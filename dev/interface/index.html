<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · SingleCellProjections.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://rasmushenningsson.github.io/SingleCellProjections.jl/interface/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SingleCellProjections.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Interface</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/main/docs/src/interface.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h1><ul><li><a href="#SingleCellProjections.DataMatrix"><code>SingleCellProjections.DataMatrix</code></a></li><li><a href="#SingleCellProjections.DataMatrix-Tuple{}"><code>SingleCellProjections.DataMatrix</code></a></li><li><a href="#SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}"><code>SingleCellProjections.DataMatrix</code></a></li><li><a href="#SingleCellProjections.LowRank"><code>SingleCellProjections.LowRank</code></a></li><li><a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.NormalizationModel</code></a></li><li><a href="#SingleCellProjections.SCTransformModel-Tuple{DataMatrix}"><code>SingleCellProjections.SCTransformModel</code></a></li><li><a href="#SingleCellProjections.SVDModel"><code>SingleCellProjections.SVDModel</code></a></li><li><a href="#LinearAlgebra.svd-Tuple{DataMatrix}"><code>LinearAlgebra.svd</code></a></li><li><a href="#SCTransform.sctransform-Tuple{DataMatrix}"><code>SCTransform.sctransform</code></a></li><li><a href="#SingleCellProjections.covariate"><code>SingleCellProjections.covariate</code></a></li><li><a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.designmatrix</code></a></li><li><a href="#SingleCellProjections.differentialexpression-Tuple{DataMatrix{&lt;:SparseArrays.SparseMatrixCSC}, AbstractVector}"><code>SingleCellProjections.differentialexpression</code></a></li><li><a href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>SingleCellProjections.filter_matrix</code></a></li><li><a href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_obs</code></a></li><li><a href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_var</code></a></li><li><a href="#SingleCellProjections.force_layout-Tuple{DataMatrix}"><code>SingleCellProjections.force_layout</code></a></li><li><a href="#SingleCellProjections.implicitsvd-Tuple{Any}"><code>SingleCellProjections.implicitsvd</code></a></li><li><a href="#SingleCellProjections.load10x-Tuple{Any}"><code>SingleCellProjections.load10x</code></a></li><li><a href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>SingleCellProjections.load_counts</code></a></li><li><a href="#SingleCellProjections.load_counts-Tuple{DataMatrix{&lt;:SingleCellProjections.Lazy10xMatrix}}"><code>SingleCellProjections.load_counts</code></a></li><li><a href="#SingleCellProjections.load_counts-Union{Tuple{DataMatrix{&lt;:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>SingleCellProjections.load_counts</code></a></li><li><a href="#SingleCellProjections.loadh5ad-Tuple{Any}"><code>SingleCellProjections.loadh5ad</code></a></li><li><a href="#SingleCellProjections.logtransform-Tuple{DataMatrix}"><code>SingleCellProjections.logtransform</code></a></li><li><a href="#SingleCellProjections.merge_counts-Tuple{Any, Any}"><code>SingleCellProjections.merge_counts</code></a></li><li><a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.normalize_matrix</code></a></li><li><a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.normalize_matrix</code></a></li><li><a href="#SingleCellProjections.obs_coordinates"><code>SingleCellProjections.obs_coordinates</code></a></li><li><a href="#SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}"><code>SingleCellProjections.project</code></a></li><li><a href="#SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{&lt;:ProjectionModel}, Vararg{Any}}"><code>SingleCellProjections.project</code></a></li><li><a href="#SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}"><code>SingleCellProjections.project</code></a></li><li><a href="#SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T&lt;:Real"><code>SingleCellProjections.splitrange</code></a></li><li><a href="#SingleCellProjections.tf_idf_transform-Tuple{DataMatrix}"><code>SingleCellProjections.tf_idf_transform</code></a></li><li><a href="#SingleCellProjections.update_matrix"><code>SingleCellProjections.update_matrix</code></a></li><li><a href="#SingleCellProjections.var_coordinates"><code>SingleCellProjections.var_coordinates</code></a></li><li><a href="#SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{&lt;:AbstractMatrix{&lt;:Integer}}, Vararg{Any}}"><code>SingleCellProjections.var_counts_fraction!</code></a></li><li><a href="#SingleCellProjections.variable_std-Tuple{DataMatrix}"><code>SingleCellProjections.variable_std</code></a></li><li><a href="#SingleCellProjections.variable_var-Tuple{DataMatrix}"><code>SingleCellProjections.variable_var</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.DataMatrix" href="#SingleCellProjections.DataMatrix"><code>SingleCellProjections.DataMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DataMatrix{T,Tv,To}</code></pre><p>A <code>DataMatrix</code> represents a matrix together with annotations for variables and observations.</p><p>Fields:</p><ul><li><code>matrix::T</code> - The matrix.</li><li><code>var::Tv</code> - Variable annotations.</li><li><code>obs::To</code> - Observation annotations.</li><li><code>var_id_cols::Vector{String}</code> - Which column(s) to use as IDs.</li><li><code>obs_id_cols::Vector{String}</code> - Which column(s) to use as IDs.</li><li><code>models::Vector{ProjectionModel}</code> - Models used in the creation of this <code>DataMatrix</code>.</li></ul><p>The rows of the <code>var</code> and <code>obs</code> tables must be unique, considering only the <code>var_id_cols</code>/<code>obs_id_cols</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}" href="#SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}"><code>SingleCellProjections.DataMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataMatrix(matrix, var, obs; var_id_cols=nothing, obs_id_cols=nothing)</code></pre><p>Create a <code>DataMatrix</code> with the given <code>matrix</code>, <code>var</code> and <code>obs</code>.</p><p>Columns to use for <code>var</code>/<code>obs</code> IDs can be explicitly set with <code>var_id_cols</code>/<code>obs_id_cols</code>. Otherwise, an attempt will be made to autodetect the ID columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.DataMatrix-Tuple{}" href="#SingleCellProjections.DataMatrix-Tuple{}"><code>SingleCellProjections.DataMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataMatrix()</code></pre><p>Create an empty DataMatrix{Matrix{Float64},DataFrame,DataFrame}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.LowRank" href="#SingleCellProjections.LowRank"><code>SingleCellProjections.LowRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LowRank</code></pre><p>A matrix decomposition <code>UVᵀ</code> where each row of <code>U</code> represents a variable and each column of <code>Vᵀ</code> represents a sample. Intended for situations where the product is low rank, i.e. <code>size(U,2)==size(Vt,1)</code> is small.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/lowrank.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}" href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.NormalizationModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NormalizationModel(data::DataMatrix, design::DesignMatrix;
                   scale=false, min_std=1e-6, annotate=true,
                   rtol=sqrt(eps()), var=:copy, obs=:copy)</code></pre><p>Create a NormalizationModel based on <code>data</code> and a <code>design</code> matrix.</p><ul><li><code>scale</code> - Set to true to normalize variables to unit standard deviation. Can also be set to a vector with a scaling factor for each variable.</li><li><code>min_std</code> - If <code>scale==true</code>, the <code>scale</code> vector is set to <code>1.0 ./ max.(std, min_std)</code>. That is, <code>min_std</code> is used to suppress variables that are very small (and any fluctuations can be assumed to be noise).</li><li><code>annotate</code> - Only used if <code>scale!=false</code>. With <code>annotate=true</code>, the <code>scale</code> vector is added as a var annotation.</li><li><code>rtol</code> - Singular values of the design matrix that are <code>≤rtol</code> are discarded. Needed for numerical stability.</li><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li></ul><p>See also: <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a>, <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/normalize.jl#L246-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.SCTransformModel-Tuple{DataMatrix}" href="#SingleCellProjections.SCTransformModel-Tuple{DataMatrix}"><code>SingleCellProjections.SCTransformModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SCTransformModel(counts::DataMatrix;
                 var_filter = hasproperty(counts.var, :feature_type) ? :feature_type =&gt; isequal(&quot;Gene Expression&quot;) : nothing,
                 rtol=1e-3, atol=0.0, annotate=true,
                 post_var_filter=:, post_obs_filter=:,
                 obs=:copy,
                 kwargs...)</code></pre><p>Computes the <code>SCTransform</code> parameter estimates for <code>counts</code> and creates a SCTransformModel that can be applied to the same or another data set. Defaults to only using &quot;Gene Expression&quot; features.</p><ul><li><code>var_filter</code> - Control which variables (features) to use for parameter estimation. Defaults to <code>:feature_type =&gt; isequal(&quot;Gene Expression&quot;)</code>, if a <code>feature_type</code> column is present in <code>counts.var</code>. Can be set to <code>nothing</code> to disable filtering. See <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a> for how to specify filters.</li><li><code>rtol</code> - Relative tolerance when constructing low rank approximation.</li><li><code>atol</code> - Absolute tolerance when constructing low rank approximation.</li><li><code>annotate</code> - Set to true to include SCTransform parameter estimates as feature annotations.</li><li><code>post_var_filter</code> - Equivalent to applying variable (feature) filtering after sctransform, but computationally more efficient.</li><li><code>post_obs_filter</code> - Equivalent to applying observation (cell) filtering after sctransform, but computationally more efficient.</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li><li><code>kwargs...</code> - Additional <code>kwargs</code> are passed on to <a href="https://github.com/rasmushenningsson/SCTransform.jl"><code>SCTransform.scparams</code></a>.</li></ul><p><strong>Examples</strong></p><p>Setup <code>SCTransformModel</code> (Gene Expression features):</p><pre><code class="nohighlight hljs">julia&gt; SCTransformModel(counts)</code></pre><p>Setup <code>SCTransformModel</code> (Antibody Capture features):</p><pre><code class="nohighlight hljs">julia&gt; SCTransformModel(counts; var_filter = :feature_type =&gt; isequal(&quot;Antibody Capture&quot;))</code></pre><p>See also: <a href="#SCTransform.sctransform-Tuple{DataMatrix}"><code>sctransform</code></a>, <a href="https://github.com/rasmushenningsson/SCTransform.jl"><code>SCTransform.scparams</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/transform.jl#L200-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.SVDModel" href="#SingleCellProjections.SVDModel"><code>SingleCellProjections.SVDModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SVDModel &lt;: ProjectionModel</code></pre><p>A model used for projecting onto an <code>SVD</code> object. Normally created using <code>svd(::DataMatrix)</code>.</p><p>See also: <a href="#LinearAlgebra.svd-Tuple{DataMatrix}"><code>svd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/reduce.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.svd-Tuple{DataMatrix}" href="#LinearAlgebra.svd-Tuple{DataMatrix}"><code>LinearAlgebra.svd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svd(data::DataMatrix; nsv=3, var=:copy, obs=:copy, kwargs...)</code></pre><p>Compute the Singular Value Decomposition (SVD) of <code>data</code> using the Random Subspace SVD algorithm from [Halko et al. &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions&quot;]. SVD is often used to perform Principal Component Analysis (PCA), which assumes that the data is centered.</p><ul><li><code>nsv</code> - The number of singular values.</li><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li></ul><p>Additional kwargs related to numerical precision are passed to <code>SingleCellProjections.implicitsvd</code>.</p><p>See also: <a href="#SingleCellProjections.implicitsvd-Tuple{Any}"><code>SingleCellProjections.implicitsvd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/reduce.jl#L24-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SCTransform.sctransform-Tuple{DataMatrix}" href="#SCTransform.sctransform-Tuple{DataMatrix}"><code>SCTransform.sctransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sctransform(counts::DataMatrix; verbose=true, kwargs...)</code></pre><p>Compute the SCTransform of the DataMatrix <code>counts</code>. The result is stored as a Matrix Expression with the sum of a sparse and a low-rank term. I.e. no large dense matrix is created.</p><p>See <code>SCTransformModel</code> for description of <code>kwargs...</code>.</p><p><strong>Examples</strong></p><p>Compute SCTransform (Gene Expression features):</p><pre><code class="nohighlight hljs">julia&gt; sctransform(counts)</code></pre><p>Compute SCTransform (Antibody Capture features):</p><pre><code class="nohighlight hljs">julia&gt; sctransform(counts; var_filter = :feature_type =&gt; isequal(&quot;Antibody Capture&quot;))</code></pre><p>See also: <a href="#SingleCellProjections.SCTransformModel-Tuple{DataMatrix}"><code>SCTransformModel</code></a>, <a href="https://github.com/rasmushenningsson/SCTransform.jl"><code>SCTransform.scparams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/transform.jl#L328-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.covariate" href="#SingleCellProjections.covariate"><code>SingleCellProjections.covariate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">covariate(name::String, type=:auto)</code></pre><p>Create a <code>covariate</code> referring to column <code>name</code>. <code>type</code> must be one of <code>:auto</code>, <code>:numerical</code>, <code>:categorical</code> and <code>:intercept</code>. <code>:auto</code> means auto-detection by checking if the values in the column are numerical or categorical. <code>type==:intercept</code> adds an intercept to the model (in which case the <code>name</code> parameter is ignored).</p><p>See also: <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/normalize.jl#L68-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.designmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">designmatrix(data::DataMatrix, [covariates...]; center=true, max_categories=100)</code></pre><p>Creates a design matrix from <code>data.obs</code> and the given <code>covariates</code>. Covariates can be specied using strings (column name in data.obs), with autodetection of whether the covariate is numerical or categorical, or using the <code>covariate</code> function for more control.</p><ul><li><code>center</code> - If <code>true</code>, an intercept is added to the design matrix. (Should only be set to <code>false</code> in very rare circumstances.)</li><li><code>max_categories</code> - Safety parameter, an error will be thrown if there are too many categories. In this case, it is likely a mistake that the covariate was used as a categorical covariate. Using a very large number of categories is also bad for performance and memory consumption.</li></ul><p><strong>Examples</strong></p><p>Centering only:</p><pre><code class="language-julia hljs">julia&gt; designmatrix(data)</code></pre><p>Regression model with intercept (centering) and &quot;fraction_mt&quot; (numerical annotation):</p><pre><code class="language-julia hljs">julia&gt; designmatrix(data, &quot;fraction_mt&quot;)</code></pre><p>As above, but also including &quot;batch&quot; (categorical annotation):</p><pre><code class="language-julia hljs">julia&gt; designmatrix(data, &quot;fraction_mt&quot;, &quot;batch&quot;)</code></pre><p>See also: <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a>, <a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>NormalizationModel</code></a>, <a href="#SingleCellProjections.covariate"><code>covariate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/normalize.jl#L162-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.differentialexpression-Tuple{DataMatrix{&lt;:SparseArrays.SparseMatrixCSC}, AbstractVector}" href="#SingleCellProjections.differentialexpression-Tuple{DataMatrix{&lt;:SparseArrays.SparseMatrixCSC}, AbstractVector}"><code>SingleCellProjections.differentialexpression</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">differentialexpression(data::DataMatrix{&lt;:SparseMatrixCSC}, groups::AbstractVector)</code></pre><p>Assumes <code>data</code> is logtransformed. <code>groups</code> should be a vector with 1 for observations in group 1, 2 for observations in group 2 and <code>missing</code> for other observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/differentialexpression.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}" href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>SingleCellProjections.filter_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_matrix(fvar, fobs, data::DataMatrix)</code></pre><p>Return a new DataMatrix, containing only the variables and observations passing the filters.</p><p><code>fvar</code>/<code>fobs</code> can be:</p><ul><li>An <code>AbstractVector</code> of indices to keep.</li><li>A <code>AbstractVector</code> of booleans (true to keep, false to discard).</li><li><code>:</code> indicating that all variables/observations should be kept.</li><li>Anything you can pass on to <code>DataFrames.filter</code> (see <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter">DataFrames documentation</a> for details).</li></ul><p>Also note that indexing of a DataMatrix supports <code>AbstractVector</code>s of indices/booleans and <code>:</code>, and is otherwise identical to <code>filter_matrix</code>.</p><p><strong>Examples</strong></p><p>Keep every 10th variable and 3rd observation:</p><pre><code class="language-julia hljs">julia&gt; filter_matrix(1:10:size(data,1), 1:3:size(data,2), data)</code></pre><p>Or, using indexing syntax:</p><pre><code class="language-julia hljs">julia&gt; data[1:10:end, 1:3:end]</code></pre><p>For more examples, see <code>filter_var</code> and <code>filter_obs</code>.</p><p>See also: <a href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>filter_var</code></a>, <a href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>filter_obs</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/filter.jl#L93-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}" href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_obs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_obs(f, data::DataMatrix)</code></pre><p>Return a new DataMatrix, containing only the observations passing the filter.</p><p><code>f</code> can be:</p><ul><li>An <code>AbstractVector</code> of indices to keep.</li><li>A <code>AbstractVector</code> of booleans (true to keep, false to discard).</li><li><code>:</code> indicating that all observations should be kept.</li><li>Anything you can pass on to <code>DataFrames.filter</code> (see DataFrames documentation for details).</li></ul><p><strong>Examples</strong></p><p>Keep every 10th observation:</p><pre><code class="language-julia hljs">julia&gt; filter_obs(1:10:size(data,2), data)</code></pre><p>Remove observations where &quot;celltype&quot; equals &quot;other&quot;:</p><pre><code class="language-julia hljs">julia&gt; filter_obs(&quot;celltype&quot;=&gt;!isequal(&quot;other&quot;), data)</code></pre><p>See also: <a href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>filter_matrix</code></a>, <a href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>filter_var</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/filter.jl#L153-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.filter_var-Tuple{Any, DataMatrix}" href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_var(f, data::DataMatrix)</code></pre><p>Return a new DataMatrix, containing only the variables passing the filter.</p><p><code>f</code> can be:</p><ul><li>An <code>AbstractVector</code> of indices to keep.</li><li>A <code>AbstractVector</code> of booleans (true to keep, false to discard).</li><li><code>:</code> indicating that all variables should be kept.</li><li>Anything you can pass on to <code>DataFrames.filter</code> (see <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter">DataFrames documentation</a> for details).</li></ul><p><strong>Examples</strong></p><p>Keep every 10th variable:</p><pre><code class="language-julia hljs">julia&gt; filter_var(1:10:size(data,1), data)</code></pre><p>Keep only variables of the type &quot;Gene Expression&quot;:</p><pre><code class="language-julia hljs">julia&gt; filter_var(&quot;feature_type&quot;=&gt;isequal(&quot;Gene Expression&quot;), data)</code></pre><p>See also: <a href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>filter_matrix</code></a>, <a href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>filter_obs</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/filter.jl#L125-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.force_layout-Tuple{DataMatrix}" href="#SingleCellProjections.force_layout-Tuple{DataMatrix}"><code>SingleCellProjections.force_layout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">force_layout(data::DataMatrix;
             ndim=3,
             k,
             adj,
             kprojection=10,
             obs=:copy,
             adj_out,
             niter = 100,
             link_distance = 4,
             link_strength = 2,
             charge = 5,
             charge_min_distance = 1,
             theta = 0.9,
             center_strength = 0.05,
             velocity_decay = 0.9,
             initialAlpha = 1.0,
             finalAlpha = 1e-3,
             initialScale = 10,
             rng)</code></pre><p>Compute the Force Layout (also known as a force directed knn-graph or SPRING plots) for <code>data</code>. Usually, <code>data</code> is a DataMatrix after reduction to <code>10-100</code> dimensions by <code>svd</code>.</p><p>A Force Layout is computed by running a physics simulation were the observations are connected by springs (such that connected observations are attracted), a general &quot;charge&quot; force repelling all observations from each other and a centering force that keep the observations around the origin. The implementation is based on d3-force: https://github.com/d3/d3-force, also see LICENSE.md.</p><p>Exactly one of the kwargs <code>k</code> and <code>adj</code> must be provided. See details below.</p><p>General parameters:</p><ul><li><code>k</code> - Number of nearest neighbors to connect each observation to (computes <code>adj</code> below).</li><li><code>adj</code> - An sparse, symmetric, adjacency matrix with booleans. <code>true</code> if two observations are connected by a spring and <code>false</code> otherwise.</li><li><code>kprojection</code> - The number of nearest neighbors used when projecting onto the resulting force layout. (Not used in the computation of the layout, only during projection.)</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li><li><code>adj_out</code> - Optional <code>Ref</code>. If specified, the (computed) <code>adj</code> matrix will be assigned to <code>adj_out</code>.</li></ul><p>Paramters controlling the physics simulation:</p><ul><li><code>niter</code> - Number of iterations to run the simulation.</li><li><code>link_distance</code> - The length of each spring.</li><li><code>link_strength</code> - The strength of the spring force.</li><li><code>charge</code> - The strength of the charge force.</li><li><code>charge_min_distance</code> - Used to avoid numerical instabilities by limiting the charge force for observations that are very close.</li><li><code>theta</code> - Parameter controlling accuracy in the Barnes-Hut approximation for charge forces.</li><li><code>center_strength</code> - Strength of the centering force.</li><li><code>velocity_decay</code> - At each iteration, the current velocity for an observations is multiplied by <code>velocity_decay</code>.</li><li><code>initialAlpha</code> - The alpha value decreases over time and allows larger changes to happen early, while being more stable towards the end.</li><li><code>finalAlpha</code> - See <code>initialAlpha</code></li><li><code>initialScale</code> - The simulation is initialized by randomly drawing each observation from a multivariate Gaussian, and is scaled by <code>initialScale</code>.</li><li><code>rng</code> - Optional RNG object. Useful for reproducibility.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; force_layout(data; ndim=3, k=100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/reduce.jl#L92-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.implicitsvd-Tuple{Any}" href="#SingleCellProjections.implicitsvd-Tuple{Any}"><code>SingleCellProjections.implicitsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">implicitsvd(A; nsv=3, subspacedims=4nsv, niter=2, stabilize_sign=true, rng)</code></pre><p>Compute the SVD of <code>A</code> using Random Subspace SVD. [Halko et al. &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions&quot;]</p><ul><li><code>nsv</code> - Number of singular values/vectors to compute</li><li><code>subspacedims</code> - Number of dimensions used for the subspace approximating the action of <code>A</code>.</li><li><code>niter</code> - Number of iterations. In each iteration, one multiplication of <code>A</code> with a matrix and one multiplication of <code>A&#39;</code> with a matrix will be performed.</li><li><code>stabilize_sign</code> - If true, handles the problem that the SVD is only unique up to the sign of each component (for real matrices), by ensuring that the l1 norm of the positive entires for each column in U is larger than the l1 norm of the negative entries.</li><li><code>rng</code> - Specify a custom RNG.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/implicitsvd.jl#L60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.load10x-Tuple{Any}" href="#SingleCellProjections.load10x-Tuple{Any}"><code>SingleCellProjections.load10x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load10x(filename; lazy=false, copy_obs_col=&quot;barcode&quot;=&gt;&quot;id&quot;, kwargs...)</code></pre><p>Load a CellRanger &quot;.h5&quot; or &quot;.mtx[.gz]&quot; file as a DataMatrix.</p><ul><li><code>lazy</code> - If <code>true</code>, the count matrix itself will not be loaded, only features and barcodes. This is used internally in <code>load_counts</code> to merge samples more efficiently. Use <code>load_counts</code> to later load the count data.</li><li><code>copy_obs_col</code> - Set to nothing to disable. Defaults to a pair <code>&quot;barcode&quot;=&gt;&quot;id&quot;</code>, which copies the <code>obs</code> annotation <code>barcode</code> to a new column <code>id</code>.</li><li>Additional <code>kwargs...</code> are passed to the DataMatrix constructor.</li></ul><p><strong>Examples</strong></p><p>Load counts from a CellRanger &quot;.h5&quot; file. (Recommended.)</p><pre><code class="language-julia hljs">julia&gt; counts = load10x(&quot;filtered_feature_bc_matrix.h5&quot;)</code></pre><p>Load counts from a CellRanger &quot;.mtx&quot; file. Tries to find barcode and feature annotation files in the same folder.</p><pre><code class="language-julia hljs">julia&gt; counts = load10x(&quot;matrix.mtx.gz&quot;)</code></pre><p>Lazy loading followed by loading.</p><pre><code class="language-julia hljs">julia&gt; counts = load10x(&quot;filtered_feature_bc_matrix.h5&quot;);
julia&gt; counts = load_counts(counts)</code></pre><p>See also: <a href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>load_counts</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/load.jl#L88-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.load_counts-Tuple{Any, Any}" href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>SingleCellProjections.load_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_counts([loadfun=load10x], filenames;
            sample_names,
            sample_name_col,
            merged_obs_id_col = &quot;id&quot;,
            lazy,
            lazy_merge = false,
            var_id_cols=nothing,
            merged_obs_id_delim = &#39;_&#39;,
            callback=nothing)</code></pre><p>Load and merge multiple samples efficiently.</p><p>Defaults to loading 10x CellRanger files. The files are first loaded lazily, then the merged count matrix is allocated and finally each sample is loaded directly into the merged count matrix. (This strategy greatly reduces memory usage, since only one copy of data is needed instead of two.)</p><p>The vector <code>filenames</code> specifies which files to load. For each file, <code>loadfun</code> is called.</p><ul><li><code>sample_names</code> - Specify the sample names. Should be a vector of the same length as <code>filenames</code>. Set to <code>nothing</code> to not create a sample name annotation.</li><li><code>sample_name_col</code> - Column for sample names in <code>obs</code>, defaults to &quot;sampleName&quot;.</li><li><code>merged_obs_id_col</code> - Colum for merged <code>id</code>s in <code>obs</code>.</li><li><code>lazy</code> - Enable lazy loading. Defaults to true if <code>load10x</code> is used, and <code>false</code> otherwise.</li><li><code>lazy_merge</code> - Enable lazy merging, i.e. <code>var</code> and <code>obs</code> are created, but the count matrix merging is postponed until a second call to <code>load_counts</code>.</li><li><code>var_id_cols</code> - Specify variable id columns. Defaults to <code>nothing</code>, i.e. autodetecting from the samples.</li><li><code>merged_obs_id_delim</code> - Delimiter used when creating merged <code>obs</code> IDs.</li><li><code>callback</code> - Experimental callback functionality. The callback function is called between samples during merging. Return <code>true</code> to abort loading and <code>false</code> to continue.</li></ul><p><strong>Examples</strong></p><p>Load and name samples:</p><pre><code class="language-julia hljs">julia&gt; counts = load_counts([&quot;s1.h5&quot;, &quot;s2.h5&quot;]; sample_names=[&quot;Sample A&quot;, &quot;Sample B&quot;])</code></pre><p>See also: <a href="#SingleCellProjections.load10x-Tuple{Any}"><code>load10x</code></a>, <a href="#SingleCellProjections.merge_counts-Tuple{Any, Any}"><code>merge_counts</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/load.jl#L136-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.load_counts-Tuple{DataMatrix{&lt;:SingleCellProjections.Lazy10xMatrix}}" href="#SingleCellProjections.load_counts-Tuple{DataMatrix{&lt;:SingleCellProjections.Lazy10xMatrix}}"><code>SingleCellProjections.load_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_counts(data::DataMatrix{&lt;:Lazy10xMatrix})</code></pre><p>Load counts for a lazily loaded 10x DataMatrix.</p><p>See also: <a href="#SingleCellProjections.load10x-Tuple{Any}"><code>load10x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/load.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.load_counts-Union{Tuple{DataMatrix{&lt;:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#SingleCellProjections.load_counts-Union{Tuple{DataMatrix{&lt;:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>SingleCellProjections.load_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_counts(data::DataMatrix{&lt;:LazyMergedMatrix})</code></pre><p>Merge/load counts for a lazily merged DataMatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/load.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.loadh5ad-Tuple{Any}" href="#SingleCellProjections.loadh5ad-Tuple{Any}"><code>SingleCellProjections.loadh5ad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadh5ad(filename; var_id_column=:id, obs_id_column=:id)</code></pre><p>Experimental loading of .h5ad files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/h5ad.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.logtransform-Tuple{DataMatrix}" href="#SingleCellProjections.logtransform-Tuple{DataMatrix}"><code>SingleCellProjections.logtransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logtransform(counts::DataMatrix; scale_factor=10_000, var=:copy, obs=:copy)</code></pre><p>Log-transform <code>counts</code> using the formula:</p><pre><code class="nohighlight hljs">  log(1 + cᵢⱼ*scale_factor/(∑ᵢcᵢⱼ))</code></pre><ul><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; transformed = logtransform(counts)</code></pre><p>See also: <a href="#SCTransform.sctransform-Tuple{DataMatrix}"><code>sctransform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/transform.jl#L63-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.merge_counts-Tuple{Any, Any}" href="#SingleCellProjections.merge_counts-Tuple{Any, Any}"><code>SingleCellProjections.merge_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_counts(samples, sample_names;
             lazy=false,
             var_id_cols=nothing,
             sample_name_col = sample_names===nothing ? nothing : &quot;sampleName&quot;,
             merged_obs_id_col = &quot;id&quot;,
             merged_obs_id_delim = &#39;_&#39;,
             callback=nothing)</code></pre><p>Merge <code>samples</code> to create one large DataMatrix, by concatenating the <code>obs</code>. The union of the variables from the samples is used, and if a variable is not present in a sample, the count will be set to zero.</p><p>The <code>obs</code> IDs are created by concatenating the current <code>obs</code> ID columns, together with the <code>sample_names</code> (if provided).</p><ul><li><code>lazy</code> - Lazy merging. Use <code>load_counts</code> to actually perform the merging.</li><li><code>var_id_cols</code> - Set to <code>nothing</code> to autodetect from the samples.</li><li><code>sample_name_col</code> - Column in which the <code>sample_names</code> are stored.</li><li><code>merged_obs_id_col</code> - <code>obs</code> ID column after merging. Set to <code>nothing</code> to keep current ID cols (will add <code>sampleName</code> as a separate ID column, if provided.)</li><li><code>merged_obs_id_delim</code> - Delimiter used when merging <code>obs</code> IDs.</li><li><code>callback</code> - Experimental callback functionality. The callback function is called between samples during merging. Return <code>true</code> to abort loading and <code>false</code> to continue.</li></ul><p>See also: <a href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>load_counts</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/load.jl#L299-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}" href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.normalize_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_matrix(data::DataMatrix, design::DesignMatrix; scale=false, kwargs...)</code></pre><p>Normalize <code>data</code> using the specified <code>design</code> matrix.</p><p>See also: <a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>NormalizationModel</code></a>, <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/normalize.jl#L355-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.normalize_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_matrix(data::DataMatrix, [covariates...]; center=true, scale=false, kwargs...)</code></pre><p>Normalize <code>data</code>. By default, the matrix is centered. Any <code>covariates</code> specified (using column names of <code>data.obs</code>) will be regressed out.</p><ul><li><code>center</code> - Set to true to center the data matrix.</li><li><code>scale</code> - Set to true to scale the variables in the data matrix to unit standard deviation.</li></ul><p>For other <code>kwargs</code> and more detailed descriptions, see <code>NormalizationModel</code> and <code>designmatrix</code>.</p><p><strong>Examples</strong></p><p>Centering only:</p><pre><code class="language-julia hljs">julia&gt; normalize_matrix(data)</code></pre><p>Regression model with intercept (centering) and &quot;fraction_mt&quot; (numerical annotation):</p><pre><code class="language-julia hljs">julia&gt; normalize_matrix(data, &quot;fraction_mt&quot;)</code></pre><p>As above, but also including &quot;batch&quot; (categorical annotation):</p><pre><code class="language-julia hljs">julia&gt; normalize_matrix(data, &quot;fraction_mt&quot;, &quot;batch&quot;)</code></pre><p>See also: <a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>NormalizationModel</code></a>, <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/normalize.jl#L367-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.obs_coordinates" href="#SingleCellProjections.obs_coordinates"><code>SingleCellProjections.obs_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">obs_coordinates(data::DataMatrix)</code></pre><p>Returns a matrix with coordinates for the observations. Not available for all types of DataMatrices. Mostly useful for data matrices after dimension reduction such as <code>svd</code> or <code>force_layout</code> has been applied.</p><p>In the case of <code>SVD</code> (PCA), <code>obs_coordinates</code> returns the principal components, scaled by the singular values. This is a a good starting point for downstream analysis, since it is the optimal linear approximation of the original data for the given number of dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L101-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{&lt;:ProjectionModel}, Vararg{Any}}" href="#SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{&lt;:ProjectionModel}, Vararg{Any}}"><code>SingleCellProjections.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)</code></pre><p>Convenience function for projection onto multiple models. Essentially calls <code>foldl</code> and prints some <code>@info</code> messages (if <code>verbose=true</code>). In most cases, it is better to call <code>project(data, base::DataMatrix)</code> instead of using this method directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}" href="#SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}"><code>SingleCellProjections.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(data::DataMatrix, base::DataMatrix, args...; from=nothing, kwargs...)</code></pre><p>Project <code>data</code> onto <code>base</code>, by applying ProjectionModels from <code>base</code> one by one.</p><p>Since <code>data</code> already might have some models applied, <code>project</code> will try to figure out which models from <code>base</code> to use. See &quot;Examples&quot; below for concrete examples. Here&#39;s a more technical overview:</p><p>Consider a <code>base</code> data matrix with four models:</p><pre><code class="nohighlight hljs">base: A -&gt; B -&gt; C -&gt; D</code></pre><p>Given some new <code>data</code> (typically counts), we can project that onto <code>base</code>, given the result <code>proj</code> by applying all four models:</p><pre><code class="nohighlight hljs">data:
proj: A -&gt; B -&gt; C -&gt; D</code></pre><p>If <code>data</code> already has some models applied (e.g. we already projected onto A and B above), <code>project</code> will look for the last model in <code>data</code> (in this case B) in the list of models in <code>base</code>, and only apply models after that (in this case C and D).</p><pre><code class="nohighlight hljs">data: A -&gt; B
proj: A -&gt; B -&gt; C -&gt; D</code></pre><p>It is also possible to use the <code>from</code> kwarg to specify exactly which models to apply. (The models in <code>from</code> must be a prefix of the models in <code>base</code>, or in other words, <code>base</code> was created by applying additional operations to <code>from</code>.)</p><pre><code class="nohighlight hljs">data: X
base: A -&gt; B -&gt; C -&gt; D
from: A -&gt; B
proj: X -&gt; C -&gt; D</code></pre><p>Note that it is necessary to use the <code>from</code> kwarg if the last model in <code>data</code> does not occurr in <code>base</code>, because <code>project</code> cannot figure out on its own which models it makes sense to apply.</p><p><strong>Examples</strong></p><p>First, we construct a &quot;base&quot; by loading counts, SCTransforming, normalizing, computing the svd and finally computing a force layout:</p><pre><code class="language-julia hljs">julia&gt; fp = [&quot;GSE164378_RNA_ADT_3P_P1.h5&quot;, &quot;GSE164378_RNA_ADT_3P_P2.h5&quot;];
julia&gt; counts = load_counts(fp; sample_names=[&quot;P1&quot;,&quot;P2&quot;]);
julia&gt; transformed = sctransform(counts);
julia&gt; normalized = normalize_matrix(transformed);
julia&gt; reduced = svd(normalized; nsv=10);
julia&gt; fl = force_layout(reduced; ndim=3, k=100)
  DataMatrix (3 variables and 35340 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform</code></pre><p>Note how the last line lists all <code>ProjectionModels</code> used in the creation of <code>fl</code>.</p><p>Next, let&#39;s load some more samples for projection:</p><pre><code class="language-julia hljs">julia&gt; fp2 = [&quot;GSE164378_RNA_ADT_3P_P5.h5&quot;, &quot;GSE164378_RNA_ADT_3P_P6.h5&quot;];
julia&gt; counts2 = load_counts(fp2; sample_names=[&quot;P5&quot;,&quot;P6&quot;]);</code></pre><p>It is easy to project the newly loaded <code>counts2</code> onto the &quot;base&quot; force layout <code>fl</code>:</p><pre><code class="language-julia hljs">julia&gt; project(counts2, fl)
DataMatrix (3 variables and 42553 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform</code></pre><p>We can also project in two or more steps, to get access to intermediate results:</p><pre><code class="language-julia hljs">julia&gt; reduced2 = project(counts2, reduced)
DataMatrix (20239 variables and 42553 observations)
  SVD (10 dimensions)
  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: id, sampleName, barcode
  Models: SVDModel(nsv=10), Normalization, SCTransform

julia&gt; project(reduced2, fl)
DataMatrix (3 variables and 42553 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform</code></pre><p>If the DataMatrix we want to project is modified, we need to use the <code>from</code> kwarg to tell <code>project</code> which models to use:</p><pre><code class="language-julia hljs">julia&gt; filtered = counts2[:,1:10:end]
DataMatrix (33766 variables and 4256 observations)
  SparseArrays.SparseMatrixCSC{Int64, Int32}
  Variables: id, feature_type, name, genome, read, pattern, sequence
  Observations: id, sampleName, barcode
  Models: FilterModel(:, 1:10:42551)

julia&gt; reduced2b = project(filtered2, reduced; from=counts)
DataMatrix (20239 variables and 4256 observations)
  SVD (10 dimensions)
  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: id, sampleName, barcode
  Models: SVDModel(nsv=10), Normalization, SCTransform, Filter</code></pre><p>After that, it is possible to continue without specifying <code>from</code>:</p><pre><code class="language-julia hljs">julia&gt; project(reduced2b, fl)
DataMatrix (3 variables and 4256 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform, Filter</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L168-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}" href="#SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}"><code>SingleCellProjections.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)</code></pre><p>Core projection function. Project <code>data</code> based on the single <code>ProjectionModel</code> <code>model</code>. In most cases, it is better to call <code>project(data, base::DataMatrix)</code> instead of using this method directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T&lt;:Real" href="#SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T&lt;:Real"><code>SingleCellProjections.splitrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitrange(r::UnitRange, nparts::Integer)</code></pre><p>Splits a range in <code>nparts</code> number of parts of equal length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.tf_idf_transform-Tuple{DataMatrix}" href="#SingleCellProjections.tf_idf_transform-Tuple{DataMatrix}"><code>SingleCellProjections.tf_idf_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tf_idf_transform(counts::DataMatrix;
                 scale_factor = 10_000,
                 idf = vec(size(counts,2) ./ max.(1,sum(counts.matrix; dims=2))),
                 annotate = true,
                 var = :copy,
                 obs = :copy)</code></pre><p>Compute the TF-IDF (term frequency-inverse document frequency) transform of <code>counts</code>, using the formula <code>log( 1 + scale_factor * tf * idf )</code> where <code>tf</code> is the term frequency <code>counts.matrix ./ max.(1, sum(counts.matrix; dims=1))</code>.</p><p>If <code>annotate</code> is true, <code>idf</code> will be added as a <code>var</code> annotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/transform.jl#L170-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.update_matrix" href="#SingleCellProjections.update_matrix"><code>SingleCellProjections.update_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_matrix(data::DataMatrix, matrix, model=nothing;
              var::Union{Symbol,String,DataFrame} = &quot;&quot;,
              obs::Union{Symbol,String,DataFrame} = &quot;&quot;,
              var_id_cols,
              obs_id_cols)</code></pre><p>Create a new <code>DataMatrix</code> by replacing parts of <code>data</code> with new values. Mostly useful when implementing new <code>ProjectionModel</code>s.</p><ul><li><code>matrix</code> - the new matrix.</li><li><code>model</code> - will be appended to the list of models from <code>data</code>. If set to <code>nothing</code>, the resulting list of <code>models</code> will be empty.</li></ul><p>Kwargs:</p><ul><li><code>var</code> - One of:<ul><li><code>:copy</code> - Copy from <code>data</code>.</li><li><code>:keep</code> - Share <code>var</code> with <code>data</code>.</li><li><code>::DataFrame</code> - Replace with a new table with variable annotations.</li><li><code>prefix::String</code> - Prefix, the new variables will be named prefix1, prefix2, etc.</li></ul></li><li><code>obs</code> See <code>var</code>.</li><li><code>var_id_cols</code> - New ID columns. Defaults to the same as data, or &quot;id&quot; if new variables were generated using the &quot;prefix&quot; above.</li><li><code>obs_id_cols</code> - See <code>var_id_cols</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L297-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.var_coordinates" href="#SingleCellProjections.var_coordinates"><code>SingleCellProjections.var_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">var_coordinates(data::DataMatrix)</code></pre><p>Returns a matrix with coordinates for the variables. Only available for DataMatrices that have a dual representation (e.g. SVD/PCA).</p><p>In the case of <code>SVD</code> (PCA), <code>var_coordinates</code> returns the principal components as unit vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/datamatrix.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{&lt;:AbstractMatrix{&lt;:Integer}}, Vararg{Any}}" href="#SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{&lt;:AbstractMatrix{&lt;:Integer}}, Vararg{Any}}"><code>SingleCellProjections.var_counts_fraction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var_counts_fraction!(counts::DataMatrix, sub_filter, tot_filter, col; check=true)</code></pre><p>For each observation, compute the fraction of counts that match a specific variable pattern.</p><ul><li><code>sub_filter</code> decides which variables are counted.</li><li><code>tot_filter</code> decides which variables to include in the total.</li><li>If <code>check=true</code>, an error will be thrown if no variables match the patterns.</li></ul><p>For more information on filtering syntax, see examples below and the documentation on <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a>.</p><p><strong>Examples</strong></p><p>Compute the fraction of reads in MT- genes, considering only &quot;Gene Expression&quot; features (and not e.g. &quot;Antibody Capture&quot;).</p><pre><code class="nohighlight hljs">var_counts_fraction!(counts, &quot;name&quot;=&gt;contains(r&quot;^MT-&quot;), &quot;feature_type&quot;=&gt;isequal(&quot;Gene Expression&quot;), &quot;fraction_mt&quot;)</code></pre><p>Compute the fraction of reads in MT- genes, when there is no <code>feature_type</code> annotation (i.e. all variables are genes).</p><pre><code class="nohighlight hljs">var_counts_fraction!(counts, &quot;name&quot;=&gt;contains(r&quot;^MT-&quot;), Returns(true), &quot;fraction_mt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/counts_fraction.jl#L66-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.variable_std-Tuple{DataMatrix}" href="#SingleCellProjections.variable_std-Tuple{DataMatrix}"><code>SingleCellProjections.variable_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_std(data::DataMatrix)</code></pre><p>Computes the variance of each variable in <code>data</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>data</code> must be mean-centered. E.g. by using <code>normalize_matrix</code> before calling <code>variable_std</code>.</p></div></div><p>See also: <a href="#SingleCellProjections.variable_var-Tuple{DataMatrix}"><code>variable_var</code></a>, <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/normalize.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SingleCellProjections.variable_var-Tuple{DataMatrix}" href="#SingleCellProjections.variable_var-Tuple{DataMatrix}"><code>SingleCellProjections.variable_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_var(data::DataMatrix)</code></pre><p>Computes the variance of each variable in <code>data</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>data</code> must be mean-centered. E.g. by using <code>normalize_matrix</code> before calling <code>variable_var</code>.</p></div></div><p>See also: <a href="#SingleCellProjections.variable_std-Tuple{DataMatrix}"><code>variable_std</code></a>, <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/ea2b0ecc19d454146d2fcad47c086d75d1a7cb26/src/normalize.jl#L2-L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 March 2023 14:54">Friday 3 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
