<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · SingleCellProjections.jl</title><meta name="title" content="Interface · SingleCellProjections.jl"/><meta property="og:title" content="Interface · SingleCellProjections.jl"/><meta property="twitter:title" content="Interface · SingleCellProjections.jl"/><meta name="description" content="Documentation for SingleCellProjections.jl."/><meta property="og:description" content="Documentation for SingleCellProjections.jl."/><meta property="twitter:description" content="Documentation for SingleCellProjections.jl."/><meta property="og:url" content="https://BioJulia.github.io/SingleCellProjections.jl/interface/"/><meta property="twitter:url" content="https://BioJulia.github.io/SingleCellProjections.jl/interface/"/><link rel="canonical" href="https://BioJulia.github.io/SingleCellProjections.jl/interface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SingleCellProjections.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../datamatrices/">Data Matrices</a></li><li><a class="tocitem" href="../matrixexpressions/">Matrix Expressions</a></li><li class="is-active"><a class="tocitem" href>Interface</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/main/docs/src/interface.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h1><ul><li><a href="#SingleCellProjections.DataMatrix"><code>SingleCellProjections.DataMatrix</code></a></li><li><a href="#SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}"><code>SingleCellProjections.DataMatrix</code></a></li><li><a href="#SingleCellProjections.DataMatrix-Tuple{}"><code>SingleCellProjections.DataMatrix</code></a></li><li><a href="#SingleCellProjections.LowRank"><code>SingleCellProjections.LowRank</code></a></li><li><a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.NormalizationModel</code></a></li><li><a href="#SingleCellProjections.PseudoBulkModel"><code>SingleCellProjections.PseudoBulkModel</code></a></li><li><a href="#SingleCellProjections.SCTransformModel-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SingleCellProjections.SCTransformModel</code></a></li><li><a href="#SingleCellProjections.SVDModel"><code>SingleCellProjections.SVDModel</code></a></li><li><a href="#Base.copy-Tuple{DataMatrix}"><code>Base.copy</code></a></li><li><a href="#LinearAlgebra.svd-Tuple{DataMatrix}"><code>LinearAlgebra.svd</code></a></li><li><a href="#SCTransform.sctransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SCTransform.sctransform</code></a></li><li><a href="#SingleCellProjections.adjacency_distances"><code>SingleCellProjections.adjacency_distances</code></a></li><li><a href="#SingleCellProjections.covariate"><code>SingleCellProjections.covariate</code></a></li><li><a href="#SingleCellProjections.covariate"><code>SingleCellProjections.covariate</code></a></li><li><a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.designmatrix</code></a></li><li><a href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>SingleCellProjections.filter_matrix</code></a></li><li><a href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_obs</code></a></li><li><a href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_var</code></a></li><li><a href="#SingleCellProjections.force_layout-Tuple{DataMatrix}"><code>SingleCellProjections.force_layout</code></a></li><li><a href="#SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ftest</code></a></li><li><a href="#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}"><code>SingleCellProjections.ftest!</code></a></li><li><a href="#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}"><code>SingleCellProjections.ftest_table</code></a></li><li><a href="#SingleCellProjections.implicitsvd-Tuple{Any}"><code>SingleCellProjections.implicitsvd</code></a></li><li><a href="#SingleCellProjections.load10x-Tuple{Any}"><code>SingleCellProjections.load10x</code></a></li><li><a href="#SingleCellProjections.load_counts-Tuple{DataMatrix{&lt;:SingleCellProjections.Lazy10xMatrix}}"><code>SingleCellProjections.load_counts</code></a></li><li><a href="#SingleCellProjections.load_counts-Union{Tuple{DataMatrix{&lt;:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>SingleCellProjections.load_counts</code></a></li><li><a href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>SingleCellProjections.load_counts</code></a></li><li><a href="#SingleCellProjections.loadh5ad-Tuple{Any}"><code>SingleCellProjections.loadh5ad</code></a></li><li><a href="#SingleCellProjections.local_outlier_factor!-Tuple{DataMatrix, DataMatrix}"><code>SingleCellProjections.local_outlier_factor!</code></a></li><li><a href="#SingleCellProjections.local_outlier_factor_projection!-NTuple{4, DataMatrix}"><code>SingleCellProjections.local_outlier_factor_projection!</code></a></li><li><a href="#SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SingleCellProjections.logtransform</code></a></li><li><a href="#SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.mannwhitney</code></a></li><li><a href="#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.mannwhitney!</code></a></li><li><a href="#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.mannwhitney_table</code></a></li><li><a href="#SingleCellProjections.merge_counts-Tuple{Any, Any}"><code>SingleCellProjections.merge_counts</code></a></li><li><a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.normalize_matrix</code></a></li><li><a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.normalize_matrix</code></a></li><li><a href="#SingleCellProjections.obs_coordinates"><code>SingleCellProjections.obs_coordinates</code></a></li><li><a href="#SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}"><code>SingleCellProjections.project</code></a></li><li><a href="#SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}"><code>SingleCellProjections.project</code></a></li><li><a href="#SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{&lt;:ProjectionModel}, Vararg{Any}}"><code>SingleCellProjections.project</code></a></li><li><a href="#SingleCellProjections.pseudobulk-Tuple{DataMatrix, Any, Vararg{String}}"><code>SingleCellProjections.pseudobulk</code></a></li><li><a href="#SingleCellProjections.set_obs_id_cols!-Tuple{DataMatrix, Vector{String}}"><code>SingleCellProjections.set_obs_id_cols!</code></a></li><li><a href="#SingleCellProjections.set_var_id_cols!-Tuple{DataMatrix, Vector{String}}"><code>SingleCellProjections.set_var_id_cols!</code></a></li><li><a href="#SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T&lt;:Real"><code>SingleCellProjections.splitrange</code></a></li><li><a href="#SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SingleCellProjections.tf_idf_transform</code></a></li><li><a href="#SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ttest</code></a></li><li><a href="#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ttest!</code></a></li><li><a href="#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ttest_table</code></a></li><li><a href="#SingleCellProjections.update_matrix"><code>SingleCellProjections.update_matrix</code></a></li><li><a href="#SingleCellProjections.ustatistic_single-Union{Tuple{T}, Tuple{AbstractSparseMatrix{T}, Vararg{Any, 4}}} where T"><code>SingleCellProjections.ustatistic_single</code></a></li><li><a href="#SingleCellProjections.var_coordinates"><code>SingleCellProjections.var_coordinates</code></a></li><li><a href="#SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{&lt;:AbstractMatrix{&lt;:Integer}}, Vararg{Any}}"><code>SingleCellProjections.var_counts_fraction!</code></a></li><li><a href="#SingleCellProjections.variable_std-Tuple{DataMatrix}"><code>SingleCellProjections.variable_std</code></a></li><li><a href="#SingleCellProjections.variable_var-Tuple{DataMatrix}"><code>SingleCellProjections.variable_var</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.DataMatrix" href="#SingleCellProjections.DataMatrix"><code>SingleCellProjections.DataMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DataMatrix{T,Tv,To}</code></pre><p>A <code>DataMatrix</code> represents a matrix together with annotations for variables and observations.</p><p>Fields:</p><ul><li><code>matrix::T</code> - The matrix.</li><li><code>var::Tv</code> - Variable annotations.</li><li><code>obs::To</code> - Observation annotations.</li><li><code>var_id_cols::Vector{String}</code> - Which column(s) to use as IDs.</li><li><code>obs_id_cols::Vector{String}</code> - Which column(s) to use as IDs.</li><li><code>models::Vector{ProjectionModel}</code> - Models used in the creation of this <code>DataMatrix</code>.</li></ul><p>The rows of the <code>var</code> and <code>obs</code> tables must be unique, considering only the <code>var_id_cols</code>/<code>obs_id_cols</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}" href="#SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}"><code>SingleCellProjections.DataMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataMatrix(matrix, var, obs; var_id_cols=nothing, obs_id_cols=nothing)</code></pre><p>Create a <code>DataMatrix</code> with the given <code>matrix</code>, <code>var</code> and <code>obs</code>.</p><p>Columns to use for <code>var</code>/<code>obs</code> IDs can be explicitly set with <code>var_id_cols</code>/<code>obs_id_cols</code>. Otherwise, an attempt will be made to autodetect the ID columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.DataMatrix-Tuple{}" href="#SingleCellProjections.DataMatrix-Tuple{}"><code>SingleCellProjections.DataMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataMatrix()</code></pre><p>Create an empty DataMatrix{Matrix{Float64},DataFrame,DataFrame}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.LowRank" href="#SingleCellProjections.LowRank"><code>SingleCellProjections.LowRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LowRank</code></pre><p>A matrix decomposition <code>UVᵀ</code> where each row of <code>U</code> represents a variable and each column of <code>Vᵀ</code> represents a sample. Intended for situations where the product is low rank, i.e. <code>size(U,2)==size(Vt,1)</code> is small.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/lowrank.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}" href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.NormalizationModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NormalizationModel(data::DataMatrix, design::DesignMatrix;
                   scale=false, min_std=1e-6, annotate=true,
                   rtol=sqrt(eps()), var=:copy, obs=:copy)</code></pre><p>Create a NormalizationModel based on <code>data</code> and a <code>design</code> matrix.</p><ul><li><code>scale</code> - Set to true to normalize variables to unit standard deviation. Can also be set to a vector with a scaling factor for each variable.</li><li><code>min_std</code> - If <code>scale==true</code>, the <code>scale</code> vector is set to <code>1.0 ./ max.(std, min_std)</code>. That is, <code>min_std</code> is used to suppress variables that are very small (and any fluctuations can be assumed to be noise).</li><li><code>annotate</code> - Only used if <code>scale!=false</code>. With <code>annotate=true</code>, the <code>scale</code> vector is added as a var annotation.</li><li><code>rtol</code> - Singular values of the design matrix that are <code>≤rtol</code> are discarded. Needed for numerical stability.</li><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li></ul><p>See also: <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a>, <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/normalize.jl#L85-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.PseudoBulkModel" href="#SingleCellProjections.PseudoBulkModel"><code>SingleCellProjections.PseudoBulkModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PseudoBulkModel &lt;: ProjectionModel</code></pre><p>A model used for computing a &quot;pseudo-bulk&quot; representation of a DataMatrix.</p><p>See also: <a href="#SingleCellProjections.pseudobulk-Tuple{DataMatrix, Any, Vararg{String}}"><code>pseudobulk</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/pseudobulk.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.SCTransformModel-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T" href="#SingleCellProjections.SCTransformModel-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SingleCellProjections.SCTransformModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SCTransformModel([T=Float64], counts::DataMatrix;
                 var_filter = hasproperty(counts.var, :feature_type) ? :feature_type =&gt; isequal(&quot;Gene Expression&quot;) : nothing,
                 rtol=1e-3, atol=0.0, annotate=true,
                 post_var_filter=:, post_obs_filter=:,
                 obs=:copy,
                 kwargs...)</code></pre><p>Computes the <code>SCTransform</code> parameter estimates for <code>counts</code> and creates a SCTransformModel that can be applied to the same or another data set. Defaults to only using &quot;Gene Expression&quot; features.</p><p>Optionally, <code>T</code> can be specified to control the <code>eltype</code> of the sparse transformed matrix. <code>T=Float32</code> can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.</p><ul><li><code>var_filter</code> - Control which variables (features) to use for parameter estimation. Defaults to <code>:feature_type =&gt; isequal(&quot;Gene Expression&quot;)</code>, if a <code>feature_type</code> column is present in <code>counts.var</code>. Can be set to <code>nothing</code> to disable filtering. See <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a> for how to specify filters.</li><li><code>rtol</code> - Relative tolerance when constructing low rank approximation.</li><li><code>atol</code> - Absolute tolerance when constructing low rank approximation.</li><li><code>annotate</code> - Set to true to include SCTransform parameter estimates as feature annotations.</li><li><code>post_var_filter</code> - Equivalent to applying variable (feature) filtering after sctransform, but computationally more efficient.</li><li><code>post_obs_filter</code> - Equivalent to applying observation (cell) filtering after sctransform, but computationally more efficient.</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li><li><code>kwargs...</code> - Additional <code>kwargs</code> are passed on to <a href="https://github.com/rasmushenningsson/SCTransform.jl"><code>SCTransform.scparams</code></a>.</li></ul><p><strong>Examples</strong></p><p>Setup <code>SCTransformModel</code> (Gene Expression features):</p><pre><code class="nohighlight hljs">julia&gt; SCTransformModel(counts)</code></pre><p>Setup <code>SCTransformModel</code> (Antibody Capture features):</p><pre><code class="nohighlight hljs">julia&gt; SCTransformModel(counts; var_filter = :feature_type =&gt; isequal(&quot;Antibody Capture&quot;))</code></pre><p>See also: <a href="#SCTransform.sctransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>sctransform</code></a>, <a href="https://github.com/rasmushenningsson/SCTransform.jl"><code>SCTransform.scparams</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/transform.jl#L245-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.SVDModel" href="#SingleCellProjections.SVDModel"><code>SingleCellProjections.SVDModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SVDModel &lt;: ProjectionModel</code></pre><p>A model used for projecting onto an <code>SVD</code> object. Normally created using <code>svd(::DataMatrix)</code>.</p><p>See also: <a href="#LinearAlgebra.svd-Tuple{DataMatrix}"><code>svd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/reduce.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{DataMatrix}" href="#Base.copy-Tuple{DataMatrix}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(data::DataMatrix; var=:copy, obs=:copy, matrix=:keep)</code></pre><p>Copy DataMatrix <code>data</code>. By default, <code>var</code> and <code>obs</code> annotations are copied, but the <code>matrix</code> is shared. Set kwargs <code>var</code>, <code>obs</code> and <code>matrix</code> to <code>:keep</code>/<code>:copy</code> for fine grained control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.svd-Tuple{DataMatrix}" href="#LinearAlgebra.svd-Tuple{DataMatrix}"><code>LinearAlgebra.svd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svd(data::DataMatrix; nsv=3, var=:copy, obs=:copy, kwargs...)</code></pre><p>Compute the Singular Value Decomposition (SVD) of <code>data</code> using the Random Subspace SVD algorithm from [Halko et al. &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions&quot;]. SVD is often used to perform Principal Component Analysis (PCA), which assumes that the data is centered.</p><ul><li><code>nsv</code> - The number of singular values.</li><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li></ul><p>Additional kwargs related to numerical precision are passed to <code>SingleCellProjections.implicitsvd</code>.</p><p>See also: <a href="#SingleCellProjections.implicitsvd-Tuple{Any}"><code>SingleCellProjections.implicitsvd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/reduce.jl#L24-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SCTransform.sctransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T" href="#SCTransform.sctransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SCTransform.sctransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sctransform([T=Float64], counts::DataMatrix; verbose=true, kwargs...)</code></pre><p>Compute the SCTransform of the DataMatrix <code>counts</code>. The result is stored as a Matrix Expression with the sum of a sparse and a low-rank term. I.e. no large dense matrix is created.</p><p>Optionally, <code>T</code> can be specified to control the <code>eltype</code> of the sparse transformed matrix. <code>T=Float32</code> can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.</p><p>See <code>SCTransformModel</code> for description of <code>kwargs...</code>.</p><p><strong>Examples</strong></p><p>Compute SCTransform (Gene Expression features):</p><pre><code class="nohighlight hljs">julia&gt; sctransform(counts)</code></pre><p>Compute SCTransform (Antibody Capture features):</p><pre><code class="nohighlight hljs">julia&gt; sctransform(counts; var_filter = :feature_type =&gt; isequal(&quot;Antibody Capture&quot;))</code></pre><p>Compute SCTransform (Gene Expression features), using eltype Float32 to lower memory usage:</p><pre><code class="nohighlight hljs">julia&gt; sctransform(Float32, counts)</code></pre><p>See also: <a href="#SingleCellProjections.SCTransformModel-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SCTransformModel</code></a>, <a href="https://github.com/rasmushenningsson/SCTransform.jl"><code>SCTransform.scparams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/transform.jl#L379-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.adjacency_distances" href="#SingleCellProjections.adjacency_distances"><code>SingleCellProjections.adjacency_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjacency_distances(adj, X, Y=X)</code></pre><p>For each structural non-zero in <code>adj</code>, compute the Euclidean distance between the point in the DataMatrix <code>Y</code> and the point in the DataMatrix <code>X</code>.</p><p>Can be useful when <code>adj</code> is created using e.g. a lower dimensional representation and we want to know the distances in the original, high dimensional space.</p><p>At the moment all points in <code>Y</code> are required to have the same number of neighbors in <code>X</code>, for computation reasons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/adjacency_matrices.jl#L59-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.covariate" href="#SingleCellProjections.covariate"><code>SingleCellProjections.covariate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">covariate(name::String, group_a, [group_b])</code></pre><p>Create a two-group <code>covariate</code> referring to column <code>name</code>, comparing <code>group_a</code> to <code>group_b</code>. <code>group_a</code> and <code>group_b</code> must be values occuring in the column <code>name</code>.</p><p>If <code>group_b</code> is not given, <code>group_a</code> will be compared to all other observations.</p><p>See also: <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/design.jl#L95-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.covariate" href="#SingleCellProjections.covariate"><code>SingleCellProjections.covariate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">covariate(name::String, type=:auto)</code></pre><p>Create a <code>covariate</code> referring to column <code>name</code>. <code>type</code> must be one of <code>:auto</code>, <code>:numerical</code>, <code>:categorical</code>, <code>:twogroup</code> and <code>:intercept</code>. <code>:auto</code> means auto-detection by checking if the values in the column are numerical or categorical. <code>type==:intercept</code> adds an intercept to the model (in which case the <code>name</code> parameter is ignored).</p><p>See also: <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/design.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.designmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">designmatrix(data::DataMatrix, [covariates...]; center=true, max_categories=100)</code></pre><p>Creates a design matrix from <code>data.obs</code> and the given <code>covariates</code>. Covariates can be specied using strings (column name in data.obs), with autodetection of whether the covariate is numerical or categorical, or using the <code>covariate</code> function for more control.</p><ul><li><code>center</code> - If <code>true</code>, an intercept is added to the design matrix. (Should only be set to <code>false</code> in very rare circumstances.)</li><li><code>max_categories</code> - Safety parameter, an error will be thrown if there are too many categories. In this case, it is likely a mistake that the covariate was used as a categorical covariate. Using a very large number of categories is also bad for performance and memory consumption.</li></ul><p><strong>Examples</strong></p><p>Centering only:</p><pre><code class="language-julia hljs">julia&gt; designmatrix(data)</code></pre><p>Regression model with intercept (centering) and &quot;fraction_mt&quot; (numerical annotation):</p><pre><code class="language-julia hljs">julia&gt; designmatrix(data, &quot;fraction_mt&quot;)</code></pre><p>As above, but also including &quot;batch&quot; (categorical annotation):</p><pre><code class="language-julia hljs">julia&gt; designmatrix(data, &quot;fraction_mt&quot;, &quot;batch&quot;)</code></pre><p>See also: <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a>, <a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>NormalizationModel</code></a>, <a href="#SingleCellProjections.covariate"><code>covariate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/design.jl#L210-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}" href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>SingleCellProjections.filter_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_matrix(fvar, fobs, data::DataMatrix)</code></pre><p>Return a new DataMatrix, containing only the variables and observations passing the filters.</p><p><code>fvar</code>/<code>fobs</code> can be:</p><ul><li>An <code>AbstractVector</code> of indices to keep.</li><li>A <code>AbstractVector</code> of booleans (true to keep, false to discard).</li><li><code>:</code> indicating that all variables/observations should be kept.</li><li>Anything you can pass on to <code>DataFrames.filter</code> (see <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter">DataFrames documentation</a> for details).</li></ul><p>Also note that indexing of a DataMatrix supports <code>AbstractVector</code>s of indices/booleans and <code>:</code>, and is otherwise identical to <code>filter_matrix</code>.</p><p><strong>Examples</strong></p><p>Keep every 10th variable and 3rd observation:</p><pre><code class="language-julia hljs">julia&gt; filter_matrix(1:10:size(data,1), 1:3:size(data,2), data)</code></pre><p>Or, using indexing syntax:</p><pre><code class="language-julia hljs">julia&gt; data[1:10:end, 1:3:end]</code></pre><p>For more examples, see <code>filter_var</code> and <code>filter_obs</code>.</p><p>See also: <a href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>filter_var</code></a>, <a href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>filter_obs</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/filter.jl#L93-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}" href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_obs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_obs(f, data::DataMatrix)</code></pre><p>Return a new DataMatrix, containing only the observations passing the filter.</p><p><code>f</code> can be:</p><ul><li>An <code>AbstractVector</code> of indices to keep.</li><li>A <code>AbstractVector</code> of booleans (true to keep, false to discard).</li><li><code>:</code> indicating that all observations should be kept.</li><li>Anything you can pass on to <code>DataFrames.filter</code> (see DataFrames documentation for details).</li></ul><p><strong>Examples</strong></p><p>Keep every 10th observation:</p><pre><code class="language-julia hljs">julia&gt; filter_obs(1:10:size(data,2), data)</code></pre><p>Remove observations where &quot;celltype&quot; equals &quot;other&quot;:</p><pre><code class="language-julia hljs">julia&gt; filter_obs(&quot;celltype&quot;=&gt;!isequal(&quot;other&quot;), data)</code></pre><p>See also: <a href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>filter_matrix</code></a>, <a href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>filter_var</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/filter.jl#L153-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.filter_var-Tuple{Any, DataMatrix}" href="#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}"><code>SingleCellProjections.filter_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_var(f, data::DataMatrix)</code></pre><p>Return a new DataMatrix, containing only the variables passing the filter.</p><p><code>f</code> can be:</p><ul><li>An <code>AbstractVector</code> of indices to keep.</li><li>A <code>AbstractVector</code> of booleans (true to keep, false to discard).</li><li><code>:</code> indicating that all variables should be kept.</li><li>Anything you can pass on to <code>DataFrames.filter</code> (see <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter">DataFrames documentation</a> for details).</li></ul><p><strong>Examples</strong></p><p>Keep every 10th variable:</p><pre><code class="language-julia hljs">julia&gt; filter_var(1:10:size(data,1), data)</code></pre><p>Keep only variables of the type &quot;Gene Expression&quot;:</p><pre><code class="language-julia hljs">julia&gt; filter_var(&quot;feature_type&quot;=&gt;isequal(&quot;Gene Expression&quot;), data)</code></pre><p>See also: <a href="#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}"><code>filter_matrix</code></a>, <a href="#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}"><code>filter_obs</code></a>, <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/filter.jl#L125-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.force_layout-Tuple{DataMatrix}" href="#SingleCellProjections.force_layout-Tuple{DataMatrix}"><code>SingleCellProjections.force_layout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">force_layout(data::DataMatrix;
             ndim=3,
             k,
             adj,
             kprojection=10,
             obs=:copy,
             adj_out,
             niter = 100,
             link_distance = 4,
             link_strength = 2,
             charge = 5,
             charge_min_distance = 1,
             theta = 0.9,
             center_strength = 0.05,
             velocity_decay = 0.9,
             initialAlpha = 1.0,
             finalAlpha = 1e-3,
             initialScale = 10,
             rng)</code></pre><p>Compute the Force Layout (also known as a force directed knn-graph or SPRING plots) for <code>data</code>. Usually, <code>data</code> is a DataMatrix after reduction to <code>10-100</code> dimensions by <code>svd</code>.</p><p>A Force Layout is computed by running a physics simulation were the observations are connected by springs (such that connected observations are attracted), a general &quot;charge&quot; force repelling all observations from each other and a centering force that keep the observations around the origin. The implementation is based on d3-force: https://github.com/d3/d3-force, also see LICENSE.md.</p><p>Exactly one of the kwargs <code>k</code> and <code>adj</code> must be provided. See details below.</p><p>General parameters:</p><ul><li><code>k</code> - Number of nearest neighbors to connect each observation to (computes <code>adj</code> below).</li><li><code>adj</code> - An sparse, symmetric, adjacency matrix with booleans. <code>true</code> if two observations are connected by a spring and <code>false</code> otherwise.</li><li><code>kprojection</code> - The number of nearest neighbors used when projecting onto the resulting force layout. (Not used in the computation of the layout, only during projection.)</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li><li><code>adj_out</code> - Optional <code>Ref</code>. If specified, the (computed) <code>adj</code> matrix will be assigned to <code>adj_out</code>.</li></ul><p>Paramters controlling the physics simulation:</p><ul><li><code>niter</code> - Number of iterations to run the simulation.</li><li><code>link_distance</code> - The length of each spring.</li><li><code>link_strength</code> - The strength of the spring force.</li><li><code>charge</code> - The strength of the charge force.</li><li><code>charge_min_distance</code> - Used to avoid numerical instabilities by limiting the charge force for observations that are very close.</li><li><code>theta</code> - Parameter controlling accuracy in the Barnes-Hut approximation for charge forces.</li><li><code>center_strength</code> - Strength of the centering force.</li><li><code>velocity_decay</code> - At each iteration, the current velocity for an observations is multiplied by <code>velocity_decay</code>.</li><li><code>initialAlpha</code> - The alpha value decreases over time and allows larger changes to happen early, while being more stable towards the end.</li><li><code>finalAlpha</code> - See <code>initialAlpha</code></li><li><code>initialScale</code> - The simulation is initialized by randomly drawing each observation from a multivariate Gaussian, and is scaled by <code>initialScale</code>.</li><li><code>rng</code> - Optional RNG object. Useful for reproducibility.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; force_layout(data; ndim=3, k=100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/reduce.jl#L92-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.ftest!-Tuple{DataMatrix, Any}" href="#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}"><code>SingleCellProjections.ftest!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ftest!(data::DataMatrix, h1; h0, kwargs...)</code></pre><p>Performs an F-Test with the given <code>h1</code> (alternative hypothesis) and <code>h0</code> (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used.</p><p><code>ftest!</code> adds a F-statistic and a p-value column to <code>data.var</code>.</p><p>See <a href="#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}"><code>ftest_table</code></a> for usage examples and more details on computations and parameters.</p><p>In addition <code>ftest!</code> supports the <code>kwarg</code>:</p><ul><li><code>prefix</code> - Output column names for F-statistics and p-values will be prefixed with this string. If none is given, it will be constructed from <code>h1</code> and <code>h0</code>.</li></ul><p>See also: <a href="#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}"><code>ftest_table</code></a>, <a href="#SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}"><code>ftest</code></a>, <a href="#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}"><code>ttest!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L350-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ftest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ftest(data::DataMatrix, h1; h0, var=:copy, obs=:copy, matrix=:keep, kwargs...)</code></pre><p>Performs an F-Test with the given <code>h1</code> (alternative hypothesis) and <code>h0</code> (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used.</p><p><code>ftest</code> creates a copy of <code>data</code> and adds a F-statistic and a p-value column to <code>data.var</code>.</p><p>See <a href="#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}"><code>ftest_table</code></a> and <a href="#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}"><code>ftest!</code></a> for usage examples and more details on computations and parameters.</p><p>See also: <a href="#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}"><code>ftest!</code></a>, <a href="#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}"><code>ftest_table</code></a>, <a href="#SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}"><code>ttest</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L377-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}" href="#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}"><code>SingleCellProjections.ftest_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ftest_table(data::DataMatrix, h1; h0, kwargs...)</code></pre><p>Performs an F-Test with the given <code>h1</code> (alternative hypothesis) and <code>h0</code> (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used. (See &quot;Examples&quot; below for concrete examples.)</p><p>F-tests can be performed on any <code>DataMatrix</code>, but it is almost always recommended to do it directly after transforming the data using e.g. <code>sctransform</code>, <code>logtransform</code> or <code>tf_idf_transform</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization</header><div class="admonition-body"><p>Do not use <code>ftest_table</code> after normalizing the data using <code>normalize_matrix</code>: <code>ftest_table</code> needs to know about the <code>h0</code> model (regressed out covariates) for correction computations. Failing to do so can result in incorrect results. If you want to correct for the same covariates, pass them as <code>h0</code> to <code>ftest_table</code>.</p></div></div><p><code>h1</code> can be:</p><ul><li>A string specifying a column name of <code>data.obs</code>. Auto-detection determines if the column is categorical (ANOVA) or numerical.</li><li>A <a href="#SingleCellProjections.covariate"><code>covariate</code></a> for more control of how to interpret the values in a column.</li><li>A tuple or vector of the above for compound models.</li></ul><p><code>ftest_table</code> returns a Dataframe with columns for variable IDs, F-statistics and p-values.</p><p>Supported <code>kwargs</code> are:</p><ul><li><code>h0</code>                  - Use a non-trivial <code>h0</code> (null) model. Specified in the same way as <code>h1</code> above.</li><li><code>center=true</code>         - Add an intercept to the <code>h0</code> (null) model.</li><li><code>statistic_col=&quot;F&quot;</code>   - Name of the output column containing the F-statistics. (Set to nothing to remove from output.)</li><li><code>pvalue_col=&quot;pValue&quot;</code> - Name of the output column containing the p-values. (Set to nothing to remove from output.)</li><li><code>h1_missing=:skip</code>    - One of <code>:skip</code> and <code>:error</code>. If <code>skip</code>, missing values in <code>h1</code> columns are skipped, otherwise an error is thrown.</li><li><code>h0_missing=:error</code>   - One of <code>:skip</code> and <code>:error</code>. If <code>skip</code>, missing values in <code>h0</code> columns are skipped, otherwise an error is thrown.</li><li><code>allow_normalized_matrix=false</code> - Set to true to accept running on a <code>DataMatrix</code> that has been normalized.</li></ul><p><strong>Examples</strong></p><p>Perform an ANOVA using the &quot;celltype&quot; annotation.</p><pre><code class="language-julia hljs">julia&gt; ftest_table(transformed, &quot;celltype&quot;)</code></pre><p>Perform an ANOVA using the &quot;celltype&quot; annotation, while correcting for <code>fraction_mt</code> (a linear covariate).</p><pre><code class="language-julia hljs">julia&gt; ftest_table(transformed, &quot;celltype&quot;; h0=&quot;fraction_mt&quot;)</code></pre><p>Perform an ANOVA using the &quot;celltype&quot; annotation, while correcting for <code>fraction_mt</code> (a linear covariate) and &quot;phase&quot; (a categorical covariate).</p><pre><code class="language-julia hljs">julia&gt; ftest_table(transformed, &quot;celltype&quot;; h0=(&quot;fraction_mt&quot;,&quot;phase&quot;))</code></pre><p>Perform Quadractic Regression using the covariate <code>x</code>, by first creating an annotation for <code>x</code> squared, and then using a compound model.</p><pre><code class="language-julia hljs">julia&gt; data.obs.x2 = data.obs.x.^2;

julia&gt; ftest_table(transformed, (&quot;x&quot;,&quot;x2&quot;))</code></pre><p>See also: <a href="#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}"><code>ftest!</code></a>, <a href="#SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}"><code>ftest</code></a>, <a href="#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}"><code>ttest_table</code></a>, <a href="#SingleCellProjections.covariate"><code>covariate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L275-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.implicitsvd-Tuple{Any}" href="#SingleCellProjections.implicitsvd-Tuple{Any}"><code>SingleCellProjections.implicitsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">implicitsvd(A; nsv=3, subspacedims=4nsv, niter=2, stabilize_sign=true, rng)</code></pre><p>Compute the SVD of <code>A</code> using Random Subspace SVD. [Halko et al. &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions&quot;]</p><ul><li><code>nsv</code> - Number of singular values/vectors to compute</li><li><code>subspacedims</code> - Number of dimensions used for the subspace approximating the action of <code>A</code>.</li><li><code>niter</code> - Number of iterations. In each iteration, one multiplication of <code>A</code> with a matrix and one multiplication of <code>A&#39;</code> with a matrix will be performed.</li><li><code>stabilize_sign</code> - If true, handles the problem that the SVD is only unique up to the sign of each component (for real matrices), by ensuring that the l1 norm of the positive entires for each column in U is larger than the l1 norm of the negative entries.</li><li><code>rng</code> - Specify a custom RNG.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/implicitsvd.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.load10x-Tuple{Any}" href="#SingleCellProjections.load10x-Tuple{Any}"><code>SingleCellProjections.load10x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load10x(filename; lazy=false, copy_obs_col=&quot;barcode&quot;=&gt;&quot;id&quot;, kwargs...)</code></pre><p>Load a CellRanger &quot;.h5&quot; or &quot;.mtx[.gz]&quot; file as a DataMatrix.</p><ul><li><code>lazy</code> - If <code>true</code>, the count matrix itself will not be loaded, only features and barcodes. This is used internally in <code>load_counts</code> to merge samples more efficiently. Use <code>load_counts</code> to later load the count data.</li><li><code>copy_obs_col</code> - Set to nothing to disable. Defaults to a pair <code>&quot;barcode&quot;=&gt;&quot;id&quot;</code>, which copies the <code>obs</code> annotation <code>barcode</code> to a new column <code>id</code>.</li><li>Additional <code>kwargs...</code> are passed to the DataMatrix constructor.</li></ul><p><strong>Examples</strong></p><p>Load counts from a CellRanger &quot;.h5&quot; file. (Recommended.)</p><pre><code class="language-julia hljs">julia&gt; counts = load10x(&quot;filtered_feature_bc_matrix.h5&quot;)</code></pre><p>Load counts from a CellRanger &quot;.mtx&quot; file. Tries to find barcode and feature annotation files in the same folder.</p><pre><code class="language-julia hljs">julia&gt; counts = load10x(&quot;matrix.mtx.gz&quot;)</code></pre><p>Lazy loading followed by loading.</p><pre><code class="language-julia hljs">julia&gt; counts = load10x(&quot;filtered_feature_bc_matrix.h5&quot;);
julia&gt; counts = load_counts(counts)</code></pre><p>See also: <a href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>load_counts</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/load.jl#L88-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.load_counts-Tuple{Any, Any}" href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>SingleCellProjections.load_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_counts([loadfun=load10x], filenames;
            sample_names,
            sample_name_col,
            merged_obs_id_col = &quot;id&quot;,
            lazy,
            lazy_merge = false,
            var_id_cols=nothing,
            merged_obs_id_delim = &#39;_&#39;,
            callback=nothing)</code></pre><p>Load and merge multiple samples efficiently.</p><p>Defaults to loading 10x CellRanger files. The files are first loaded lazily, then the merged count matrix is allocated and finally each sample is loaded directly into the merged count matrix. (This strategy greatly reduces memory usage, since only one copy of data is needed instead of two.)</p><p>The vector <code>filenames</code> specifies which files to load. For each file, <code>loadfun</code> is called.</p><ul><li><code>sample_names</code> - Specify the sample names. Should be a vector of the same length as <code>filenames</code>. Set to <code>nothing</code> to not create a sample name annotation.</li><li><code>sample_name_col</code> - Column for sample names in <code>obs</code>, defaults to &quot;sampleName&quot;.</li><li><code>merged_obs_id_col</code> - Colum for merged <code>id</code>s in <code>obs</code>.</li><li><code>lazy</code> - Enable lazy loading. Defaults to true if <code>load10x</code> is used, and <code>false</code> otherwise.</li><li><code>lazy_merge</code> - Enable lazy merging, i.e. <code>var</code> and <code>obs</code> are created, but the count matrix merging is postponed until a second call to <code>load_counts</code>.</li><li><code>var_id_cols</code> - Specify variable id columns. Defaults to <code>nothing</code>, i.e. autodetecting from the samples.</li><li><code>merged_obs_id_delim</code> - Delimiter used when creating merged <code>obs</code> IDs.</li><li><code>callback</code> - Experimental callback functionality. The callback function is called between samples during merging. Return <code>true</code> to abort loading and <code>false</code> to continue.</li></ul><p><strong>Examples</strong></p><p>Load and name samples:</p><pre><code class="language-julia hljs">julia&gt; counts = load_counts([&quot;s1.h5&quot;, &quot;s2.h5&quot;]; sample_names=[&quot;Sample A&quot;, &quot;Sample B&quot;])</code></pre><p>See also: <a href="#SingleCellProjections.load10x-Tuple{Any}"><code>load10x</code></a>, <a href="#SingleCellProjections.merge_counts-Tuple{Any, Any}"><code>merge_counts</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/load.jl#L136-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.load_counts-Tuple{DataMatrix{&lt;:SingleCellProjections.Lazy10xMatrix}}" href="#SingleCellProjections.load_counts-Tuple{DataMatrix{&lt;:SingleCellProjections.Lazy10xMatrix}}"><code>SingleCellProjections.load_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_counts(data::DataMatrix{&lt;:Lazy10xMatrix})</code></pre><p>Load counts for a lazily loaded 10x DataMatrix.</p><p>See also: <a href="#SingleCellProjections.load10x-Tuple{Any}"><code>load10x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/load.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.load_counts-Union{Tuple{DataMatrix{&lt;:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#SingleCellProjections.load_counts-Union{Tuple{DataMatrix{&lt;:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>SingleCellProjections.load_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_counts(data::DataMatrix{&lt;:LazyMergedMatrix})</code></pre><p>Merge/load counts for a lazily merged DataMatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/load.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.loadh5ad-Tuple{Any}" href="#SingleCellProjections.loadh5ad-Tuple{Any}"><code>SingleCellProjections.loadh5ad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadh5ad(filename; var_id_column=:id, obs_id_column=:id)</code></pre><p>Experimental loading of .h5ad files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/h5ad.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.local_outlier_factor!-Tuple{DataMatrix, DataMatrix}" href="#SingleCellProjections.local_outlier_factor!-Tuple{DataMatrix, DataMatrix}"><code>SingleCellProjections.local_outlier_factor!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">local_outlier_factor!(data::DataMatrix, full::DataMatrix; k=10, col=&quot;LOF&quot;)</code></pre><p>Compute the Local Outlier Factor (LOF) for each observation in <code>data</code>, and add as column to <code>data.obs</code> with the name <code>col</code>.</p><p>When working with projected <code>DataMatrices</code>, use <a href="#SingleCellProjections.local_outlier_factor_projection!-NTuple{4, DataMatrix}"><code>local_outlier_factor_projection!</code></a> instead.</p><p>NB: This function might be very slow for high values of <code>k</code>.</p><p>First, the <code>k</code> nearest neighbors are found for each observation in <code>data</code>. Then, the Local Outlier Factor is computed by considering the distance between the neighbors, but this time in the <code>full</code> DataMatrix. Thus <code>full</code> must have the same observations as are present in <code>data</code>.</p><p>A LOF value smaller than or close to one is means that the observation is an inlier, but a LOF value much larger than one means that the observation is an inlier.</p><p>By specifiying <code>full=data</code>, this is coincides with the standard definition for Local Outlier Factor. However, it is perhaps more useful to find neighbors in a dimension reduced space (after e.g. <code>svd</code> (PCA) or <code>umap</code>), but then compute distances in the high dimensional space (typically after normalization). This way, an observation is concidered an outlier if the reduction to a lower dimensional space didn&#39;t properly represent the neighborhood of the observation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The interface is not yet fully decided and subject to change.</p></div></div><p><strong>Examples</strong></p><p>Compute the Local Outlier Factor, with nearest neighbors based only on <code>reduced</code>, but later using distances in <code>full</code> for the actual LOF computation.</p><pre><code class="language-julia hljs">julia&gt; reduced = svd(normalized; nsv=10)

julia&gt; local_outlier_factor!(reduced, normalized; k=10)</code></pre><p>See also: <a href="#SingleCellProjections.local_outlier_factor_projection!-NTuple{4, DataMatrix}"><code>local_outlier_factor_projection!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/local_outlier_factor.jl#L48-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.local_outlier_factor_projection!-NTuple{4, DataMatrix}" href="#SingleCellProjections.local_outlier_factor_projection!-NTuple{4, DataMatrix}"><code>SingleCellProjections.local_outlier_factor_projection!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">local_outlier_factor_projection!(data::DataMatrix, full::DataMatrix, base::DataMatrix, base_full::DataMatrix; k=10, col=&quot;LOF_projection&quot;)</code></pre><p>Compute the Local Outlier Factor (LOF) for each observation in <code>data</code>, and add as column to <code>data.obs</code> with the name <code>col</code>.</p><p>Use <code>local_outlier_factor_projection!</code> if you are working with projected data, and <a href="#SingleCellProjections.local_outlier_factor!-Tuple{DataMatrix, DataMatrix}"><code>local_outlier_factor!</code></a> otherwise.</p><p>Parameters:</p><ul><li><code>data</code> - A <code>DataMatrix</code> for which we compute LOF for each observation. Expected to be a <code>DataMatrix</code> projected onto <code>base</code>, so that the <code>data</code> and <code>base</code> use the same coordinate system.</li><li><code>full</code> - A <code>DataMatrix</code> with the same observations as <code>data</code>, used to compute distances in the LOF computation. Expected to be a <code>DataMatrix</code> projected onto <code>base_full</code>, so that the <code>full</code> and <code>base_full</code> use the same coordinate system.</li><li><code>base</code> - The base <code>DataMatrix</code>.</li><li><code>base_full</code> - The base <code>DataMatrix</code>.</li><li><code>k</code> - The number of nearest neighbors to use. NB: This function might be very slow for high values of <code>k</code>.</li></ul><p>First, for each observation in <code>data</code>, the <code>k</code> nearest neighbors in <code>base</code> are found. Then, the distance to each neighbor is computed using <code>full</code> and <code>base_full</code>. Thus <code>full</code> must have the same observations as are present in <code>data</code>, and <code>base_full</code> must have the same observations as <code>base</code>.</p><p>A LOF value smaller than or close to one is means that the observation is an inlier, but a LOF value much larger than one means that the observation is an inlier.</p><p>By specifiying <code>full=data</code> and <code>base_full=base</code>, this is coincides with the standard definition for Local Outlier Factor. However, it is perhaps more useful to find neighbors in a dimension reduced space (after e.g. <code>svd</code> (PCA) or <code>umap</code>), but then compute distances in the high dimensional space (typically after normalization). This way, an observation is concidered an outlier if the reduction to a lower dimensional space didn&#39;t properly represent the neighborhood of the observation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The interface is not yet fully decided and subject to change.</p></div></div><p><strong>Examples</strong></p><p>Compute the Local Outlier Factor (LOF) for each observation in a data set <code>reduced</code>, which has been projected onto <code>base_reduced</code>.</p><p>The nearest neighbors are computed between observations in <code>reduced</code> and <code>base_reduced</code>, but the distances in the actual LOF computation are between the same observations in <code>normalized</code> and <code>base_normalized</code>.</p><pre><code class="language-julia hljs">julia&gt; base_reduced = svd(base_normalized; nsv=10)

julia&gt; normalized = project(counts, base_normalized);

julia&gt; reduced = project(normalized, base_reduced);

julia&gt; local_outlier_factor!(reduced, normalized, base_reduced, base_normalized; k=10)</code></pre><p>See also: <a href="#SingleCellProjections.local_outlier_factor!-Tuple{DataMatrix, DataMatrix}"><code>local_outlier_factor!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/local_outlier_factor.jl#L100-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T" href="#SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SingleCellProjections.logtransform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logtransform([T=Float64], counts::DataMatrix;
             var_filter = hasproperty(counts.var, :feature_type) ? :feature_type =&gt; isequal(&quot;Gene Expression&quot;) : nothing,
             scale_factor=10_000,
             var=:copy,
             obs=:copy)</code></pre><p>Log₂-transform <code>counts</code> using the formula:</p><pre><code class="nohighlight hljs">  log₂(1 + cᵢⱼ*scale_factor/(∑ᵢcᵢⱼ))</code></pre><p>Optionally, <code>T</code> can be specified to control the <code>eltype</code> of the sparse transformed matrix. <code>T=Float32</code> can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.</p><ul><li><code>var_filter</code> - Control which variables (features) to use for parameter estimation. Defaults to <code>:feature_type =&gt; isequal(&quot;Gene Expression&quot;)</code>, if a <code>feature_type</code> column is present in <code>counts.var</code>. Can be set to <code>nothing</code> to disable filtering. See <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a> for how to specify filters.</li><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; transformed = logtransform(counts)</code></pre><p>Use eltype Float32 to lower memory usage:</p><pre><code class="language-julia hljs">julia&gt; transformed = logtransform(Float32, counts)</code></pre><p>See also: <a href="#SCTransform.sctransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>sctransform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/transform.jl#L74-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.mannwhitney!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mannwhitney!(data::DataMatrix, column, [group_a, group_b]; kwargs...)</code></pre><p>Perform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.</p><p>Note that <code>data</code> must be a <code>DataMatrix</code> containing a sparse matrix only. It is recommended to first <a href="#SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>logtransform</code></a> (or <a href="#SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>tf_idf_transform</code></a>) the raw counts before performing the Mann-Whitney U-test.</p><p><code>mannwhitney!</code> adds a U statistic and a p-value column to <code>data.var</code>. See <a href="#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney_table</code></a> for more details on groups and kwargs.</p><p>In addition <code>mannwhitney!</code> supports the <code>kwarg</code>:</p><ul><li><code>prefix</code> - Output column names for U statistics and p-values will be prefixed with this string. If none is given, it will be constructed from <code>column</code>, <code>group_a</code> and <code>group_b</code>.</li></ul><p>See also: <a href="#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney_table</code></a>, <a href="#SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L120-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.mannwhitney</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mannwhitney(data::DataMatrix, column, [group_a, group_b]; var=:copy, obs=:copy, matrix=:keep, kwargs...)</code></pre><p>Perform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.</p><p>Note that <code>data</code> must be a <code>DataMatrix</code> containing a sparse matrix only. It is recommended to first <a href="#SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>logtransform</code></a> (or <a href="#SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>tf_idf_transform</code></a>) the raw counts before performing the Mann-Whitney U-test.</p><p><code>mannwhitney</code> creates a copy of <code>data</code> and adds a U statistic and a p-value column to <code>data.var</code>. See <a href="#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney!</code></a> and <a href="#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney_table</code></a> for more details on groups and <code>kwargs</code>.</p><p>See also: <a href="#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney!</code></a>, <a href="#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney_table</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L148-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.mannwhitney_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mannwhitney_table(data::DataMatrix, column, [group_a, group_b]; kwargs...)</code></pre><p>Perform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.</p><p>Note that <code>data</code> must be a <code>DataMatrix</code> containing a sparse matrix only. It is recommended to first <a href="#SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>logtransform</code></a> (or <a href="#SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>tf_idf_transform</code></a>) the raw counts before performing the Mann-Whitney U-test.</p><p><code>column</code> specifies a column in <code>data.obs</code> and is used to determine which observations belong in which group.</p><p>If <code>group_a</code> and <code>group_b</code> are not given, the <code>column</code> must contain exactly two unique values (except <code>missing</code>). If <code>group_a</code> is given, but not <code>group_b</code>, the observations in group A are compared to all other observations (except <code>missing</code>). If both <code>group_a</code> and <code>group_b</code> are given, the observations in group A are compared the observations in group B.</p><p><code>mannwhitney_table</code> returns a Dataframe with columns for variable IDs, U statistics and p-values.</p><p>Supported <code>kwargs</code> are:</p><ul><li><code>statistic_col=&quot;U&quot;</code>   - Name of the output column containing the U statistics. (Set to nothing to remove from output.)</li><li><code>pvalue_col=&quot;pValue&quot;</code> - Name of the output column containing the p-values. (Set to nothing to remove from output.)</li><li><code>h1_missing=:skip</code>    - One of <code>:skip</code> and <code>:error</code>. If <code>skip</code>, missing values in <code>column</code> are skipped, otherwise an error is thrown.</li></ul><p>The following <code>kwargs</code> determine how the computations are threaded:</p><ul><li><code>nworkers</code>      - Number of worker threads used in the computation. Set to 1 to disable threading.</li><li><code>chunk_size</code>    - Number of variables processed in each chunk.</li><li><code>channel_size</code>  - Max number of unprocessed chunks in queue.</li></ul><p>See also: <a href="#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney!</code></a>, <a href="#SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L84-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.merge_counts-Tuple{Any, Any}" href="#SingleCellProjections.merge_counts-Tuple{Any, Any}"><code>SingleCellProjections.merge_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_counts(samples, sample_names;
             lazy=false,
             var_id_cols=nothing,
             sample_name_col = sample_names===nothing ? nothing : &quot;sampleName&quot;,
             merged_obs_id_col = &quot;id&quot;,
             merged_obs_id_delim = &#39;_&#39;,
             callback=nothing)</code></pre><p>Merge <code>samples</code> to create one large DataMatrix, by concatenating the <code>obs</code>. The union of the variables from the samples is used, and if a variable is not present in a sample, the count will be set to zero.</p><p>The <code>obs</code> IDs are created by concatenating the current <code>obs</code> ID columns, together with the <code>sample_names</code> (if provided).</p><ul><li><code>lazy</code> - Lazy merging. Use <code>load_counts</code> to actually perform the merging.</li><li><code>var_id_cols</code> - Set to <code>nothing</code> to autodetect from the samples.</li><li><code>sample_name_col</code> - Column in which the <code>sample_names</code> are stored.</li><li><code>merged_obs_id_col</code> - <code>obs</code> ID column after merging. Set to <code>nothing</code> to keep current ID cols (will add <code>sampleName</code> as a separate ID column, if provided.)</li><li><code>merged_obs_id_delim</code> - Delimiter used when merging <code>obs</code> IDs.</li><li><code>callback</code> - Experimental callback functionality. The callback function is called between samples during merging. Return <code>true</code> to abort loading and <code>false</code> to continue.</li></ul><p>See also: <a href="#SingleCellProjections.load_counts-Tuple{Any, Any}"><code>load_counts</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/load.jl#L299-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}" href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>SingleCellProjections.normalize_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_matrix(data::DataMatrix, design::DesignMatrix; scale=false, kwargs...)</code></pre><p>Normalize <code>data</code> using the specified <code>design</code> matrix.</p><p>See also: <a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>NormalizationModel</code></a>, <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/normalize.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.normalize_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_matrix(data::DataMatrix, [covariates...]; center=true, scale=false, kwargs...)</code></pre><p>Normalize <code>data</code>. By default, the matrix is centered. Any <code>covariates</code> specified (using column names of <code>data.obs</code>) will be regressed out.</p><ul><li><code>center</code> - Set to true to center the data matrix.</li><li><code>scale</code> - Set to true to scale the variables in the data matrix to unit standard deviation.</li></ul><p>For other <code>kwargs</code> and more detailed descriptions, see <code>NormalizationModel</code> and <code>designmatrix</code>.</p><p><strong>Examples</strong></p><p>Centering only:</p><pre><code class="language-julia hljs">julia&gt; normalize_matrix(data)</code></pre><p>Regression model with intercept (centering) and &quot;fraction_mt&quot; (numerical annotation):</p><pre><code class="language-julia hljs">julia&gt; normalize_matrix(data, &quot;fraction_mt&quot;)</code></pre><p>As above, but also including &quot;batch&quot; (categorical annotation):</p><pre><code class="language-julia hljs">julia&gt; normalize_matrix(data, &quot;fraction_mt&quot;, &quot;batch&quot;)</code></pre><p>See also: <a href="#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>NormalizationModel</code></a>, <a href="#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}"><code>designmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/normalize.jl#L206-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.obs_coordinates" href="#SingleCellProjections.obs_coordinates"><code>SingleCellProjections.obs_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">obs_coordinates(data::DataMatrix)</code></pre><p>Returns a matrix with coordinates for the observations. Not available for all types of DataMatrices. Mostly useful for data matrices after dimension reduction such as <code>svd</code> or <code>force_layout</code> has been applied.</p><p>In the case of <code>SVD</code> (PCA), <code>obs_coordinates</code> returns the principal components, scaled by the singular values. This is a a good starting point for downstream analysis, since it is the optimal linear approximation of the original data for the given number of dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L149-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{&lt;:ProjectionModel}, Vararg{Any}}" href="#SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{&lt;:ProjectionModel}, Vararg{Any}}"><code>SingleCellProjections.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(data::DataMatrix, models, args...; verbose=true, kwargs...)</code></pre><p>Convenience function for projection onto multiple <code>models</code>. Essentially calls <code>foldl</code> and prints some <code>@info</code> messages (if <code>verbose=true</code>). In most cases, it is better to call <code>project(data, base::DataMatrix)</code> instead of using this method directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}" href="#SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}"><code>SingleCellProjections.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(data::DataMatrix, base::DataMatrix, args...; from=nothing, kwargs...)</code></pre><p>Project <code>data</code> onto <code>base</code>, by applying ProjectionModels from <code>base</code> one by one.</p><p>Since <code>data</code> already might have some models applied, <code>project</code> will try to figure out which models from <code>base</code> to use. See &quot;Examples&quot; below for concrete examples. Here&#39;s a more technical overview:</p><p>Consider a <code>base</code> data matrix with four models:</p><pre><code class="nohighlight hljs">base: A -&gt; B -&gt; C -&gt; D</code></pre><p>Given some new <code>data</code> (typically counts), we can project that onto <code>base</code>, given the result <code>proj</code> by applying all four models:</p><pre><code class="nohighlight hljs">data:
proj: A -&gt; B -&gt; C -&gt; D</code></pre><p>If <code>data</code> already has some models applied (e.g. we already projected onto A and B above), <code>project</code> will look for the last model in <code>data</code> (in this case B) in the list of models in <code>base</code>, and only apply models after that (in this case C and D).</p><pre><code class="nohighlight hljs">data: A -&gt; B
proj: A -&gt; B -&gt; C -&gt; D</code></pre><p>It is also possible to use the <code>from</code> kwarg to specify exactly which models to apply. (The models in <code>from</code> must be a prefix of the models in <code>base</code>, or in other words, <code>base</code> was created by applying additional operations to <code>from</code>.)</p><pre><code class="nohighlight hljs">data: X
base: A -&gt; B -&gt; C -&gt; D
from: A -&gt; B
proj: X -&gt; C -&gt; D</code></pre><p>Note that it is necessary to use the <code>from</code> kwarg if the last model in <code>data</code> does not occurr in <code>base</code>, because <code>project</code> cannot figure out on its own which models it makes sense to apply.</p><p><strong>Examples</strong></p><p>First, we construct a &quot;base&quot; by loading counts, SCTransforming, normalizing, computing the svd and finally computing a force layout:</p><pre><code class="language-julia hljs">julia&gt; fp = [&quot;GSE164378_RNA_ADT_3P_P1.h5&quot;, &quot;GSE164378_RNA_ADT_3P_P2.h5&quot;];
julia&gt; counts = load_counts(fp; sample_names=[&quot;P1&quot;,&quot;P2&quot;]);
julia&gt; transformed = sctransform(counts);
julia&gt; normalized = normalize_matrix(transformed);
julia&gt; reduced = svd(normalized; nsv=10);
julia&gt; fl = force_layout(reduced; ndim=3, k=100)
  DataMatrix (3 variables and 35340 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform</code></pre><p>Note how the last line lists all <code>ProjectionModels</code> used in the creation of <code>fl</code>.</p><p>Next, let&#39;s load some more samples for projection:</p><pre><code class="language-julia hljs">julia&gt; fp2 = [&quot;GSE164378_RNA_ADT_3P_P5.h5&quot;, &quot;GSE164378_RNA_ADT_3P_P6.h5&quot;];
julia&gt; counts2 = load_counts(fp2; sample_names=[&quot;P5&quot;,&quot;P6&quot;]);</code></pre><p>It is easy to project the newly loaded <code>counts2</code> onto the &quot;base&quot; force layout <code>fl</code>:</p><pre><code class="language-julia hljs">julia&gt; project(counts2, fl)
DataMatrix (3 variables and 42553 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform</code></pre><p>We can also project in two or more steps, to get access to intermediate results:</p><pre><code class="language-julia hljs">julia&gt; reduced2 = project(counts2, reduced)
DataMatrix (20239 variables and 42553 observations)
  SVD (10 dimensions)
  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: id, sampleName, barcode
  Models: SVDModel(nsv=10), Normalization, SCTransform

julia&gt; project(reduced2, fl)
DataMatrix (3 variables and 42553 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform</code></pre><p>If the DataMatrix we want to project is modified, we need to use the <code>from</code> kwarg to tell <code>project</code> which models to use:</p><pre><code class="language-julia hljs">julia&gt; filtered = counts2[:,1:10:end]
DataMatrix (33766 variables and 4256 observations)
  SparseArrays.SparseMatrixCSC{Int64, Int32}
  Variables: id, feature_type, name, genome, read, pattern, sequence
  Observations: id, sampleName, barcode
  Models: FilterModel(:, 1:10:42551)

julia&gt; reduced2b = project(filtered2, reduced; from=counts)
DataMatrix (20239 variables and 4256 observations)
  SVD (10 dimensions)
  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: id, sampleName, barcode
  Models: SVDModel(nsv=10), Normalization, SCTransform, Filter</code></pre><p>After that, it is possible to continue without specifying <code>from</code>:</p><pre><code class="language-julia hljs">julia&gt; project(reduced2b, fl)
DataMatrix (3 variables and 4256 observations)
  Matrix{Float64}
  Variables: id
  Observations: id, sampleName, barcode
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Normalization, SCTransform, Filter</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L216-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}" href="#SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}"><code>SingleCellProjections.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)</code></pre><p>Core projection function. Project <code>data</code> based on the single <code>ProjectionModel</code> <code>model</code>. In most cases, it is better to call <code>project(data, base::DataMatrix)</code> instead of using this method directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.pseudobulk-Tuple{DataMatrix, Any, Vararg{String}}" href="#SingleCellProjections.pseudobulk-Tuple{DataMatrix, Any, Vararg{String}}"><code>SingleCellProjections.pseudobulk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pseudobulk(data::DataMatrix, obs_col, [additional_columns...]; var=:copy)</code></pre><p>Create a new <code>DataMatrix</code> by averging over groups, as specified by the categorical annotation <code>obs_col</code> (and optionally additional columns).</p><ul><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li></ul><p><strong>Examples</strong></p><p>Create a pseudobulk representation of each sample:</p><pre><code class="language-julia hljs">julia&gt; pseudobulk(transformed; &quot;sampleName&quot;)</code></pre><p>Create a pseudobulk representation for each celltype in each sample:</p><pre><code class="language-julia hljs">julia&gt; pseudobulk(transformed; &quot;sampleName&quot;, &quot;celltype&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/pseudobulk.jl#L32-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.set_obs_id_cols!-Tuple{DataMatrix, Vector{String}}" href="#SingleCellProjections.set_obs_id_cols!-Tuple{DataMatrix, Vector{String}}"><code>SingleCellProjections.set_obs_id_cols!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_obs_id_cols!(data::DataMatrix, obs_id_cols::Vector{String})</code></pre><p>Set which column(s) to use as observation IDs. The rows of the <code>data.obs</code> table must be unique, considering only the <code>obs_id_cols</code> columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.set_var_id_cols!-Tuple{DataMatrix, Vector{String}}" href="#SingleCellProjections.set_var_id_cols!-Tuple{DataMatrix, Vector{String}}"><code>SingleCellProjections.set_var_id_cols!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_var_id_cols!(data::DataMatrix, var_id_cols::Vector{String})</code></pre><p>Set which column(s) to use as variable IDs. The rows of the <code>data.var</code> table must be unique, considering only the <code>var_id_cols</code> columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T&lt;:Real" href="#SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T&lt;:Real"><code>SingleCellProjections.splitrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitrange(r::UnitRange, nparts::Integer)</code></pre><p>Splits a range in <code>nparts</code> number of parts of equal length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T" href="#SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T"><code>SingleCellProjections.tf_idf_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tf_idf_transform([T=Float64], counts::DataMatrix;
                 var_filter = hasproperty(counts.var, :feature_type) ? :feature_type =&gt; isequal(&quot;Gene Expression&quot;) : nothing,
                 scale_factor = 10_000,
                 idf = vec(size(counts,2) ./ max.(1,sum(counts.matrix; dims=2))),
                 annotate = true,
                 var = :copy,
                 obs = :copy)</code></pre><p>Compute the TF-IDF (term frequency-inverse document frequency) transform of <code>counts</code>, using the formula <code>log( 1 + scale_factor * tf * idf )</code> where <code>tf</code> is the term frequency <code>counts.matrix ./ max.(1, sum(counts.matrix; dims=1))</code>.</p><p>Optionally, <code>T</code> can be specified to control the <code>eltype</code> of the sparse transformed matrix. <code>T=Float32</code> can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.</p><ul><li><code>var_filter</code> - Control which variables (features) to use for parameter estimation. Defaults to <code>:feature_type =&gt; isequal(&quot;Gene Expression&quot;)</code>, if a <code>feature_type</code> column is present in <code>counts.var</code>. Can be set to <code>nothing</code> to disable filtering. See <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a> for how to specify filters.</li><li><code>annotate</code> - If true, <code>idf</code> will be added as a <code>var</code> annotation.</li><li><code>var</code> - Can be <code>:copy</code> (make a copy of source <code>var</code>) or <code>:keep</code> (share the source <code>var</code> object).</li><li><code>obs</code> - Can be <code>:copy</code> (make a copy of source <code>obs</code>) or <code>:keep</code> (share the source <code>obs</code> object).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/transform.jl#L205-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ttest!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ttest!(data::DataMatrix, h1, [group_a], [group_b]; h0, kwargs...)</code></pre><p>Performs a t-Test with the given <code>h1</code> (alternative hypothesis) and <code>h0</code> (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.</p><p><code>ttest!</code> adds a t-statistic, a p-value and a difference column to <code>data.var</code>.</p><p>See <a href="#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}"><code>ttest_table</code></a> for usage examples and more details on computations and parameters.</p><p>In addition <code>ttest!</code> supports the <code>kwarg</code>:</p><ul><li><code>prefix</code> - Output column names for t-statistics, p-values and differences will be prefixed with this string. If none is given, it will be constructed from <code>h1</code>, <code>group_a</code>, <code>group_b</code> and <code>h0</code>.</li></ul><p>See also: <a href="#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}"><code>ttest_table</code></a>, <a href="#SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}"><code>ttest</code></a>, <a href="#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}"><code>ftest!</code></a>, <a href="#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L512-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ttest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ttest(data::DataMatrix, h1, [group_a], [group_b]; h0, var=:copy, obs=:copy, matrix=:keep, kwargs...)</code></pre><p>Performs a t-Test with the given <code>h1</code> (alternative hypothesis) and <code>h0</code> (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.</p><p><code>ttest</code> creates a copy of <code>data</code> and adds a t-statistic, a p-value and a difference column to <code>data.var</code>.</p><p>See <a href="#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}"><code>ttest_table</code></a> and <a href="#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}"><code>ttest!</code></a> for usage examples and more details on computations and parameters.</p><p>See also: <a href="#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}"><code>ttest!</code></a>, <a href="#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}"><code>ttest_table</code></a>, <a href="#SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}"><code>ftest</code></a>, <a href="#SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L540-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}" href="#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}"><code>SingleCellProjections.ttest_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ttest_table(data::DataMatrix, h1, [group_a], [group_b]; h0, kwargs...)</code></pre><p>Performs a t-Test with the given <code>h1</code> (alternative hypothesis) and <code>h0</code> (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.</p><p>T-tests can be performed on any <code>DataMatrix</code>, but it is almost always recommended to do it directly after transforming the data using e.g. <code>sctransform</code>, <code>logtransform</code> or <code>tf_idf_transform</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization</header><div class="admonition-body"><p>Do not use <code>ttest_table</code> after normalizing the data using <code>normalize_matrix</code>: <code>ttest_table</code> needs to know about the <code>h0</code> model (regressed out covariates) for correction computations. Failing to do so can result in incorrect results. If you want to correct for the same covariates, pass them as <code>h0</code> to <code>ttest_table</code>.</p></div></div><p><code>h1</code> can be:</p><ul><li>A string specifying a column name of <code>data.obs</code>. Auto-detection determines if the column is categorical (Two-Group) or numerical (linear regression).<ul><li>If <code>group_a</code> and <code>group_b</code> are specified, a Two-Group test between <code>group_a</code> and <code>group_b</code> is performed.</li><li>If <code>group_a</code> is specified, but not <code>group_b</code>, a Two-Group test between <code>group_a</code> and all other observations is performed.</li></ul></li><li>A <a href="#SingleCellProjections.covariate"><code>covariate</code></a> for more control of how to interpret the values in the column.</li></ul><p><code>ttest_table</code> returns a Dataframe with columns for variable IDs, t-statistics, p-values and differences. For Two-group tests, <code>difference</code> is the difference in mean between the two groups. For linear regression, the difference corresponds to the rate of change.</p><p>Supported <code>kwargs</code> are:</p><ul><li><code>h0</code>                            - Use a non-trivial <code>h0</code> (null) model. Specified in the same way as <code>h1</code> above.</li><li><code>center=true</code>                   - Add an intercept to the <code>h0</code> (null) model.</li><li><code>statistic_col=&quot;t&quot;</code>             - Name of the output column containing the t-statistics. (Set to nothing to remove from output.)</li><li><code>pvalue_col=&quot;pValue&quot;</code>           - Name of the output column containing the p-values. (Set to nothing to remove from output.)</li><li><code>difference_col=&quot;difference&quot;</code>   - Name of the output column containing the differences. (Set to nothing to remove from output.)</li><li><code>h1_missing=:skip</code>              - One of <code>:skip</code> and <code>:error</code>. If <code>skip</code>, missing values in <code>h1</code> columns are skipped, otherwise an error is thrown.</li><li><code>h0_missing=:error</code>             - One of <code>:skip</code> and <code>:error</code>. If <code>skip</code>, missing values in <code>h0</code> columns are skipped, otherwise an error is thrown.</li><li><code>allow_normalized_matrix=false</code> - Set to true to accept running on a <code>DataMatrix</code> that has been normalized.</li></ul><p><strong>Examples</strong></p><p>Perform a Two-Group t-test between celltypes &quot;Mono&quot; and &quot;DC&quot;.</p><pre><code class="language-julia hljs">julia&gt; ttest_table(transformed, &quot;celltype&quot;, &quot;Mono&quot;, &quot;DC&quot;)</code></pre><p>Perform a Two-Group t-test between celltype &quot;Mono&quot; and all other cells.</p><pre><code class="language-julia hljs">julia&gt; ttest_table(transformed, &quot;celltype&quot;, &quot;Mono&quot;)</code></pre><p>Perform a Two-Group t-test between celltypes &quot;Mono&quot; and &quot;DC&quot;, while correcting for &quot;fraction_mt&quot; (a linear covariate).</p><pre><code class="language-julia hljs">julia&gt; ttest_table(transformed, &quot;celltype&quot;, &quot;Mono&quot;, &quot;DC&quot;)</code></pre><p>Perform Linear Regression using the covariate &quot;fraction_mt&quot;.</p><pre><code class="language-julia hljs">julia&gt; ttest_table(transformed, &quot;fraction_mt&quot;)</code></pre><p>See also: <a href="#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}"><code>ttest!</code></a>, <a href="#SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}"><code>ttest</code></a>, <a href="#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}"><code>ftest_table</code></a>, <a href="#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}"><code>mannwhitney_table</code></a>, <a href="#SingleCellProjections.covariate"><code>covariate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/statistical_tests.jl#L432-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.update_matrix" href="#SingleCellProjections.update_matrix"><code>SingleCellProjections.update_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_matrix(data::DataMatrix, matrix, model=nothing;
              var::Union{Symbol,String,DataFrame} = &quot;&quot;,
              obs::Union{Symbol,String,DataFrame} = &quot;&quot;,
              var_id_cols,
              obs_id_cols)</code></pre><p>Create a new <code>DataMatrix</code> by replacing parts of <code>data</code> with new values. Mostly useful when implementing new <code>ProjectionModel</code>s.</p><ul><li><code>matrix</code> - the new matrix.</li><li><code>model</code> - will be appended to the list of models from <code>data</code>. If set to <code>nothing</code>, the resulting list of <code>models</code> will be empty.</li></ul><p>Kwargs:</p><ul><li><code>var</code> - One of:<ul><li><code>:copy</code> - Copy from <code>data</code>.</li><li><code>:keep</code> - Share <code>var</code> with <code>data</code>.</li><li><code>::DataFrame</code> - Replace with a new table with variable annotations.</li><li><code>prefix::String</code> - Prefix, the new variables will be named prefix1, prefix2, etc.</li></ul></li><li><code>obs</code> See <code>var</code>.</li><li><code>var_id_cols</code> - New ID columns. Defaults to the same as data, or &quot;id&quot; if new variables were generated using the &quot;prefix&quot; above.</li><li><code>obs_id_cols</code> - See <code>var_id_cols</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L345-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.ustatistic_single-Union{Tuple{T}, Tuple{AbstractSparseMatrix{T}, Vararg{Any, 4}}} where T" href="#SingleCellProjections.ustatistic_single-Union{Tuple{T}, Tuple{AbstractSparseMatrix{T}, Vararg{Any, 4}}} where T"><code>SingleCellProjections.ustatistic_single</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ustatistic_single(X, j, groups, n1, n2)</code></pre><p>NB: Assumes all sparse non-zeros are positive.</p><p><code>X</code> is a sparse matrix where each column is a variable. <code>j</code> is the current variable. <code>groups</code> is a vector with values: <code>1</code> for each sample in group 1, <code>2</code> for each sample in group 2 and <code>0</code> for samples in neither group. <code>n1</code> number of elements in group 1 (precomputed from <code>groups</code>) <code>n2</code> number of elements in group 2 (precomputed from <code>groups</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/mannwhitney.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.var_coordinates" href="#SingleCellProjections.var_coordinates"><code>SingleCellProjections.var_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">var_coordinates(data::DataMatrix)</code></pre><p>Returns a matrix with coordinates for the variables. Only available for DataMatrices that have a dual representation (e.g. SVD/PCA).</p><p>In the case of <code>SVD</code> (PCA), <code>var_coordinates</code> returns the principal components as unit vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/datamatrix.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{&lt;:AbstractMatrix{&lt;:Integer}}, Vararg{Any}}" href="#SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{&lt;:AbstractMatrix{&lt;:Integer}}, Vararg{Any}}"><code>SingleCellProjections.var_counts_fraction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var_counts_fraction!(counts::DataMatrix, sub_filter, tot_filter, col; check=true)</code></pre><p>For each observation, compute the fraction of counts that match a specific variable pattern.</p><ul><li><code>sub_filter</code> decides which variables are counted.</li><li><code>tot_filter</code> decides which variables to include in the total.</li><li>If <code>check=true</code>, an error will be thrown if no variables match the patterns.</li></ul><p>For more information on filtering syntax, see examples below and the documentation on <a href="https://dataframes.juliadata.org/stable/lib/functions/#Base.filter"><code>DataFrames.filter</code></a>.</p><p><strong>Examples</strong></p><p>Compute the fraction of reads in MT- genes, considering only &quot;Gene Expression&quot; features (and not e.g. &quot;Antibody Capture&quot;).</p><pre><code class="nohighlight hljs">var_counts_fraction!(counts, &quot;name&quot;=&gt;contains(r&quot;^MT-&quot;), &quot;feature_type&quot;=&gt;isequal(&quot;Gene Expression&quot;), &quot;fraction_mt&quot;)</code></pre><p>Compute the fraction of reads in MT- genes, when there is no <code>feature_type</code> annotation (i.e. all variables are genes).</p><pre><code class="nohighlight hljs">var_counts_fraction!(counts, &quot;name&quot;=&gt;contains(r&quot;^MT-&quot;), Returns(true), &quot;fraction_mt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/counts_fraction.jl#L66-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.variable_std-Tuple{DataMatrix}" href="#SingleCellProjections.variable_std-Tuple{DataMatrix}"><code>SingleCellProjections.variable_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_std(data::DataMatrix)</code></pre><p>Computes the variance of each variable in <code>data</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>data</code> must be mean-centered. E.g. by using <code>normalize_matrix</code> before calling <code>variable_std</code>.</p></div></div><p>See also: <a href="#SingleCellProjections.variable_var-Tuple{DataMatrix}"><code>variable_var</code></a>, <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/normalize.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SingleCellProjections.variable_var-Tuple{DataMatrix}" href="#SingleCellProjections.variable_var-Tuple{DataMatrix}"><code>SingleCellProjections.variable_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_var(data::DataMatrix)</code></pre><p>Computes the variance of each variable in <code>data</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>data</code> must be mean-centered. E.g. by using <code>normalize_matrix</code> before calling <code>variable_var</code>.</p></div></div><p>See also: <a href="#SingleCellProjections.variable_std-Tuple{DataMatrix}"><code>variable_std</code></a>, <a href="#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}"><code>normalize_matrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/SingleCellProjections.jl/blob/5e23d9269ad1ccd65de418e9fe8dd9b24207dc2d/src/normalize.jl#L9-L18">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrixexpressions/">« Matrix Expressions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 15 December 2023 19:39">Friday 15 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
