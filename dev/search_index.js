var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [SingleCellProjections]","category":"page"},{"location":"interface/#SingleCellProjections.DataMatrix","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"struct DataMatrix{T,Tv,To}\n\nA DataMatrix represents a matrix together with annotations for variables and observations.\n\nFields:\n\nmatrix::T - The matrix.\nvar::Tv - Variable annotations.\nobs::To - Observation annotations.\nvar_id_cols::Vector{String} - Which column(s) to use as IDs.\nobs_id_cols::Vector{String} - Which column(s) to use as IDs.\nmodels::Vector{ProjectionModel} - Models used in the creation of this DataMatrix.\n\nThe rows of the var and obs tables must be unique, considering only the var_id_cols/obs_id_cols.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"DataMatrix(matrix, var, obs; var_id_cols=nothing, obs_id_cols=nothing)\n\nCreate a DataMatrix with the given matrix, var and obs.\n\nColumns to use for var/obs IDs can be explicitly set with var_id_cols/obs_id_cols. Otherwise, an attempt will be made to autodetect the ID columns.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.DataMatrix-Tuple{}","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"DataMatrix()\n\nCreate an empty DataMatrix{Matrix{Float64},DataFrame,DataFrame}.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.LowRank","page":"Interface","title":"SingleCellProjections.LowRank","text":"LowRank\n\nA matrix decomposition UVᵀ where each row of U represents a variable and each column of Vᵀ represents a sample. Intended for situations where the product is low rank, i.e. size(U,2)==size(Vt,1) is small.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}","page":"Interface","title":"SingleCellProjections.NormalizationModel","text":"NormalizationModel(data::DataMatrix, design::DesignMatrix;\n                   scale=false, min_std=1e-6, annotate=true,\n                   rtol=sqrt(eps()), var=:copy, obs=:copy)\n\nCreate a NormalizationModel based on data and a design matrix.\n\nscale - Set to true to normalize variables to unit standard deviation. Can also be set to a vector with a scaling factor for each variable.\nmin_std - If scale==true, the scale vector is set to 1.0 ./ max.(std, min_std). That is, min_std is used to suppress variables that are very small (and any fluctuations can be assumed to be noise).\nannotate - Only used if scale!=false. With annotate=true, the scale vector is added as a var annotation.\nrtol - Singular values of the design matrix that are ≤rtol are discarded. Needed for numerical stability.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nSee also: normalize_matrix, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.SCTransformModel-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SingleCellProjections.SCTransformModel","text":"SCTransformModel([T=Float64], counts::DataMatrix;\n                 var_filter = hasproperty(counts.var, :feature_type) ? :feature_type => isequal(\"Gene Expression\") : nothing,\n                 rtol=1e-3, atol=0.0, annotate=true,\n                 post_var_filter=:, post_obs_filter=:,\n                 obs=:copy,\n                 kwargs...)\n\nComputes the SCTransform parameter estimates for counts and creates a SCTransformModel that can be applied to the same or another data set. Defaults to only using \"Gene Expression\" features.\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nvar_filter - Control which variables (features) to use for parameter estimation. Defaults to :feature_type => isequal(\"Gene Expression\"), if a feature_type column is present in counts.var. Can be set to nothing to disable filtering. See DataFrames.filter for how to specify filters.\nrtol - Relative tolerance when constructing low rank approximation.\natol - Absolute tolerance when constructing low rank approximation.\nannotate - Set to true to include SCTransform parameter estimates as feature annotations.\npost_var_filter - Equivalent to applying variable (feature) filtering after sctransform, but computationally more efficient.\npost_obs_filter - Equivalent to applying observation (cell) filtering after sctransform, but computationally more efficient.\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\nkwargs... - Additional kwargs are passed on to SCTransform.scparams.\n\nExamples\n\nSetup SCTransformModel (Gene Expression features):\n\njulia> SCTransformModel(counts)\n\nSetup SCTransformModel (Antibody Capture features):\n\njulia> SCTransformModel(counts; var_filter = :feature_type => isequal(\"Antibody Capture\"))\n\nSee also: sctransform, SCTransform.scparams, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.SVDModel","page":"Interface","title":"SingleCellProjections.SVDModel","text":"SVDModel <: ProjectionModel\n\nA model used for projecting onto an SVD object. Normally created using svd(::DataMatrix).\n\nSee also: svd\n\n\n\n\n\n","category":"type"},{"location":"interface/#Base.copy-Tuple{DataMatrix}","page":"Interface","title":"Base.copy","text":"copy(data::DataMatrix; var=:copy, obs=:copy, matrix=:keep)\n\nCopy DataMatrix data. By default, var and obs annotations are copied, but the matrix is shared. Set kwargs var, obs and matrix to :keep/:copy for fine grained control.\n\n\n\n\n\n","category":"method"},{"location":"interface/#LinearAlgebra.svd-Tuple{DataMatrix}","page":"Interface","title":"LinearAlgebra.svd","text":"svd(data::DataMatrix; nsv=3, var=:copy, obs=:copy, kwargs...)\n\nCompute the Singular Value Decomposition (SVD) of data using the Random Subspace SVD algorithm from [Halko et al. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions\"]. SVD is often used to perform Principal Component Analysis (PCA), which assumes that the data is centered.\n\nnsv - The number of singular values.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nAdditional kwargs related to numerical precision are passed to SingleCellProjections.implicitsvd.\n\nSee also: SingleCellProjections.implicitsvd\n\n\n\n\n\n","category":"method"},{"location":"interface/#SCTransform.sctransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SCTransform.sctransform","text":"sctransform([T=Float64], counts::DataMatrix; verbose=true, kwargs...)\n\nCompute the SCTransform of the DataMatrix counts. The result is stored as a Matrix Expression with the sum of a sparse and a low-rank term. I.e. no large dense matrix is created.\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nSee SCTransformModel for description of kwargs....\n\nExamples\n\nCompute SCTransform (Gene Expression features):\n\njulia> sctransform(counts)\n\nCompute SCTransform (Antibody Capture features):\n\njulia> sctransform(counts; var_filter = :feature_type => isequal(\"Antibody Capture\"))\n\nCompute SCTransform (Gene Expression features), using eltype Float32 to lower memory usage:\n\njulia> sctransform(Float32, counts)\n\nSee also: SCTransformModel, SCTransform.scparams\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.covariate","page":"Interface","title":"SingleCellProjections.covariate","text":"covariate(name::String, group_a, [group_b])\n\nCreate a two-group covariate referring to column name, comparing group_a to group_b. group_a and group_b must be values occuring in the column name.\n\nIf group_b is not given, group_a will be compared to all other observations.\n\nSee also: designmatrix\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.covariate-2","page":"Interface","title":"SingleCellProjections.covariate","text":"covariate(name::String, type=:auto)\n\nCreate a covariate referring to column name. type must be one of :auto, :numerical, :categorical, :twogroup and :intercept. :auto means auto-detection by checking if the values in the column are numerical or categorical. type==:intercept adds an intercept to the model (in which case the name parameter is ignored).\n\nSee also: designmatrix\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.designmatrix","text":"designmatrix(data::DataMatrix, [covariates...]; center=true, max_categories=100)\n\nCreates a design matrix from data.obs and the given covariates. Covariates can be specied using strings (column name in data.obs), with autodetection of whether the covariate is numerical or categorical, or using the covariate function for more control.\n\ncenter - If true, an intercept is added to the design matrix. (Should only be set to false in very rare circumstances.)\nmax_categories - Safety parameter, an error will be thrown if there are too many categories. In this case, it is likely a mistake that the covariate was used as a categorical covariate. Using a very large number of categories is also bad for performance and memory consumption.\n\nExamples\n\nCentering only:\n\njulia> designmatrix(data)\n\nRegression model with intercept (centering) and \"fraction_mt\" (numerical annotation):\n\njulia> designmatrix(data, \"fraction_mt\")\n\nAs above, but also including \"batch\" (categorical annotation):\n\njulia> designmatrix(data, \"fraction_mt\", \"batch\")\n\nSee also: normalize_matrix, NormalizationModel, covariate\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_matrix","text":"filter_matrix(fvar, fobs, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the variables and observations passing the filters.\n\nfvar/fobs can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all variables/observations should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nAlso note that indexing of a DataMatrix supports AbstractVectors of indices/booleans and :, and is otherwise identical to filter_matrix.\n\nExamples\n\nKeep every 10th variable and 3rd observation:\n\njulia> filter_matrix(1:10:size(data,1), 1:3:size(data,2), data)\n\nOr, using indexing syntax:\n\njulia> data[1:10:end, 1:3:end]\n\nFor more examples, see filter_var and filter_obs.\n\nSee also: filter_var, filter_obs, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_obs","text":"filter_obs(f, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the observations passing the filter.\n\nf can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all observations should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nExamples\n\nKeep every 10th observation:\n\njulia> filter_obs(1:10:size(data,2), data)\n\nRemove observations where \"celltype\" equals \"other\":\n\njulia> filter_obs(\"celltype\"=>!isequal(\"other\"), data)\n\nSee also: filter_matrix, filter_var, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_var","text":"filter_var(f, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the variables passing the filter.\n\nf can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all variables should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nExamples\n\nKeep every 10th variable:\n\njulia> filter_var(1:10:size(data,1), data)\n\nKeep only variables of the type \"Gene Expression\":\n\njulia> filter_var(\"feature_type\"=>isequal(\"Gene Expression\"), data)\n\nSee also: filter_matrix, filter_obs, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.force_layout-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.force_layout","text":"force_layout(data::DataMatrix;\n             ndim=3,\n             k,\n             adj,\n             kprojection=10,\n             obs=:copy,\n             adj_out,\n             niter = 100,\n             link_distance = 4,\n             link_strength = 2,\n             charge = 5,\n             charge_min_distance = 1,\n             theta = 0.9,\n             center_strength = 0.05,\n             velocity_decay = 0.9,\n             initialAlpha = 1.0,\n             finalAlpha = 1e-3,\n             initialScale = 10,\n             rng)\n\nCompute the Force Layout (also known as a force directed knn-graph or SPRING plots) for data. Usually, data is a DataMatrix after reduction to 10-100 dimensions by svd.\n\nA Force Layout is computed by running a physics simulation were the observations are connected by springs (such that connected observations are attracted), a general \"charge\" force repelling all observations from each other and a centering force that keep the observations around the origin. The implementation is based on d3-force: https://github.com/d3/d3-force, also see LICENSE.md.\n\nExactly one of the kwargs k and adj must be provided. See details below.\n\nGeneral parameters:\n\nk - Number of nearest neighbors to connect each observation to (computes adj below).\nadj - An sparse, symmetric, adjacency matrix with booleans. true if two observations are connected by a spring and false otherwise.\nkprojection - The number of nearest neighbors used when projecting onto the resulting force layout. (Not used in the computation of the layout, only during projection.)\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\nadj_out - Optional Ref. If specified, the (computed) adj matrix will be assigned to adj_out.\n\nParamters controlling the physics simulation:\n\nniter - Number of iterations to run the simulation.\nlink_distance - The length of each spring.\nlink_strength - The strength of the spring force.\ncharge - The strength of the charge force.\ncharge_min_distance - Used to avoid numerical instabilities by limiting the charge force for observations that are very close.\ntheta - Parameter controlling accuracy in the Barnes-Hut approximation for charge forces.\ncenter_strength - Strength of the centering force.\nvelocity_decay - At each iteration, the current velocity for an observations is multiplied by velocity_decay.\ninitialAlpha - The alpha value decreases over time and allows larger changes to happen early, while being more stable towards the end.\nfinalAlpha - See initialAlpha\ninitialScale - The simulation is initialized by randomly drawing each observation from a multivariate Gaussian, and is scaled by initialScale.\nrng - Optional RNG object. Useful for reproducibility.\n\nExamples\n\njulia> force_layout(data; ndim=3, k=100)\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}","page":"Interface","title":"SingleCellProjections.ftest!","text":"ftest!(data::DataMatrix, h1; h0, kwargs...)\n\nPerforms an F-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used.\n\nftest! adds a F-statistic and a p-value column to data.var.\n\nSee ftest_table for usage examples and more details on computations and parameters.\n\nIn addition ftest! supports the kwarg:\n\nprefix - Output column names for F-statistics and p-values will be prefixed with this string. If none is given, it will be constructed from h1 and h0.\n\nSee also: ftest_table, ftest, ttest!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ftest","text":"ftest(data::DataMatrix, h1; h0, var=:copy, obs=:copy, matrix=:keep, kwargs...)\n\nPerforms an F-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used.\n\nftest creates a copy of data and adds a F-statistic and a p-value column to data.var.\n\nSee ftest_table and ftest! for usage examples and more details on computations and parameters.\n\nSee also: ftest!, ftest_table, ttest\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}","page":"Interface","title":"SingleCellProjections.ftest_table","text":"ftest_table(data::DataMatrix, h1; h0, kwargs...)\n\nPerforms an F-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used. (See \"Examples\" below for concrete examples.)\n\nF-tests can be performed on any DataMatrix, but it is almost always recommended to do it directly after transforming the data using e.g. sctransform, logtransform or tf_idf_transform.\n\nnote: Normalization\nDo not use ftest_table after normalizing the data using normalize_matrix: ftest_table needs to know about the h0 model (regressed out covariates) for correction computations. Failing to do so can result in incorrect results. If you want to correct for the same covariates, pass them as h0 to ftest_table.\n\nh1 can be:\n\nA string specifying a column name of data.obs. Auto-detection determines if the column is categorical (ANOVA) or numerical.\nA covariate for more control of how to interpret the values in a column.\nA tuple or vector of the above for compound models.\n\nftest_table returns a Dataframe with columns for variable IDs, F-statistics and p-values.\n\nSupported kwargs are:\n\nh0                  - Use a non-trivial h0 (null) model. Specified in the same way as h1 above.\ncenter=true         - Add an intercept to the h0 (null) model.\nstatistic_col=\"F\"   - Name of the output column containing the F-statistics. (Set to nothing to remove from output.)\npvalue_col=\"pValue\" - Name of the output column containing the p-values. (Set to nothing to remove from output.)\nh1_missing=:skip    - One of :skip and :error. If skip, missing values in h1 columns are skipped, otherwise an error is thrown.\nh0_missing=:error   - One of :skip and :error. If skip, missing values in h0 columns are skipped, otherwise an error is thrown.\nallow_normalized_matrix=false - Set to true to accept running on a DataMatrix that has been normalized.\n\nExamples\n\nPerform an ANOVA using the \"celltype\" annotation.\n\njulia> ftest_table(transformed, \"celltype\")\n\nPerform an ANOVA using the \"celltype\" annotation, while correcting for fraction_mt (a linear covariate).\n\njulia> ftest_table(transformed, \"celltype\"; h0=\"fraction_mt\")\n\nPerform an ANOVA using the \"celltype\" annotation, while correcting for fraction_mt (a linear covariate) and \"phase\" (a categorical covariate).\n\njulia> ftest_table(transformed, \"celltype\"; h0=(\"fraction_mt\",\"phase\"))\n\nPerform Quadractic Regression using the covariate x, by first creating an annotation for x squared, and then using a compound model.\n\njulia> data.obs.x2 = data.obs.x.^2;\n\njulia> ftest_table(transformed, (\"x\",\"x2\"))\n\nSee also: ftest!, ftest, ttest_table, covariate\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.implicitsvd-Tuple{Any}","page":"Interface","title":"SingleCellProjections.implicitsvd","text":"implicitsvd(A; nsv=3, subspacedims=4nsv, niter=2, stabilize_sign=true, rng)\n\nCompute the SVD of A using Random Subspace SVD. [Halko et al. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions\"]\n\nnsv - Number of singular values/vectors to compute\nsubspacedims - Number of dimensions used for the subspace approximating the action of A.\nniter - Number of iterations. In each iteration, one multiplication of A with a matrix and one multiplication of A' with a matrix will be performed.\nstabilize_sign - If true, handles the problem that the SVD is only unique up to the sign of each component (for real matrices), by ensuring that the l1 norm of the positive entires for each column in U is larger than the l1 norm of the negative entries.\nrng - Specify a custom RNG.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load10x-Tuple{Any}","page":"Interface","title":"SingleCellProjections.load10x","text":"load10x(filename; lazy=false, copy_obs_col=\"barcode\"=>\"id\", kwargs...)\n\nLoad a CellRanger \".h5\" or \".mtx[.gz]\" file as a DataMatrix.\n\nlazy - If true, the count matrix itself will not be loaded, only features and barcodes. This is used internally in load_counts to merge samples more efficiently. Use load_counts to later load the count data.\ncopy_obs_col - Set to nothing to disable. Defaults to a pair \"barcode\"=>\"id\", which copies the obs annotation barcode to a new column id.\nAdditional kwargs... are passed to the DataMatrix constructor.\n\nExamples\n\nLoad counts from a CellRanger \".h5\" file. (Recommended.)\n\njulia> counts = load10x(\"filtered_feature_bc_matrix.h5\")\n\nLoad counts from a CellRanger \".mtx\" file. Tries to find barcode and feature annotation files in the same folder.\n\njulia> counts = load10x(\"matrix.mtx.gz\")\n\nLazy loading followed by loading.\n\njulia> counts = load10x(\"filtered_feature_bc_matrix.h5\");\njulia> counts = load_counts(counts)\n\nSee also: load_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Tuple{Any, Any}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts([loadfun=load10x], filenames;\n            sample_names,\n            sample_name_col,\n            merged_obs_id_col = \"id\",\n            lazy,\n            lazy_merge = false,\n            var_id_cols=nothing,\n            merged_obs_id_delim = '_',\n            callback=nothing)\n\nLoad and merge multiple samples efficiently.\n\nDefaults to loading 10x CellRanger files. The files are first loaded lazily, then the merged count matrix is allocated and finally each sample is loaded directly into the merged count matrix. (This strategy greatly reduces memory usage, since only one copy of data is needed instead of two.)\n\nThe vector filenames specifies which files to load. For each file, loadfun is called.\n\nsample_names - Specify the sample names. Should be a vector of the same length as filenames. Set to nothing to not create a sample name annotation.\nsample_name_col - Column for sample names in obs, defaults to \"sampleName\".\nmerged_obs_id_col - Colum for merged ids in obs.\nlazy - Enable lazy loading. Defaults to true if load10x is used, and false otherwise.\nlazy_merge - Enable lazy merging, i.e. var and obs are created, but the count matrix merging is postponed until a second call to load_counts.\nvar_id_cols - Specify variable id columns. Defaults to nothing, i.e. autodetecting from the samples.\nmerged_obs_id_delim - Delimiter used when creating merged obs IDs.\ncallback - Experimental callback functionality. The callback function is called between samples during merging. Return true to abort loading and false to continue.\n\nExamples\n\nLoad and name samples:\n\njulia> counts = load_counts([\"s1.h5\", \"s2.h5\"]; sample_names=[\"Sample A\", \"Sample B\"])\n\nSee also: load10x, merge_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Tuple{DataMatrix{<:SingleCellProjections.Lazy10xMatrix}}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts(data::DataMatrix{<:Lazy10xMatrix})\n\nLoad counts for a lazily loaded 10x DataMatrix.\n\nSee also: load10x\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Union{Tuple{DataMatrix{<:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts(data::DataMatrix{<:LazyMergedMatrix})\n\nMerge/load counts for a lazily merged DataMatrix.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.loadh5ad-Tuple{Any}","page":"Interface","title":"SingleCellProjections.loadh5ad","text":"loadh5ad(filename; var_id_column=:id, obs_id_column=:id)\n\nExperimental loading of .h5ad files.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SingleCellProjections.logtransform","text":"logtransform([T=Float64], counts::DataMatrix;\n             var_filter = hasproperty(counts.var, :feature_type) ? :feature_type => isequal(\"Gene Expression\") : nothing,\n             scale_factor=10_000,\n             var=:copy,\n             obs=:copy)\n\nLog₂-transform counts using the formula:\n\n  log₂(1 + cᵢⱼ*scale_factor/(∑ᵢcᵢⱼ))\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nvar_filter - Control which variables (features) to use for parameter estimation. Defaults to :feature_type => isequal(\"Gene Expression\"), if a feature_type column is present in counts.var. Can be set to nothing to disable filtering. See DataFrames.filter for how to specify filters.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nExamples\n\njulia> transformed = logtransform(counts)\n\nUse eltype Float32 to lower memory usage:\n\njulia> transformed = logtransform(Float32, counts)\n\nSee also: sctransform\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.mannwhitney!","text":"mannwhitney!(data::DataMatrix, column, [group_a, group_b]; kwargs...)\n\nPerform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.\n\nNote that data must be a DataMatrix containing a sparse matrix only. It is recommended to first logtransform (or tf_idf_transform) the raw counts before performing the Mann-Whitney U-test.\n\nmannwhitney! adds a U statistic and a p-value column to data.var. See mannwhitney_table for more details on groups and kwargs.\n\nIn addition mannwhitney! supports the kwarg:\n\nprefix - Output column names for U statistics and p-values will be prefixed with this string. If none is given, it will be constructed from column, group_a and group_b.\n\nSee also: mannwhitney_table, mannwhitney\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.mannwhitney","text":"mannwhitney(data::DataMatrix, column, [group_a, group_b]; var=:copy, obs=:copy, matrix=:keep, kwargs...)\n\nPerform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.\n\nNote that data must be a DataMatrix containing a sparse matrix only. It is recommended to first logtransform (or tf_idf_transform) the raw counts before performing the Mann-Whitney U-test.\n\nmannwhitney creates a copy of data and adds a U statistic and a p-value column to data.var. See mannwhitney! and mannwhitney_table for more details on groups and kwargs.\n\nSee also: mannwhitney!, mannwhitney_table\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.mannwhitney_table","text":"mannwhitney_table(data::DataMatrix, column, [group_a, group_b]; kwargs...)\n\nPerform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.\n\nNote that data must be a DataMatrix containing a sparse matrix only. It is recommended to first logtransform (or tf_idf_transform) the raw counts before performing the Mann-Whitney U-test.\n\ncolumn specifies a column in data.obs and is used to determine which observations belong in which group.\n\nIf group_a and group_b are not given, the column must contain exactly two unique values (except missing). If group_a is given, but not group_b, the observations in group A are compared to all other observations (except missing). If both group_a and group_b are given, the observations in group A are compared the observations in group B.\n\nmannwhitney_table returns a Dataframe with columns for variable IDs, U statistics and p-values.\n\nSupported kwargs are:\n\nstatistic_col=\"U\"   - Name of the output column containing the U statistics. (Set to nothing to remove from output.)\npvalue_col=\"pValue\" - Name of the output column containing the p-values. (Set to nothing to remove from output.)\nh1_missing=:skip    - One of :skip and :error. If skip, missing values in column are skipped, otherwise an error is thrown.\n\nThe following kwargs determine how the computations are threaded:\n\nnworkers      - Number of worker threads used in the computation. Set to 1 to disable threading.\nchunk_size    - Number of variables processed in each chunk.\nchannel_size  - Max number of unprocessed chunks in queue.\n\nSee also: mannwhitney!, mannwhitney\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.merge_counts-Tuple{Any, Any}","page":"Interface","title":"SingleCellProjections.merge_counts","text":"merge_counts(samples, sample_names;\n             lazy=false,\n             var_id_cols=nothing,\n             sample_name_col = sample_names===nothing ? nothing : \"sampleName\",\n             merged_obs_id_col = \"id\",\n             merged_obs_id_delim = '_',\n             callback=nothing)\n\nMerge samples to create one large DataMatrix, by concatenating the obs. The union of the variables from the samples is used, and if a variable is not present in a sample, the count will be set to zero.\n\nThe obs IDs are created by concatenating the current obs ID columns, together with the sample_names (if provided).\n\nlazy - Lazy merging. Use load_counts to actually perform the merging.\nvar_id_cols - Set to nothing to autodetect from the samples.\nsample_name_col - Column in which the sample_names are stored.\nmerged_obs_id_col - obs ID column after merging. Set to nothing to keep current ID cols (will add sampleName as a separate ID column, if provided.)\nmerged_obs_id_delim - Delimiter used when merging obs IDs.\ncallback - Experimental callback functionality. The callback function is called between samples during merging. Return true to abort loading and false to continue.\n\nSee also: load_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}","page":"Interface","title":"SingleCellProjections.normalize_matrix","text":"normalize_matrix(data::DataMatrix, design::DesignMatrix; scale=false, kwargs...)\n\nNormalize data using the specified design matrix.\n\nSee also: NormalizationModel, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.normalize_matrix","text":"normalize_matrix(data::DataMatrix, [covariates...]; center=true, scale=false, kwargs...)\n\nNormalize data. By default, the matrix is centered. Any covariates specified (using column names of data.obs) will be regressed out.\n\ncenter - Set to true to center the data matrix.\nscale - Set to true to scale the variables in the data matrix to unit standard deviation.\n\nFor other kwargs and more detailed descriptions, see NormalizationModel and designmatrix.\n\nExamples\n\nCentering only:\n\njulia> normalize_matrix(data)\n\nRegression model with intercept (centering) and \"fraction_mt\" (numerical annotation):\n\njulia> normalize_matrix(data, \"fraction_mt\")\n\nAs above, but also including \"batch\" (categorical annotation):\n\njulia> normalize_matrix(data, \"fraction_mt\", \"batch\")\n\nSee also: NormalizationModel, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.obs_coordinates","page":"Interface","title":"SingleCellProjections.obs_coordinates","text":"obs_coordinates(data::DataMatrix)\n\nReturns a matrix with coordinates for the observations. Not available for all types of DataMatrices. Mostly useful for data matrices after dimension reduction such as svd or force_layout has been applied.\n\nIn the case of SVD (PCA), obs_coordinates returns the principal components, scaled by the singular values. This is a a good starting point for downstream analysis, since it is the optimal linear approximation of the original data for the given number of dimensions.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{<:ProjectionModel}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)\n\nConvenience function for projection onto multiple models. Essentially calls foldl and prints some @info messages (if verbose=true). In most cases, it is better to call project(data, base::DataMatrix) instead of using this method directly.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, base::DataMatrix, args...; from=nothing, kwargs...)\n\nProject data onto base, by applying ProjectionModels from base one by one.\n\nSince data already might have some models applied, project will try to figure out which models from base to use. See \"Examples\" below for concrete examples. Here's a more technical overview:\n\nConsider a base data matrix with four models:\n\nbase: A -> B -> C -> D\n\nGiven some new data (typically counts), we can project that onto base, given the result proj by applying all four models:\n\ndata:\nproj: A -> B -> C -> D\n\nIf data already has some models applied (e.g. we already projected onto A and B above), project will look for the last model in data (in this case B) in the list of models in base, and only apply models after that (in this case C and D).\n\ndata: A -> B\nproj: A -> B -> C -> D\n\nIt is also possible to use the from kwarg to specify exactly which models to apply. (The models in from must be a prefix of the models in base, or in other words, base was created by applying additional operations to from.)\n\ndata: X\nbase: A -> B -> C -> D\nfrom: A -> B\nproj: X -> C -> D\n\nNote that it is necessary to use the from kwarg if the last model in data does not occurr in base, because project cannot figure out on its own which models it makes sense to apply.\n\nExamples\n\nFirst, we construct a \"base\" by loading counts, SCTransforming, normalizing, computing the svd and finally computing a force layout:\n\njulia> fp = [\"GSE164378_RNA_ADT_3P_P1.h5\", \"GSE164378_RNA_ADT_3P_P2.h5\"];\njulia> counts = load_counts(fp; sample_names=[\"P1\",\"P2\"]);\njulia> transformed = sctransform(counts);\njulia> normalized = normalize_matrix(transformed);\njulia> reduced = svd(normalized; nsv=10);\njulia> fl = force_layout(reduced; ndim=3, k=100)\n  DataMatrix (3 variables and 35340 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nNote how the last line lists all ProjectionModels used in the creation of fl.\n\nNext, let's load some more samples for projection:\n\njulia> fp2 = [\"GSE164378_RNA_ADT_3P_P5.h5\", \"GSE164378_RNA_ADT_3P_P6.h5\"];\njulia> counts2 = load_counts(fp2; sample_names=[\"P5\",\"P6\"]);\n\nIt is easy to project the newly loaded counts2 onto the \"base\" force layout fl:\n\njulia> project(counts2, fl)\nDataMatrix (3 variables and 42553 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nWe can also project in two or more steps, to get access to intermediate results:\n\njulia> reduced2 = project(counts2, reduced)\nDataMatrix (20239 variables and 42553 observations)\n  SVD (10 dimensions)\n  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...\n  Observations: id, sampleName, barcode\n  Models: SVDModel(nsv=10), Normalization, SCTransform\n\njulia> project(reduced2, fl)\nDataMatrix (3 variables and 42553 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nIf the DataMatrix we want to project is modified, we need to use the from kwarg to tell project which models to use:\n\njulia> filtered = counts2[:,1:10:end]\nDataMatrix (33766 variables and 4256 observations)\n  SparseArrays.SparseMatrixCSC{Int64, Int32}\n  Variables: id, feature_type, name, genome, read, pattern, sequence\n  Observations: id, sampleName, barcode\n  Models: FilterModel(:, 1:10:42551)\n\njulia> reduced2b = project(filtered2, reduced; from=counts)\nDataMatrix (20239 variables and 4256 observations)\n  SVD (10 dimensions)\n  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...\n  Observations: id, sampleName, barcode\n  Models: SVDModel(nsv=10), Normalization, SCTransform, Filter\n\nAfter that, it is possible to continue without specifying from:\n\njulia> project(reduced2b, fl)\nDataMatrix (3 variables and 4256 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform, Filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)\n\nCore projection function. Project data based on the single ProjectionModel model. In most cases, it is better to call project(data, base::DataMatrix) instead of using this method directly.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.set_obs_id_cols!-Tuple{DataMatrix, Vector{String}}","page":"Interface","title":"SingleCellProjections.set_obs_id_cols!","text":"set_obs_id_cols!(data::DataMatrix, obs_id_cols::Vector{String})\n\nSet which column(s) to use as observation IDs. The rows of the data.obs table must be unique, considering only the obs_id_cols columns.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.set_var_id_cols!-Tuple{DataMatrix, Vector{String}}","page":"Interface","title":"SingleCellProjections.set_var_id_cols!","text":"set_var_id_cols!(data::DataMatrix, var_id_cols::Vector{String})\n\nSet which column(s) to use as variable IDs. The rows of the data.var table must be unique, considering only the var_id_cols columns.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T<:Real","page":"Interface","title":"SingleCellProjections.splitrange","text":"splitrange(r::UnitRange, nparts::Integer)\n\nSplits a range in nparts number of parts of equal length.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SingleCellProjections.tf_idf_transform","text":"tf_idf_transform([T=Float64], counts::DataMatrix;\n                 var_filter = hasproperty(counts.var, :feature_type) ? :feature_type => isequal(\"Gene Expression\") : nothing,\n                 scale_factor = 10_000,\n                 idf = vec(size(counts,2) ./ max.(1,sum(counts.matrix; dims=2))),\n                 annotate = true,\n                 var = :copy,\n                 obs = :copy)\n\nCompute the TF-IDF (term frequency-inverse document frequency) transform of counts, using the formula log( 1 + scale_factor * tf * idf ) where tf is the term frequency counts.matrix ./ max.(1, sum(counts.matrix; dims=1)).\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nvar_filter - Control which variables (features) to use for parameter estimation. Defaults to :feature_type => isequal(\"Gene Expression\"), if a feature_type column is present in counts.var. Can be set to nothing to disable filtering. See DataFrames.filter for how to specify filters.\nannotate - If true, idf will be added as a var annotation.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ttest!","text":"ttest!(data::DataMatrix, h1, [group_a], [group_b]; h0, kwargs...)\n\nPerforms a t-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.\n\nttest! adds a t-statistic, a p-value and a difference column to data.var.\n\nSee ttest_table for usage examples and more details on computations and parameters.\n\nIn addition ttest! supports the kwarg:\n\nprefix - Output column names for t-statistics, p-values and differences will be prefixed with this string. If none is given, it will be constructed from h1, group_a, group_b and h0.\n\nSee also: ttest_table, ttest, ftest!, mannwhitney!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ttest","text":"ttest(data::DataMatrix, h1, [group_a], [group_b]; h0, var=:copy, obs=:copy, matrix=:keep, kwargs...)\n\nPerforms a t-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.\n\nttest creates a copy of data and adds a t-statistic, a p-value and a difference column to data.var.\n\nSee ttest_table and ttest! for usage examples and more details on computations and parameters.\n\nSee also: ttest!, ttest_table, ftest, mannwhitney\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ttest_table","text":"ttest_table(data::DataMatrix, h1, [group_a], [group_b]; h0, kwargs...)\n\nPerforms a t-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.\n\nT-tests can be performed on any DataMatrix, but it is almost always recommended to do it directly after transforming the data using e.g. sctransform, logtransform or tf_idf_transform.\n\nnote: Normalization\nDo not use ttest_table after normalizing the data using normalize_matrix: ttest_table needs to know about the h0 model (regressed out covariates) for correction computations. Failing to do so can result in incorrect results. If you want to correct for the same covariates, pass them as h0 to ttest_table.\n\nh1 can be:\n\nA string specifying a column name of data.obs. Auto-detection determines if the column is categorical (Two-Group) or numerical (linear regression).\nIf group_a and group_b are specified, a Two-Group test between group_a and group_b is performed.\nIf group_a is specified, but not group_b, a Two-Group test between group_a and all other observations is performed.\nA covariate for more control of how to interpret the values in the column.\n\nttest_table returns a Dataframe with columns for variable IDs, t-statistics, p-values and differences. For Two-group tests, difference is the difference in mean between the two groups. For linear regression, the difference corresponds to the rate of change.\n\nSupported kwargs are:\n\nh0                            - Use a non-trivial h0 (null) model. Specified in the same way as h1 above.\ncenter=true                   - Add an intercept to the h0 (null) model.\nstatistic_col=\"t\"             - Name of the output column containing the t-statistics. (Set to nothing to remove from output.)\npvalue_col=\"pValue\"           - Name of the output column containing the p-values. (Set to nothing to remove from output.)\ndifference_col=\"difference\"   - Name of the output column containing the differences. (Set to nothing to remove from output.)\nh1_missing=:skip              - One of :skip and :error. If skip, missing values in h1 columns are skipped, otherwise an error is thrown.\nh0_missing=:error             - One of :skip and :error. If skip, missing values in h0 columns are skipped, otherwise an error is thrown.\nallow_normalized_matrix=false - Set to true to accept running on a DataMatrix that has been normalized.\n\nExamples\n\nPerform a Two-Group t-test between celltypes \"Mono\" and \"DC\".\n\njulia> ttest_table(transformed, \"celltype\", \"Mono\", \"DC\")\n\nPerform a Two-Group t-test between celltype \"Mono\" and all other cells.\n\njulia> ttest_table(transformed, \"celltype\", \"Mono\")\n\nPerform a Two-Group t-test between celltypes \"Mono\" and \"DC\", while correcting for \"fraction_mt\" (a linear covariate).\n\njulia> ttest_table(transformed, \"celltype\", \"Mono\", \"DC\")\n\nPerform Linear Regression using the covariate \"fraction_mt\".\n\njulia> ttest_table(transformed, \"fraction_mt\")\n\nSee also: ttest!, ttest, ftest_table, mannwhitney_table, covariate\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.update_matrix","page":"Interface","title":"SingleCellProjections.update_matrix","text":"update_matrix(data::DataMatrix, matrix, model=nothing;\n              var::Union{Symbol,String,DataFrame} = \"\",\n              obs::Union{Symbol,String,DataFrame} = \"\",\n              var_id_cols,\n              obs_id_cols)\n\nCreate a new DataMatrix by replacing parts of data with new values. Mostly useful when implementing new ProjectionModels.\n\nmatrix - the new matrix.\nmodel - will be appended to the list of models from data. If set to nothing, the resulting list of models will be empty.\n\nKwargs:\n\nvar - One of:\n:copy - Copy from data.\n:keep - Share var with data.\n::DataFrame - Replace with a new table with variable annotations.\nprefix::String - Prefix, the new variables will be named prefix1, prefix2, etc.\nobs See var.\nvar_id_cols - New ID columns. Defaults to the same as data, or \"id\" if new variables were generated using the \"prefix\" above.\nobs_id_cols - See var_id_cols.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.ustatistic_single-Union{Tuple{T}, Tuple{AbstractSparseMatrix{T}, Vararg{Any, 4}}} where T","page":"Interface","title":"SingleCellProjections.ustatistic_single","text":"ustatistic_single(X, j, groups, n1, n2)\n\nNB: Assumes all sparse non-zeros are positive.\n\nX is a sparse matrix where each column is a variable. j is the current variable. groups is a vector with values: 1 for each sample in group 1, 2 for each sample in group 2 and 0 for samples in neither group. n1 number of elements in group 1 (precomputed from groups) n2 number of elements in group 2 (precomputed from groups)\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.var_coordinates","page":"Interface","title":"SingleCellProjections.var_coordinates","text":"var_coordinates(data::DataMatrix)\n\nReturns a matrix with coordinates for the variables. Only available for DataMatrices that have a dual representation (e.g. SVD/PCA).\n\nIn the case of SVD (PCA), var_coordinates returns the principal components as unit vectors.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{<:AbstractMatrix{<:Integer}}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.var_counts_fraction!","text":"var_counts_fraction!(counts::DataMatrix, sub_filter, tot_filter, col; check=true)\n\nFor each observation, compute the fraction of counts that match a specific variable pattern.\n\nsub_filter decides which variables are counted.\ntot_filter decides which variables to include in the total.\nIf check=true, an error will be thrown if no variables match the patterns.\n\nFor more information on filtering syntax, see examples below and the documentation on DataFrames.filter.\n\nExamples\n\nCompute the fraction of reads in MT- genes, considering only \"Gene Expression\" features (and not e.g. \"Antibody Capture\").\n\nvar_counts_fraction!(counts, \"name\"=>contains(r\"^MT-\"), \"feature_type\"=>isequal(\"Gene Expression\"), \"fraction_mt\")\n\nCompute the fraction of reads in MT- genes, when there is no feature_type annotation (i.e. all variables are genes).\n\nvar_counts_fraction!(counts, \"name\"=>contains(r\"^MT-\"), Returns(true), \"fraction_mt\")\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.variable_std-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.variable_std","text":"variable_std(data::DataMatrix)\n\nComputes the variance of each variable in data.\n\nnote: Note\ndata must be mean-centered. E.g. by using normalize_matrix before calling variable_std.\n\nSee also: variable_var, normalize_matrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.variable_var-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.variable_var","text":"variable_var(data::DataMatrix)\n\nComputes the variance of each variable in data.\n\nnote: Note\ndata must be mean-centered. E.g. by using normalize_matrix before calling variable_var.\n\nSee also: variable_std, normalize_matrix\n\n\n\n\n\n","category":"method"},{"location":"datamatrices/#Data-Matrices","page":"Data Matrices","title":"Data Matrices","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"# Mimic the dataset from the tutorial without including it in the docs building\n\n\n# Useful function to extract a little data from a DataMatrix to use here for show\n# function f(col, n; h=10, t=10, filler=\"\")\n# \t@assert h+t <= n\n# \tpre = string(col[1:h])\n# \tmid = string(\"fill(\\\"\", filler, \"\\\", \", n-h-t, \")\")\n# \tpost = string(col[end-t+1:end])\n# \tstring(\"vcat(\", pre, \", \", mid, \", \", post, ')')\n# end\n\n\n\nusing SingleCellProjections, SparseArrays, DataFrames\nP,N = 33766,35340\nX = sparse(Int32[], Int32[], Int[], P, N)\n\nv_id = vcat([\"MIR1302-2HG\", \"FAM138A\", \"OR4F5\", \"AL627309.1\", \"AL627309.3\", \"AL627309.2\", \"AL627309.4\", \"AL732372.1\", \"OR4F29\", \"AC114498.1\"], string.(\"dummy_\", 1:33746), [\"CD169\", \"CD28\", \"CD161\", \"CD163\", \"CD138-1\", \"CD164\", \"CD138-2\", \"CD144\", \"CD202b\", \"CD11c\"])\nv_feature_type = vcat(fill(\"Gene Expression\",33538), fill(\"Antibody Capture\", P-33538))\n\no_id = vcat([\"P1_L1_AAACCCAAGACATACA\", \"P1_L1_AAACCCACATCGGTTA\", \"P1_L1_AAACCCAGTGGAACAC\", \"P1_L1_AAACCCATCTGCGGAC\", \"P1_L1_AAACGAAAGTTACTCG\", \"P1_L1_AAACGAACAATGAGCG\", \"P1_L1_AAACGAACACTCCTTG\", \"P1_L1_AAACGAACAGCATCTA\", \"P1_L1_AAACGAATCCTCACCA\", \"P1_L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:35320), [\"P2_L5_TTTGGTTGTCCGAAAG\", \"P2_L5_TTTGGTTTCCTCTAGC\", \"P2_L5_TTTGGTTTCGTAGGGA\", \"P2_L5_TTTGGTTTCTTTGATC\", \"P2_L5_TTTGTTGAGTGTACCT\", \"P2_L5_TTTGTTGGTACGATCT\", \"P2_L5_TTTGTTGGTCCTTAAG\", \"P2_L5_TTTGTTGTCAACACCA\", \"P2_L5_TTTGTTGTCATGCATG\", \"P2_L5_TTTGTTGTCCGTGCGA\"])\no_sampleName = vcat(fill(\"P1\",18135), fill(\"P2\", N-18135))\no_barcode = vcat([\"L1_AAACCCAAGACATACA\", \"L1_AAACCCACATCGGTTA\", \"L1_AAACCCAGTGGAACAC\", \"L1_AAACCCATCTGCGGAC\", \"L1_AAACGAAAGTTACTCG\", \"L1_AAACGAACAATGAGCG\", \"L1_AAACGAACACTCCTTG\", \"L1_AAACGAACAGCATCTA\", \"L1_AAACGAATCCTCACCA\", \"L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:35320), [\"L5_TTTGGTTGTCCGAAAG\", \"L5_TTTGGTTTCCTCTAGC\", \"L5_TTTGGTTTCGTAGGGA\", \"L5_TTTGGTTTCTTTGATC\", \"L5_TTTGTTGAGTGTACCT\", \"L5_TTTGTTGGTACGATCT\", \"L5_TTTGTTGGTCCTTAAG\", \"L5_TTTGTTGTCAACACCA\", \"L5_TTTGTTGTCATGCATG\", \"L5_TTTGTTGTCCGTGCGA\"])\n\nv = DataFrame(id=v_id, feature_type=v_feature_type, name=v_id, genome=\"hg19\", read=\"\", pattern=\"\", sequence=\"\")\no = DataFrame(id=o_id, sampleName=o_sampleName, barcode=o_barcode)\ndata = DataMatrix(X, v, o)","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"DataMatrix objects – annotated matrices where rows are variables and columns are observations – are central in SingleCellProjections.jl. A DataMatrix is also sometimes called an \"Assay\", in other software packages.","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"An overview of a DataMatrix is shown when the object is displayed:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Here we see the matrix size (number of variables and observations), a brief description of the matrix contents, and an overview of available variable and observation annotations. The underlined annotation names are the ID columns (see IDs below for more details).","category":"page"},{"location":"datamatrices/#Variables","page":"Data Matrices","title":"Variables","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Variables, or var for short, are typically genes, features (such as CITE-seq features) or variables after dimension reduction (e.g. \"UMAP1\"). The variables are stored as a DataFrame and can be accessed by:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.var","category":"page"},{"location":"datamatrices/#Observations","page":"Data Matrices","title":"Observations","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Observations, or obs for short, are typically cells, but can in theory be any kind of observation. The observations are stored as a DataFrame and can be accessed by:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.obs","category":"page"},{"location":"datamatrices/#IDs","page":"Data Matrices","title":"IDs","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Each variable and each observation must have a unique ID, that is, each row in the DataFrame should be unique if we consider the ID columns only. As seen above, the ID columns are underlined when displaying a DataMatrix. We can also access them directly:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.var_id_cols","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.obs_id_cols","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Most of the time, IDs are handled automatically by SingleCellProjections.jl. Sometimes, you need to make sure IDs are unique when loading or merging data matrices. In particular, when loading a DataMatrix that should be projected onto another DataMatrix, the user must ensure that relevant IDs are matching.","category":"page"},{"location":"datamatrices/#Matrix","page":"Data Matrices","title":"Matrix","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"The matrix can be accessed by data.matrix. Depending on the stage of analysis, different kinds of matrices (or matrix-like objects) are used. Most of this complexity is hidden from the user, but internally SingleCellProjections.jl depends on this functionality to be fast and to reduce memory usage.","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"warning: Read-only\nSingleCellProjections.jl will reuse matrices when possible, in order to reduce memory usage. E.g. normalize_matrix will reuse and extend the Matrix Expression of the source DataMatrix, without creating a copy of the actual data. When matrices are reused/copied is considered an implementation detail, and can change at any time. Users of SingleCellProjections.jl should thus consider the matrices to be \"read-only\". This should rarely present problems in practice.","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Roughly, the matrix types used at different stages are:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Counts - SparseMatrixCSC\nTransformed and normalized data - Matrix Expressions\nSVD (PCA) result - SVD\nForceLayout/UMAP/t-SNE result - Matrix{Float64}","category":"page"},{"location":"matrixexpressions/#Matrix-Expressions","page":"Matrix Expressions","title":"Matrix Expressions","text":"","category":"section"},{"location":"matrixexpressions/","page":"Matrix Expressions","title":"Matrix Expressions","text":"To be written.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SingleCellProjections","category":"page"},{"location":"#SingleCellProjections","page":"Home","title":"SingleCellProjections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SingleCellProjections.jl is an easy to use and powerful package for analysis of Single Cell Expression data in Julia. It is faster and uses less memory than existing solutions since the data is internally represented as expressions of sparse and low rank matrices, instead of storing huge dense matrices. In particular, it efficiently performs PCA (Principal Component Analysis), a natural starting point for downstream analysis, and supports both standard workflows and projections onto a base data set.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Source code: SingleCellProjections.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install SingleCellProjections.jl by running the following commands in Julia:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SingleCellProjections\")","category":"page"},{"location":"#Threading","page":"Home","title":"Threading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SingleCellProjections.jl relies heavily on threading. Please make sure to enable threading in Julia to dramatically improve computation speed.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Mimic the real dataset, without actually loading the data.\n# The plots are generated offline and uploaded separately.\n# We might consider actually running the tutorial code here - but then we would need to download files, load more packages and to more computations each time we rebuild the docs.\n\n\n# Useful function to extract a little data from a DataMatrix to use here for show\n# function f(col, n; h=10, t=10, filler=\"\")\n#   @assert h+t <= n\n#   pre = string(col[1:h])\n#   mid = string(\"fill(\\\"\", filler, \"\\\", \", n-h-t, \")\")\n#   post = string(col[end-t+1:end])\n#   string(\"vcat(\", pre, \", \", mid, \", \", post, ')')\n# end\n\n\nusing SingleCellProjections, SparseArrays, DataFrames, LinearAlgebra\nusing UMAP, TSne\n\nfunction load_counts(args...; sample_names, kwargs...) # Shadow SingleCellProjections.load_counts to fake loading!\n    P = 33766\n    N = \"P1\" in sample_names ? 35340 : 42553\n    # X = sparse(Int32[], Int32[], Int[], P, N)\n    # X = sparse(ones(Int32,N), Int32.(1:N), 1:N, P, N)\n\n    I = repeat(Int32[1,2]; inner=N)\n    J = vcat(Int32.(1:N), Int32.(1:N))\n    V = vcat(1:N, div.(N:-1:1,3))\n    X = sparse(I,J,V,P,N)\n\n    v_id = vcat([\"MIR1302-2HG\", \"FAM138A\", \"OR4F5\", \"AL627309.1\", \"AL627309.3\", \"AL627309.2\", \"AL627309.4\", \"AL732372.1\", \"OR4F29\", \"AC114498.1\"], string.(\"dummy_\", 1:33746), [\"CD169\", \"CD28\", \"CD161\", \"CD163\", \"CD138-1\", \"CD164\", \"CD138-2\", \"CD144\", \"CD202b\", \"CD11c\"])\n    v_feature_type = vcat(fill(\"Gene Expression\",33538), fill(\"Antibody Capture\", P-33538))\n\n    v_id[33497:33509] .= string.(\"MT-\", 1:13)\n\n    o_id = vcat([\"P1_L1_AAACCCAAGACATACA\", \"P1_L1_AAACCCACATCGGTTA\", \"P1_L1_AAACCCAGTGGAACAC\", \"P1_L1_AAACCCATCTGCGGAC\", \"P1_L1_AAACGAAAGTTACTCG\", \"P1_L1_AAACGAACAATGAGCG\", \"P1_L1_AAACGAACACTCCTTG\", \"P1_L1_AAACGAACAGCATCTA\", \"P1_L1_AAACGAATCCTCACCA\", \"P1_L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:N-20), [\"P2_L5_TTTGGTTGTCCGAAAG\", \"P2_L5_TTTGGTTTCCTCTAGC\", \"P2_L5_TTTGGTTTCGTAGGGA\", \"P2_L5_TTTGGTTTCTTTGATC\", \"P2_L5_TTTGTTGAGTGTACCT\", \"P2_L5_TTTGTTGGTACGATCT\", \"P2_L5_TTTGTTGGTCCTTAAG\", \"P2_L5_TTTGTTGTCAACACCA\", \"P2_L5_TTTGTTGTCATGCATG\", \"P2_L5_TTTGTTGTCCGTGCGA\"])\n    o_sampleName = vcat(fill(\"P1\",18135), fill(\"P2\", N-18135))\n    o_barcode = vcat([\"L1_AAACCCAAGACATACA\", \"L1_AAACCCACATCGGTTA\", \"L1_AAACCCAGTGGAACAC\", \"L1_AAACCCATCTGCGGAC\", \"L1_AAACGAAAGTTACTCG\", \"L1_AAACGAACAATGAGCG\", \"L1_AAACGAACACTCCTTG\", \"L1_AAACGAACAGCATCTA\", \"L1_AAACGAATCCTCACCA\", \"L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:N-20), [\"L5_TTTGGTTGTCCGAAAG\", \"L5_TTTGGTTTCCTCTAGC\", \"L5_TTTGGTTTCGTAGGGA\", \"L5_TTTGGTTTCTTTGATC\", \"L5_TTTGTTGAGTGTACCT\", \"L5_TTTGTTGGTACGATCT\", \"L5_TTTGTTGGTCCTTAAG\", \"L5_TTTGTTGTCAACACCA\", \"L5_TTTGTTGTCATGCATG\", \"L5_TTTGTTGTCCGTGCGA\"])\n\n    v = DataFrame(id=v_id, feature_type=v_feature_type, name=v_id, genome=\"hg19\", read=\"\", pattern=\"\", sequence=\"\")\n    o = DataFrame(id=o_id, sampleName=o_sampleName, barcode=o_barcode)\n    counts = DataMatrix(X, v, o)\nend\n\nfunction sctransform(counts)\n    # SingleCellProjections.sctransform(counts; use_cache=false, verbose=false)\n    m = SCTransformModel(counts; use_cache=false, verbose=false)\n    nvar = 20239\n    append!(m.params, m.params[mod1.(1:nvar-size(m.params,1),2),:])\n    m.params.id = counts.var.id[1:nvar]\n    project(counts, m; verbose=false)\nend\n\nsvd(args...; nsv, kwargs...) = LinearAlgebra.svd(args...; nsv, subspacedims=nsv, niter=1, kwargs...)\nforce_layout(args...; kwargs...) = SingleCellProjections.force_layout(reduced; niter=1, kwargs...)\n\numap(args...; kwargs...) = UMAP.umap(args...; n_epochs=1, init=:random, n_neighbors=2, kwargs...)\ntsne(data, d; kwargs...) = TSne.tsne(data, d, 0, 1, 5; verbose=false, progress=false, kwargs...) # We might want to speed this up further by running with fewer cells, takes about half of the total doc generation time","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For this example we will use PBMC (Peripheral Blood Mononuclear Cell) data from the paper Integrated analysis of multimodal single-cell data by Hao et al. You can find the original data here, in MatrixMarker (.mtx) format. For convenience, you can download the samples recompressed as .h5 files. Direct links:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Cell annotations (.csv.gz)\nDonor P1 (.h5)\nDonor P2 (.h5)\nDonor P3 (.h5)\nDonor P4 (.h5)\nDonor P5 (.h5)\nDonor P6 (.h5)\nDonor P7 (.h5)\nDonor P8 (.h5)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First we load SingleCellProjections and the packages DataFrames and CSV for handling annotations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SingleCellProjections, DataFrames, CSV","category":"page"},{"location":"tutorial/#Loading-Data","page":"Tutorial","title":"Loading Data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we load samples \"P1\" and \"P2\", by specifiying the paths to the files and naming them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"base_path = \"/path/to/downloads/\";\n\nsample_paths = joinpath.(base_path, [\"GSE164378_RNA_ADT_3P_P1.h5\", \"GSE164378_RNA_ADT_3P_P2.h5\"]);\n\ncounts = load_counts(sample_paths; sample_names=[\"P1\",\"P2\"])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Data sets in SingleCellProjections are represented as DataMatrix objects, which are matrices with annotations for var (variables/genes/features) and obs (observations, typically cells). Above, counts is a DataMatrix where the counts are stored in a sparse matrix. You can also see the available annotations for variables and observations. To access the different parts, use:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts.matrix - For the matrix\ncounts.var - Variable annotations (DataFrame)\ncounts.obs - Observation annotations (DataFrame)","category":"page"},{"location":"tutorial/#Cell-Annotations","page":"Tutorial","title":"Cell Annotations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we compute a new obs annotation where we count the fraction of reads coming from Mitochondrial genes for each cell:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"var_counts_fraction!(counts, \"name\"=>contains(r\"^MT-\"), \"feature_type\"=>isequal(\"Gene Expression\"), \"fraction_mt\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the new annotation fraction_mt is present in the output.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will also load some more cell annotations from the provided file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> cell_annotations = CSV.read(joinpath(base_path, \"GSE164378_RNA_ADT_3P.csv.gz\"), DataFrame);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\ncounts.obs.fraction_mt[1:10] = [194/5864,606/9333,176/3251,299/4198,343/5486,473/7379,196/4444,174/5693,160/4525,156/3519]\n\ncsv_str = \"\"\"barcode,nCount_ADT,nFeature_ADT,nCount_RNA,nFeature_RNA,orig.ident,lane,donor,time,celltype.l1,celltype.l2,celltype.l3,Phase,Batch\n          L1_AAACCCAAGAAACTCA,7535,217,10823,2915,SeuratProject,L1,P2,7,Mono,CD14 Mono,CD14 Mono,G1,Batch1\n          L1_AAACCCAAGACATACA,6013,209,5864,1617,SeuratProject,L1,P1,7,CD4 T,CD4 TCM,CD4 TCM_1,G1,Batch1\n          L1_AAACCCACAACTGGTT,6620,213,5067,1381,SeuratProject,L1,P4,2,CD8 T,CD8 Naive,CD8 Naive,S,Batch1\n          L1_AAACCCACACGTACTA,3567,202,4786,1890,SeuratProject,L1,P3,7,NK,NK,NK_2,G1,Batch1\n          L1_AAACCCACAGCATACT,6402,215,6505,1621,SeuratProject,L1,P4,7,CD8 T,CD8 Naive,CD8 Naive,G1,Batch1\n          L1_AAACCCACATCAGTCA,5297,212,4332,1633,SeuratProject,L1,P3,2,CD8 T,CD8 TEM,CD8 TEM_1,G1,Batch1\n          L1_AAACCCACATCGGTTA,7634,219,9333,2672,SeuratProject,L1,P1,7,Mono,CD16 Mono,CD16 Mono,G1,Batch1\n          L1_AAACCCACATGGATCT,8210,222,3589,1122,SeuratProject,L1,P4,2,B,B intermediate,B intermediate lambda,G1,Batch1\n          L1_AAACCCAGTGGAACAC,2847,201,3251,1375,SeuratProject,L1,P1,2,NK,NK,NK_2,G2M,Batch1\n          L1_AAACCCATCCACACCT,4557,209,3401,1200,SeuratProject,L1,P3,2,CD8 T,CD8 Naive,CD8 Naive,S,Batch1\n          L1_AAACCCATCTGCGGAC,5129,212,4198,1318,SeuratProject,L1,P1,0,CD4 T,CD4 TCM,CD4 TCM_1,S,Batch1\n          L1_AAACGAAAGTTACTCG,7630,208,5486,1390,SeuratProject,L1,P1,0,CD4 T,CD4 TCM,CD4 TCM_3,G1,Batch1\n          \"\"\"\ncell_annotations = CSV.read(codeunits(csv_str), DataFrame)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To merge, we use the DataFrames function leftjoin!, since it takes care of matching the cells in counts to the cells in cell_annotations based on the :barcode column.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"leftjoin!(counts.obs, cell_annotations; on=:barcode);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts.obs[34639+1:end,\"celltype.l1\"] .= \"other\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's look at some annotations for the first few cells:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts.obs[1:5,[\"id\",\"sampleName\",\"barcode\",\"fraction_mt\",\"celltype.l1\"]]","category":"page"},{"location":"tutorial/#Transformation","page":"Tutorial","title":"Transformation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The raw counts data is not suitable for analyses like PCA, since the data is far from normally distributed. A common strategy to handle this is to transform the data. Here we will use SCTransform (see also original sctransform implementation in R).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"transformed = sctransform(counts)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From the output, we see that the number of variables have been reduced, since the default sctransform options remove variables present in very few cells and only keeps variables with feature_type set to \"Gene Expression\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The matrix is now shown as A+B₁B₂B₃. This is normally not very important from the user's point of view, but it is critical for explaining how SingleCellProjections can be fast and not use too much memory. Instead of storing the SCTransformed matrix as a huge dense matrix, it is stored in memory as a MatrixExpression, in this case a sparse matrix A plus a product of three smaller matrices B₁,B₂ and B₃.","category":"page"},{"location":"tutorial/#Normalization","page":"Tutorial","title":"Normalization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After transformation we always want to normalize the data. At the very least, data should be centered for PCA to work properly, this can be achieved by just running normalize_matrix with the default parameters. Here, we also want to regress out \"fraction_mt\". You can add more obs annotations (categorical and/or numerical) to regress out if you need.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"normalized = normalize_matrix(transformed, \"fraction_mt\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the matrix is shown as A+B₁B₂B₃+(-β)X', i.e. another low-rank term was added to handle the normalization/regression. The first two terms are reused to make sure memory is not wasted.","category":"page"},{"location":"tutorial/#Filtering","page":"Tutorial","title":"Filtering","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is possible to filter variables and observations. Here we keep all cells that are not labeled as \"other\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"filtered = filter_obs(\"celltype.l1\"=>!isequal(\"other\"), normalized)","category":"page"},{"location":"tutorial/#Principal-Component-Analysis-(PCA)","page":"Tutorial","title":"Principal Component Analysis (PCA)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we are ready to perform Principal Component Analysis (PCA). This is computed by the Singular Value Decomposition (SVD), so we should call the svd function. The number of dimensions is specified using the nsv parameter.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"reduced = svd(filtered; nsv=20)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The matrix is now stored as an SVD object, which includes low dimensional representations of the observations and variables. To retrieve the low dimensional coordinates, use obs_coordinates and var_coordinates respectively.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Principal Component Analysis)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive PCA plot.","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<details>\n<summary>Expand this to show some example PlotlyJS plotting code.</summary>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can of course use your own favorite plotting library instead. Use obs_coordinates to get the coordinates for each cell, and data.obs to access cell annotations for coloring.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PlotlyJS\nfunction plot_categorical_3d(data, annotation; marker_size=3)\n    points = obs_coordinates(data)\n    traces = GenericTrace[]\n    for sub in groupby(data.obs, annotation; sort=true)\n        value = sub[1,annotation]\n        ind = parentindices(sub)[1]\n        push!(traces, scatter3d(;x=points[1,ind], y=points[2,ind], z=points[3,ind], mode=\"markers\", marker_size, name=value))\n    end\n    plot(traces, Layout(;legend=attr(itemsizing=\"constant\")))\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use it like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> plot_categorical_3d(reduced, \"celltype.l1\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"</details>\n<br>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For visualization purposes, it is often useful to further reduce the dimension after running PCA. (In contrast, analyses are generally run on the PCA/normalized/original data, since the methods below necessarily distort the data to force it down to 2 or 3 dimensions.)","category":"page"},{"location":"tutorial/#Force-Layout","page":"Tutorial","title":"Force Layout","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Force Layout plots (also known as SPRING Plots) are created like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fl = force_layout(reduced; ndim=3, k=100)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: force_layout)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive Force Layout plot.","category":"page"},{"location":"tutorial/#UMAP","page":"Tutorial","title":"UMAP","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SingleCellProjections can be used together with UMAP.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using UMAP\n\numapped = umap(reduced, 3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: umap)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive UMAP plot.","category":"page"},{"location":"tutorial/#t-SNE","page":"Tutorial","title":"t-SNE","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, t-SNE plots are supported using TSne.jl. In this example, we just run it one every 10ᵗʰ cell, because t-SNE doesn't scale very well with the number of cells:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TSne\n\nt = tsne(reduced[:,1:10:end], 3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: t-SNE)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive t-SNE plot.","category":"page"},{"location":"tutorial/#Other","page":"Tutorial","title":"Other","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is of course possible to use your own favorite dimension reduction method/package. The natural input for most cases are the coordinates after dimension reduction by PCA (obs_coordinates(reduced)).","category":"page"},{"location":"tutorial/#Projections","page":"Tutorial","title":"Projections","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SingleCellProjections is build to make it very easy to project one dataset onto another.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's load count data for two more samples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sample_paths_proj = joinpath.(base_path, [\"GSE164378_RNA_ADT_3P_P5.h5\", \"GSE164378_RNA_ADT_3P_P6.h5\"]);\n\ncounts_proj = load_counts(sample_paths_proj; sample_names=[\"P5\",\"P6\"]);\n\nleftjoin!(counts_proj.obs, cell_annotations; on=:barcode);\n\ncounts_proj","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts_proj.obs[41095+1:end,\"celltype.l1\"] .= \"other\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And project them onto the Force Layout we created above:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fl_proj = project(counts_proj, fl)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The result looks similar to the force layout plot above, since the donors \"P5\" and \"P6\" are similar to donors \"P1\" and \"P2\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: force_layout_projected)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive Force Layout projection plot.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Under the hood, SingleCellProjections recorded a ProjectionModel for every step of the analysis leading up to the Force Layout. Let's take a look:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fl.models","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When projecting, these models are applied one by one (C.f. output from project above), ensuring that the projected data is processed correctly. In most cases, projecting is not the same as running the same analysis independently, since information about the data set is recorded in the model.","category":"page"}]
}
