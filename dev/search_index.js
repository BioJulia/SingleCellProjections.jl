var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [SingleCellProjections]","category":"page"},{"location":"interface/#SingleCellProjections.DataMatrix","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"struct DataMatrix{T,Tv,To}\n\nA DataMatrix represents a matrix together with annotations for variables and observations.\n\nFields:\n\nmatrix::T - The matrix.\nvar::Tv - Variable annotations.\nobs::To - Observation annotations.\nvar_id_cols::Vector{String} - Which column(s) to use as IDs.\nobs_id_cols::Vector{String} - Which column(s) to use as IDs.\nmodels::Vector{ProjectionModel} - Models used in the creation of this DataMatrix.\n\nThe rows of the var and obs tables must be unique, considering only the var_id_cols/obs_id_cols.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"DataMatrix(matrix, var, obs; var_id_cols=nothing, obs_id_cols=nothing)\n\nCreate a DataMatrix with the given matrix, var and obs.\n\nColumns to use for var/obs IDs can be explicitly set with var_id_cols/obs_id_cols. Otherwise, an attempt will be made to autodetect the ID columns.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.DataMatrix-Tuple{}","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"DataMatrix()\n\nCreate an empty DataMatrix{Matrix{Float64},DataFrame,DataFrame}.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.LowRank","page":"Interface","title":"SingleCellProjections.LowRank","text":"LowRank\n\nA matrix decomposition UVᵀ where each row of U represents a variable and each column of Vᵀ represents a sample. Intended for situations where the product is low rank, i.e. size(U,2)==size(Vt,1) is small.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}","page":"Interface","title":"SingleCellProjections.NormalizationModel","text":"NormalizationModel(data::DataMatrix, design::DesignMatrix;\n                   scale=false, min_std=1e-6, annotate=true,\n                   rtol=sqrt(eps()), var=:copy, obs=:copy)\n\nCreate a NormalizationModel based on data and a design matrix.\n\nscale - Set to true to normalize variables to unit standard deviation. Can also be set to a vector with a scaling factor for each variable.\nmin_std - If scale==true, the scale vector is set to 1.0 ./ max.(std, min_std). That is, min_std is used to suppress variables that are very small (and any fluctuations can be assumed to be noise).\nannotate - Only used if scale!=false. With annotate=true, the scale vector is added as a var annotation.\nrtol - Singular values of the design matrix that are ≤rtol are discarded. Needed for numerical stability.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nSee also: normalize_matrix, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.SCTransformModel-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.SCTransformModel","text":"SCTransformModel(counts::DataMatrix;\n                 var_filter = hasproperty(counts.var, :feature_type) ? :feature_type => isequal(\"Gene Expression\") : nothing,\n                 rtol=1e-3, atol=0.0, annotate=true,\n                 post_var_filter=:, post_obs_filter=:,\n                 obs=:copy,\n                 kwargs...)\n\nComputes the SCTransform parameter estimates for counts and creates a SCTransformModel that can be applied to the same or another data set. Defaults to only using \"Gene Expression\" features.\n\nvar_filter - Control which variables (features) to use for parameter estimation. Defaults to :feature_type => isequal(\"Gene Expression\"), if a feature_type column is present in counts.var. Can be set to nothing to disable filtering. See DataFrames.filter for how to specify filters.\nrtol - Relative tolerance when constructing low rank approximation.\natol - Absolute tolerance when constructing low rank approximation.\nannotate - Set to true to include SCTransform parameter estimates as feature annotations.\npost_var_filter - Equivalent to applying variable (feature) filtering after sctransform, but computationally more efficient.\npost_obs_filter - Equivalent to applying observation (cell) filtering after sctransform, but computationally more efficient.\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\nkwargs... - Additional kwargs are passed on to SCTransform.scparams.\n\nExamples\n\nSetup SCTransformModel (Gene Expression features):\n\njulia> SCTransformModel(counts)\n\nSetup SCTransformModel (Antibody Capture features):\n\njulia> SCTransformModel(counts; var_filter = :feature_type => isequal(\"Antibody Capture\"))\n\nSee also: sctransform, SCTransform.scparams, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.SVDModel","page":"Interface","title":"SingleCellProjections.SVDModel","text":"SVDModel <: ProjectionModel\n\nA model used for projecting onto an SVD object. Normally created using svd(::DataMatrix).\n\nSee also: svd\n\n\n\n\n\n","category":"type"},{"location":"interface/#LinearAlgebra.svd-Tuple{DataMatrix}","page":"Interface","title":"LinearAlgebra.svd","text":"svd(data::DataMatrix; nsv=3, var=:copy, obs=:copy, kwargs...)\n\nCompute the Singular Value Decomposition (SVD) of data using the Random Subspace SVD algorithm from [Halko et al. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions\"]. SVD is often used to perform Principal Component Analysis (PCA), which assumes that the data is centered.\n\nnsv - The number of singular values.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nAdditional kwargs related to numerical precision are passed to SingleCellProjections.implicitsvd.\n\nSee also: SingleCellProjections.implicitsvd\n\n\n\n\n\n","category":"method"},{"location":"interface/#SCTransform.sctransform-Tuple{DataMatrix}","page":"Interface","title":"SCTransform.sctransform","text":"sctransform(counts::DataMatrix; verbose=true, kwargs...)\n\nCompute the SCTransform of the DataMatrix counts. The result is stored as a Matrix Expression with the sum of a sparse and a low-rank term. I.e. no large dense matrix is created.\n\nSee SCTransformModel for description of kwargs....\n\nExamples\n\nCompute SCTransform (Gene Expression features):\n\njulia> sctransform(counts)\n\nCompute SCTransform (Antibody Capture features):\n\njulia> sctransform(counts; var_filter = :feature_type => isequal(\"Antibody Capture\"))\n\nSee also: SCTransformModel, SCTransform.scparams\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.covariate","page":"Interface","title":"SingleCellProjections.covariate","text":"covariate(name::String, type=:auto)\n\nCreate a covariate referring to column name. type must be one of :auto, :numerical, :categorical and :intercept. :auto means auto-detection by checking if the values in the column are numerical or categorical. type==:intercept adds an intercept to the model (in which case the name parameter is ignored).\n\nSee also: designmatrix\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.designmatrix","text":"designmatrix(data::DataMatrix, [covariates...]; center=true, max_categories=100)\n\nCreates a design matrix from data.obs and the given covariates. Covariates can be specied using strings (column name in data.obs), with autodetection of whether the covariate is numerical or categorical, or using the covariate function for more control.\n\ncenter - If true, an intercept is added to the design matrix. (Should only be set to false in very rare circumstances.)\nmax_categories - Safety parameter, an error will be thrown if there are too many categories. In this case, it is likely a mistake that the covariate was used as a categorical covariate. Using a very large number of categories is also bad for performance and memory consumption.\n\nExamples\n\nCentering only:\n\njulia> designmatrix(data)\n\nRegression model with intercept (centering) and \"fraction_mt\" (numerical annotation):\n\njulia> designmatrix(data, \"fraction_mt\")\n\nAs above, but also including \"batch\" (categorical annotation):\n\njulia> designmatrix(data, \"fraction_mt\", \"batch\")\n\nSee also: normalize_matrix, NormalizationModel, covariate\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.differentialexpression-Tuple{DataMatrix{<:SparseArrays.SparseMatrixCSC}, AbstractVector}","page":"Interface","title":"SingleCellProjections.differentialexpression","text":"differentialexpression(data::DataMatrix{<:SparseMatrixCSC}, groups::AbstractVector)\n\nAssumes data is logtransformed. groups should be a vector with 1 for observations in group 1, 2 for observations in group 2 and missing for other observations.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_matrix","text":"filter_matrix(fvar, fobs, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the variables and observations passing the filters.\n\nfvar/fobs can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all variables/observations should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nAlso note that indexing of a DataMatrix supports AbstractVectors of indices/booleans and :, and is otherwise identical to filter_matrix.\n\nExamples\n\nKeep every 10th variable and 3rd observation:\n\njulia> filter_matrix(1:10:size(data,1), 1:3:size(data,2), data)\n\nOr, using indexing syntax:\n\njulia> data[1:10:end, 1:3:end]\n\nFor more examples, see filter_var and filter_obs.\n\nSee also: filter_var, filter_obs, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_obs","text":"filter_obs(f, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the observations passing the filter.\n\nf can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all observations should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nExamples\n\nKeep every 10th observation:\n\njulia> filter_obs(1:10:size(data,2), data)\n\nRemove observations where \"celltype\" equals \"other\":\n\njulia> filter_obs(\"celltype\"=>!isequal(\"other\"), data)\n\nSee also: filter_matrix, filter_var, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_var","text":"filter_var(f, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the variables passing the filter.\n\nf can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all variables should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nExamples\n\nKeep every 10th variable:\n\njulia> filter_var(1:10:size(data,1), data)\n\nKeep only variables of the type \"Gene Expression\":\n\njulia> filter_var(\"feature_type\"=>isequal(\"Gene Expression\"), data)\n\nSee also: filter_matrix, filter_obs, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.force_layout-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.force_layout","text":"force_layout(data::DataMatrix;\n             ndim=3,\n             k,\n             adj,\n             kprojection=10,\n             obs=:copy,\n             adj_out,\n             niter = 100,\n             link_distance = 4,\n             link_strength = 2,\n             charge = 5,\n             charge_min_distance = 1,\n             theta = 0.9,\n             center_strength = 0.05,\n             velocity_decay = 0.9,\n             initialAlpha = 1.0,\n             finalAlpha = 1e-3,\n             initialScale = 10,\n             rng)\n\nCompute the Force Layout (also known as a force directed knn-graph or SPRING plots) for data. Usually, data is a DataMatrix after reduction to 10-100 dimensions by svd.\n\nA Force Layout is computed by running a physics simulation were the observations are connected by springs (such that connected observations are attracted), a general \"charge\" force repelling all observations from each other and a centering force that keep the observations around the origin. The implementation is based on d3-force: https://github.com/d3/d3-force, also see LICENSE.md.\n\nExactly one of the kwargs k and adj must be provided. See details below.\n\nGeneral parameters:\n\nk - Number of nearest neighbors to connect each observation to (computes adj below).\nadj - An sparse, symmetric, adjacency matrix with booleans. true if two observations are connected by a spring and false otherwise.\nkprojection - The number of nearest neighbors used when projecting onto the resulting force layout. (Not used in the computation of the layout, only during projection.)\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\nadj_out - Optional Ref. If specified, the (computed) adj matrix will be assigned to adj_out.\n\nParamters controlling the physics simulation:\n\nniter - Number of iterations to run the simulation.\nlink_distance - The length of each spring.\nlink_strength - The strength of the spring force.\ncharge - The strength of the charge force.\ncharge_min_distance - Used to avoid numerical instabilities by limiting the charge force for observations that are very close.\ntheta - Parameter controlling accuracy in the Barnes-Hut approximation for charge forces.\ncenter_strength - Strength of the centering force.\nvelocity_decay - At each iteration, the current velocity for an observations is multiplied by velocity_decay.\ninitialAlpha - The alpha value decreases over time and allows larger changes to happen early, while being more stable towards the end.\nfinalAlpha - See initialAlpha\ninitialScale - The simulation is initialized by randomly drawing each observation from a multivariate Gaussian, and is scaled by initialScale.\nrng - Optional RNG object. Useful for reproducibility.\n\nExamples\n\njulia> force_layout(data; ndim=3, k=100)\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.implicitsvd-Tuple{Any}","page":"Interface","title":"SingleCellProjections.implicitsvd","text":"implicitsvd(A; nsv=3, subspacedims=4nsv, niter=2, stabilize_sign=true, rng)\n\nCompute the SVD of A using Random Subspace SVD. [Halko et al. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions\"]\n\nnsv - Number of singular values/vectors to compute\nsubspacedims - Number of dimensions used for the subspace approximating the action of A.\nniter - Number of iterations. In each iteration, one multiplication of A with a matrix and one multiplication of A' with a matrix will be performed.\nstabilize_sign - If true, handles the problem that the SVD is only unique up to the sign of each component (for real matrices), by ensuring that the l1 norm of the positive entires for each column in U is larger than the l1 norm of the negative entries.\nrng - Specify a custom RNG.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load10x-Tuple{Any}","page":"Interface","title":"SingleCellProjections.load10x","text":"load10x(filename; lazy=false, copy_obs_col=\"barcode\"=>\"id\", kwargs...)\n\nLoad a CellRanger \".h5\" or \".mtx[.gz]\" file as a DataMatrix.\n\nlazy - If true, the count matrix itself will not be loaded, only features and barcodes. This is used internally in load_counts to merge samples more efficiently. Use load_counts to later load the count data.\ncopy_obs_col - Set to nothing to disable. Defaults to a pair \"barcode\"=>\"id\", which copies the obs annotation barcode to a new column id.\nAdditional kwargs... are passed to the DataMatrix constructor.\n\nExamples\n\nLoad counts from a CellRanger \".h5\" file. (Recommended.)\n\njulia> counts = load10x(\"filtered_feature_bc_matrix.h5\")\n\nLoad counts from a CellRanger \".mtx\" file. Tries to find barcode and feature annotation files in the same folder.\n\njulia> counts = load10x(\"matrix.mtx.gz\")\n\nLazy loading followed by loading.\n\njulia> counts = load10x(\"filtered_feature_bc_matrix.h5\");\njulia> counts = load_counts(counts)\n\nSee also: load_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Tuple{Any, Any}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts([loadfun=load10x], filenames;\n            sample_names,\n            sample_name_col,\n            merged_obs_id_col = \"id\",\n            lazy,\n            lazy_merge = false,\n            var_id_cols=nothing,\n            merged_obs_id_delim = '_',\n            callback=nothing)\n\nLoad and merge multiple samples efficiently.\n\nDefaults to loading 10x CellRanger files. The files are first loaded lazily, then the merged count matrix is allocated and finally each sample is loaded directly into the merged count matrix. (This strategy greatly reduces memory usage, since only one copy of data is needed instead of two.)\n\nThe vector filenames specifies which files to load. For each file, loadfun is called.\n\nsample_names - Specify the sample names. Should be a vector of the same length as filenames. Set to nothing to not create a sample name annotation.\nsample_name_col - Column for sample names in obs, defaults to \"sampleName\".\nmerged_obs_id_col - Colum for merged ids in obs.\nlazy - Enable lazy loading. Defaults to true if load10x is used, and false otherwise.\nlazy_merge - Enable lazy merging, i.e. var and obs are created, but the count matrix merging is postponed until a second call to load_counts.\nvar_id_cols - Specify variable id columns. Defaults to nothing, i.e. autodetecting from the samples.\nmerged_obs_id_delim - Delimiter used when creating merged obs IDs.\ncallback - Experimental callback functionality. The callback function is called between samples during merging. Return true to abort loading and false to continue.\n\nExamples\n\nLoad and name samples:\n\njulia> counts = load_counts([\"s1.h5\", \"s2.h5\"]; sample_names=[\"Sample A\", \"Sample B\"])\n\nSee also: load10x, merge_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Tuple{DataMatrix{<:SingleCellProjections.Lazy10xMatrix}}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts(data::DataMatrix{<:Lazy10xMatrix})\n\nLoad counts for a lazily loaded 10x DataMatrix.\n\nSee also: load10x\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Union{Tuple{DataMatrix{<:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts(data::DataMatrix{<:LazyMergedMatrix})\n\nMerge/load counts for a lazily merged DataMatrix.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.loadh5ad-Tuple{Any}","page":"Interface","title":"SingleCellProjections.loadh5ad","text":"loadh5ad(filename; var_id_column=:id, obs_id_column=:id)\n\nExperimental loading of .h5ad files.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.logtransform-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.logtransform","text":"logtransform(counts::DataMatrix; scale_factor=10_000, var=:copy, obs=:copy)\n\nLog-transform counts using the formula:\n\n  log(1 + cᵢⱼ*scale_factor/(∑ᵢcᵢⱼ))\n\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nExamples\n\njulia> transformed = logtransform(counts)\n\nSee also: sctransform\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.merge_counts-Tuple{Any, Any}","page":"Interface","title":"SingleCellProjections.merge_counts","text":"merge_counts(samples, sample_names;\n             lazy=false,\n             var_id_cols=nothing,\n             sample_name_col = sample_names===nothing ? nothing : \"sampleName\",\n             merged_obs_id_col = \"id\",\n             merged_obs_id_delim = '_',\n             callback=nothing)\n\nMerge samples to create one large DataMatrix, by concatenating the obs. The union of the variables from the samples is used, and if a variable is not present in a sample, the count will be set to zero.\n\nThe obs IDs are created by concatenating the current obs ID columns, together with the sample_names (if provided).\n\nlazy - Lazy merging. Use load_counts to actually perform the merging.\nvar_id_cols - Set to nothing to autodetect from the samples.\nsample_name_col - Column in which the sample_names are stored.\nmerged_obs_id_col - obs ID column after merging. Set to nothing to keep current ID cols (will add sampleName as a separate ID column, if provided.)\nmerged_obs_id_delim - Delimiter used when merging obs IDs.\ncallback - Experimental callback functionality. The callback function is called between samples during merging. Return true to abort loading and false to continue.\n\nSee also: load_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}","page":"Interface","title":"SingleCellProjections.normalize_matrix","text":"normalize_matrix(data::DataMatrix, design::DesignMatrix; scale=false, kwargs...)\n\nNormalize data using the specified design matrix.\n\nSee also: NormalizationModel, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.normalize_matrix","text":"normalize_matrix(data::DataMatrix, [covariates...]; center=true, scale=false, kwargs...)\n\nNormalize data. By default, the matrix is centered. Any covariates specified (using column names of data.obs) will be regressed out.\n\ncenter - Set to true to center the data matrix.\nscale - Set to true to scale the variables in the data matrix to unit standard deviation.\n\nFor other kwargs and more detailed descriptions, see NormalizationModel and designmatrix.\n\nExamples\n\nCentering only:\n\njulia> normalize_matrix(data)\n\nRegression model with intercept (centering) and \"fraction_mt\" (numerical annotation):\n\njulia> normalize_matrix(data, \"fraction_mt\")\n\nAs above, but also including \"batch\" (categorical annotation):\n\njulia> normalize_matrix(data, \"fraction_mt\", \"batch\")\n\nSee also: NormalizationModel, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.obs_coordinates","page":"Interface","title":"SingleCellProjections.obs_coordinates","text":"obs_coordinates(data::DataMatrix)\n\nReturns a matrix with coordinates for the observations. Not available for all types of DataMatrices. Mostly useful for data matrices after dimension reduction such as svd or force_layout has been applied.\n\nIn the case of SVD (PCA), obs_coordinates returns the principal components, scaled by the singular values. This is a a good starting point for downstream analysis, since it is the optimal linear approximation of the original data for the given number of dimensions.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{<:ProjectionModel}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)\n\nConvenience function for projection onto multiple models. Essentially calls foldl and prints some @info messages (if verbose=true). In most cases, it is better to call project(data, base::DataMatrix) instead of using this method directly.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, base::DataMatrix, args...; from=nothing, kwargs...)\n\nProject data onto base, by applying ProjectionModels from base one by one.\n\nSince data already might have some models applied, project will try to figure out which models from base to use. See \"Examples\" below for concrete examples. Here's a more technical overview:\n\nConsider a base data matrix with four models:\n\nbase: A -> B -> C -> D\n\nGiven some new data (typically counts), we can project that onto base, given the result proj by applying all four models:\n\ndata:\nproj: A -> B -> C -> D\n\nIf data already has some models applied (e.g. we already projected onto A and B above), project will look for the last model in data (in this case B) in the list of models in base, and only apply models after that (in this case C and D).\n\ndata: A -> B\nproj: A -> B -> C -> D\n\nIt is also possible to use the from kwarg to specify exactly which models to apply. (The models in from must be a prefix of the models in base, or in other words, base was created by applying additional operations to from.)\n\ndata: X\nbase: A -> B -> C -> D\nfrom: A -> B\nproj: X -> C -> D\n\nNote that it is necessary to use the from kwarg if the last model in data does not occurr in base, because project cannot figure out on its own which models it makes sense to apply.\n\nExamples\n\nFirst, we construct a \"base\" by loading counts, SCTransforming, normalizing, computing the svd and finally computing a force layout:\n\njulia> fp = [\"GSE164378_RNA_ADT_3P_P1.h5\", \"GSE164378_RNA_ADT_3P_P2.h5\"];\njulia> counts = load_counts(fp; sample_names=[\"P1\",\"P2\"]);\njulia> transformed = sctransform(counts);\njulia> normalized = normalize_matrix(transformed);\njulia> reduced = svd(normalized; nsv=10);\njulia> fl = force_layout(reduced; ndim=3, k=100)\n  DataMatrix (3 variables and 35340 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nNote how the last line lists all ProjectionModels used in the creation of fl.\n\nNext, let's load some more samples for projection:\n\njulia> fp2 = [\"GSE164378_RNA_ADT_3P_P5.h5\", \"GSE164378_RNA_ADT_3P_P6.h5\"];\njulia> counts2 = load_counts(fp2; sample_names=[\"P5\",\"P6\"]);\n\nIt is easy to project the newly loaded counts2 onto the \"base\" force layout fl:\n\njulia> project(counts2, fl)\nDataMatrix (3 variables and 42553 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nWe can also project in two or more steps, to get access to intermediate results:\n\njulia> reduced2 = project(counts2, reduced)\nDataMatrix (20239 variables and 42553 observations)\n  SVD (10 dimensions)\n  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...\n  Observations: id, sampleName, barcode\n  Models: SVDModel(nsv=10), Normalization, SCTransform\n\njulia> project(reduced2, fl)\nDataMatrix (3 variables and 42553 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nIf the DataMatrix we want to project is modified, we need to use the from kwarg to tell project which models to use:\n\njulia> filtered = counts2[:,1:10:end]\nDataMatrix (33766 variables and 4256 observations)\n  SparseArrays.SparseMatrixCSC{Int64, Int32}\n  Variables: id, feature_type, name, genome, read, pattern, sequence\n  Observations: id, sampleName, barcode\n  Models: FilterModel(:, 1:10:42551)\n\njulia> reduced2b = project(filtered2, reduced; from=counts)\nDataMatrix (20239 variables and 4256 observations)\n  SVD (10 dimensions)\n  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...\n  Observations: id, sampleName, barcode\n  Models: SVDModel(nsv=10), Normalization, SCTransform, Filter\n\nAfter that, it is possible to continue without specifying from:\n\njulia> project(reduced2b, fl)\nDataMatrix (3 variables and 4256 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform, Filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)\n\nCore projection function. Project data based on the single ProjectionModel model. In most cases, it is better to call project(data, base::DataMatrix) instead of using this method directly.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T<:Real","page":"Interface","title":"SingleCellProjections.splitrange","text":"splitrange(r::UnitRange, nparts::Integer)\n\nSplits a range in nparts number of parts of equal length.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.tf_idf_transform-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.tf_idf_transform","text":"tf_idf_transform(counts::DataMatrix;\n                 scale_factor = 10_000,\n                 idf = vec(size(counts,2) ./ max.(1,sum(counts.matrix; dims=2))),\n                 annotate = true,\n                 var = :copy,\n                 obs = :copy)\n\nCompute the TF-IDF (term frequency-inverse document frequency) transform of counts, using the formula log( 1 + scale_factor * tf * idf ) where tf is the term frequency counts.matrix ./ max.(1, sum(counts.matrix; dims=1)).\n\nIf annotate is true, idf will be added as a var annotation.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.update_matrix","page":"Interface","title":"SingleCellProjections.update_matrix","text":"update_matrix(data::DataMatrix, matrix, model=nothing;\n              var::Union{Symbol,String,DataFrame} = \"\",\n              obs::Union{Symbol,String,DataFrame} = \"\",\n              var_id_cols,\n              obs_id_cols)\n\nCreate a new DataMatrix by replacing parts of data with new values. Mostly useful when implementing new ProjectionModels.\n\nmatrix - the new matrix.\nmodel - will be appended to the list of models from data. If set to nothing, the resulting list of models will be empty.\n\nKwargs:\n\nvar - One of:\n:copy - Copy from data.\n:keep - Share var with data.\n::DataFrame - Replace with a new table with variable annotations.\nprefix::String - Prefix, the new variables will be named prefix1, prefix2, etc.\nobs See var.\nvar_id_cols - New ID columns. Defaults to the same as data, or \"id\" if new variables were generated using the \"prefix\" above.\nobs_id_cols - See var_id_cols.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.var_coordinates","page":"Interface","title":"SingleCellProjections.var_coordinates","text":"var_coordinates(data::DataMatrix)\n\nReturns a matrix with coordinates for the variables. Only available for DataMatrices that have a dual representation (e.g. SVD/PCA).\n\nIn the case of SVD (PCA), var_coordinates returns the principal components as unit vectors.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{<:AbstractMatrix{<:Integer}}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.var_counts_fraction!","text":"var_counts_fraction!(counts::DataMatrix, sub_filter, tot_filter, col; check=true)\n\nFor each observation, compute the fraction of counts that match a specific variable pattern.\n\nsub_filter decides which variables are counted.\ntot_filter decides which variables to include in the total.\nIf check=true, an error will be thrown if no variables match the patterns.\n\nFor more information on filtering syntax, see examples below and the documentation on DataFrames.filter.\n\nExamples\n\nCompute the fraction of reads in MT- genes, considering only \"Gene Expression\" features (and not e.g. \"Antibody Capture\").\n\nvar_counts_fraction!(counts, \"name\"=>contains(r\"^MT-\"), \"feature_type\"=>isequal(\"Gene Expression\"), \"fraction_mt\")\n\nCompute the fraction of reads in MT- genes, when there is no feature_type annotation (i.e. all variables are genes).\n\nvar_counts_fraction!(counts, \"name\"=>contains(r\"^MT-\"), Returns(true), \"fraction_mt\")\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.variable_std-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.variable_std","text":"variable_std(data::DataMatrix)\n\nComputes the variance of each variable in data.\n\nnote: Note\ndata must be mean-centered. E.g. by using normalize_matrix before calling variable_std.\n\nSee also: variable_var, normalize_matrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.variable_var-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.variable_var","text":"variable_var(data::DataMatrix)\n\nComputes the variance of each variable in data.\n\nnote: Note\ndata must be mean-centered. E.g. by using normalize_matrix before calling variable_var.\n\nSee also: variable_std, normalize_matrix\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SingleCellProjections","category":"page"},{"location":"#SingleCellProjections","page":"Home","title":"SingleCellProjections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SingleCellProjections.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See README.md.","category":"page"}]
}
