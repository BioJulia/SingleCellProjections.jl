<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SingleCellProjections.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://rasmushenningsson.github.io/SingleCellProjections.jl/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SingleCellProjections.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Loading-Data"><span>Loading Data</span></a></li><li><a class="tocitem" href="#Cell-Annotations"><span>Cell Annotations</span></a></li><li><a class="tocitem" href="#Transformation"><span>Transformation</span></a></li><li><a class="tocitem" href="#Normalization"><span>Normalization</span></a></li><li><a class="tocitem" href="#Filtering"><span>Filtering</span></a></li><li><a class="tocitem" href="#Principal-Component-Analysis-(PCA)"><span>Principal Component Analysis (PCA)</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Projections"><span>Projections</span></a></li></ul></li><li><a class="tocitem" href="../datamatrices/">Data Matrices</a></li><li><a class="tocitem" href="../matrixexpressions/">Matrix Expressions</a></li><li><a class="tocitem" href="../interface/">Interface</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rasmushenningsson/SingleCellProjections.jl/blob/main/docs/src/tutorial.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>For this example we will use PBMC (Peripheral Blood Mononuclear Cell) data from the paper <a href="https://www.sciencedirect.com/science/article/pii/S0092867421005833">Integrated analysis of multimodal single-cell data</a> by Hao et al. You can find the original data <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164378">here</a>, in MatrixMarker (.mtx) format. For convenience, you can <a href="https://github.com/rasmushenningsson/SingleCellExampleData">download the samples recompressed as .h5 files</a>. Direct links:</p><ul><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P.csv.gz">Cell annotations (.csv.gz)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P1.h5">Donor P1 (.h5)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P2.h5">Donor P2 (.h5)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P3.h5">Donor P3 (.h5)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P4.h5">Donor P4 (.h5)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P5.h5">Donor P5 (.h5)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P6.h5">Donor P6 (.h5)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P7.h5">Donor P7 (.h5)</a></li><li><a href="https://github.com/rasmushenningsson/SingleCellExampleData/releases/download/GSE164378_RNA_ADT_3P/GSE164378_RNA_ADT_3P_P8.h5">Donor P8 (.h5)</a></li></ul><p>First we load <code>SingleCellProjections</code> and the packages <code>DataFrames</code> and <code>CSV</code> for handling annotations.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SingleCellProjections, DataFrames, CSV</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Loading-Data"><a class="docs-heading-anchor" href="#Loading-Data">Loading Data</a><a id="Loading-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-Data" title="Permalink"></a></h2><p>Then we load samples &quot;P1&quot; and &quot;P2&quot;, by specifiying the paths to the files and naming them.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; base_path = &quot;/path/to/downloads/&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sample_paths = joinpath.(base_path, [&quot;GSE164378_RNA_ADT_3P_P1.h5&quot;, &quot;GSE164378_RNA_ADT_3P_P2.h5&quot;]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; counts = load_counts(sample_paths; sample_names=[&quot;P1&quot;,&quot;P2&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (33766 variables and 35340 observations)
  SparseMatrixCSC{Int64, Int32}
  Variables: <span class="sgr4">id</span>, <span class="sgr4">feature_type</span>, name, genome, read, pattern, sequence
  Observations: <span class="sgr4">id</span>, sampleName, barcode</code></pre><p>Data sets in <code>SingleCellProjections</code> are represented as <code>DataMatrix</code> objects, which are matrices with annotations for <code>var</code> (variables/genes/features) and <code>obs</code> (observations, typically cells). Above, <code>counts</code> is a <code>DataMatrix</code> where the counts are stored in a sparse matrix. You can also see the available annotations for variables and observations. To access the different parts, use:</p><ul><li><code>counts.matrix</code> - For the matrix</li><li><code>counts.var</code> - Variable annotations (<code>DataFrame</code>)</li><li><code>counts.obs</code> - Observation annotations (<code>DataFrame</code>)</li></ul><h2 id="Cell-Annotations"><a class="docs-heading-anchor" href="#Cell-Annotations">Cell Annotations</a><a id="Cell-Annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Cell-Annotations" title="Permalink"></a></h2><p>Here we compute a new <code>obs</code> annotation where we count the fraction of reads coming from Mitochondrial genes for each cell:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; var_counts_fraction!(counts, &quot;name&quot;=&gt;contains(r&quot;^MT-&quot;), &quot;feature_type&quot;=&gt;isequal(&quot;Gene Expression&quot;), &quot;fraction_mt&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (33766 variables and 35340 observations)
  SparseMatrixCSC{Int64, Int32}
  Variables: <span class="sgr4">id</span>, <span class="sgr4">feature_type</span>, name, genome, read, pattern, sequence
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt
  Models: VarCountsFractionModel(subset_size=13, total_size=33538, col=&quot;fraction_mt&quot;)</code></pre><p>Note that the new annotation <code>fraction_mt</code> is present in the output.</p><p>We will also load some more cell annotations from the provided file.</p><pre><code class="language-julia-repl hljs">julia&gt; cell_annotations = CSV.read(joinpath(base_path, &quot;GSE164378_RNA_ADT_3P.csv.gz&quot;), DataFrame);</code></pre><p>To merge, we use the <code>DataFrames</code> function <code>leftjoin!</code>, since it takes care of matching the cells in <code>counts</code> to the cells in <code>cell_annotations</code> based on the <code>:barcode</code> column.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; leftjoin!(counts.obs, cell_annotations; on=:barcode);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Let&#39;s look at some annotations for the first few cells:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; counts.obs[1:5,[&quot;id&quot;,&quot;sampleName&quot;,&quot;barcode&quot;,&quot;fraction_mt&quot;,&quot;celltype.l1&quot;]]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">5×5 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> id                      sampleName  barcode              fraction_mt  celltype.l1 </span>
     │<span class="sgr90"> String                  String      String               Float64      String7     </span>
─────┼───────────────────────────────────────────────────────────────────────────────────
   1 │ P1_L1_AAACCCAAGACATACA  P1          L1_AAACCCAAGACATACA    0.0330832  CD4 T
   2 │ P1_L1_AAACCCACATCGGTTA  P1          L1_AAACCCACATCGGTTA    0.0649309  Mono
   3 │ P1_L1_AAACCCAGTGGAACAC  P1          L1_AAACCCAGTGGAACAC    0.0541372  NK
   4 │ P1_L1_AAACCCATCTGCGGAC  P1          L1_AAACCCATCTGCGGAC    0.0712244  CD4 T
   5 │ P1_L1_AAACGAAAGTTACTCG  P1          L1_AAACGAAAGTTACTCG    0.0625228  CD4 T</code></pre><h2 id="Transformation"><a class="docs-heading-anchor" href="#Transformation">Transformation</a><a id="Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation" title="Permalink"></a></h2><p>The raw counts data is not suitable for analyses like PCA, since the data is far from normally distributed. A common strategy to handle this is to transform the data. Here we will use <a href="https://github.com/rasmushenningsson/SCTransform.jl">SCTransform</a> (see also <a href="https://github.com/satijalab/sctransform">original sctransform implementation in R</a>).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; transformed = sctransform(counts)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (20239 variables and 35340 observations)
  A+B₁B₂B₃
  Variables: <span class="sgr4">id</span>, <span class="sgr4">feature_type</span>, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, ...
  Models: SCTransformModel(nvar=20239, clip=34.32), VarCountsFraction</code></pre><p>From the output, we see that the number of variables have been reduced, since the default <code>sctransform</code> options remove variables present in very few cells and only keeps variables with <code>feature_type</code> set to <code>&quot;Gene Expression&quot;</code>.</p><p>The matrix is now shown as <code>A+B₁B₂B₃</code>. This is normally not very important from the user&#39;s point of view, but it is critical for explaining how <code>SingleCellProjections</code> can be fast and not use too much memory. Instead of storing the SCTransformed matrix as a huge dense matrix, it is stored in memory as a <code>MatrixExpression</code>, in this case a sparse matrix <code>A</code> plus a product of three smaller matrices <code>B₁</code>,<code>B₂</code> and <code>B₃</code>.</p><h2 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h2><p>After transformation we always want to normalize the data. At the very least, data should be centered for PCA to work properly, this can be achieved by just running <code>normalize_matrix</code> with the default parameters. Here, we also want to regress out <code>&quot;fraction_mt&quot;</code>. You can add more <code>obs</code> annotations (categorical and/or numerical) to regress out if you need.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; normalized = normalize_matrix(transformed, &quot;fraction_mt&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (20239 variables and 35340 observations)
  A+B₁B₂B₃+(-β)X&#39;
  Variables: <span class="sgr4">id</span>, <span class="sgr4">feature_type</span>, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, ...
  Models: NormalizationModel(rank=2, ~1+num(fraction_mt)), SCTransform, VarCountsFraction</code></pre><p>Now the matrix is shown as <code>A+B₁B₂B₃+(-β)X&#39;</code>, i.e. another low-rank term was added to handle the normalization/regression. The first two terms are reused to make sure memory is not wasted.</p><h2 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h2><p>It is possible to filter variables and observations. Here we keep all cells that are not labeled as <code>&quot;other&quot;</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; filtered = filter_obs(&quot;celltype.l1&quot;=&gt;!isequal(&quot;other&quot;), normalized)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (20239 variables and 34639 observations)
  Aᵣ+B₁B₂B₃ᵣ+(-β)Xₗ&#39;
  Variables: <span class="sgr4">id</span>, <span class="sgr4">feature_type</span>, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, ...
  Models: FilterModel(:, &quot;celltype.l1&quot;=&gt;!Fix2{typeof(isequal), String}(isequal, &quot;other&quot;)), Normalization, SCTransform, VarCountsFraction</code></pre><h2 id="Principal-Component-Analysis-(PCA)"><a class="docs-heading-anchor" href="#Principal-Component-Analysis-(PCA)">Principal Component Analysis (PCA)</a><a id="Principal-Component-Analysis-(PCA)-1"></a><a class="docs-heading-anchor-permalink" href="#Principal-Component-Analysis-(PCA)" title="Permalink"></a></h2><p>Now we are ready to perform Principal Component Analysis (PCA). This is computed by the Singular Value Decomposition (SVD), so we should call the <code>svd</code> function. The number of dimensions is specified using the <code>nsv</code> parameter.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reduced = svd(filtered; nsv=20)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (20239 variables and 34639 observations)
  SVD (20 dimensions)
  Variables: <span class="sgr4">id</span>, <span class="sgr4">feature_type</span>, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, ...
  Models: SVDModel(nsv=20), Filter, Normalization, SCTransform, VarCountsFraction</code></pre><p>The matrix is now stored as an <code>SVD</code> object, which includes low dimensional representations of the observations and variables. To retrieve the low dimensional coordinates, use <code>obs_coordinates</code> and <code>var_coordinates</code> respectively.</p><p><img src="https://user-images.githubusercontent.com/16546530/228492439-7e31d4d1-1edd-493e-9e96-48fd2583b93d.svg" alt="Principal Component Analysis"/></p><p><a href="https://github.com/rasmushenningsson/SingleCellProjections.jl/files/11099039/svd.zip">Download interactive PCA plot</a>.</p><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><details>
<summary>Expand this to show some example PlotlyJS plotting code.</summary><p>You can of course use your own favorite plotting library instead. Use <code>obs_coordinates</code> to get the coordinates for each cell, and <code>data.obs</code> to access cell annotations for coloring.</p><pre><code class="language-julia hljs">using PlotlyJS
function plot_categorical_3d(data, annotation; marker_size=3)
    points = obs_coordinates(data)
    traces = GenericTrace[]
    for sub in groupby(data.obs, annotation; sort=true)
        value = sub[1,annotation]
        ind = parentindices(sub)[1]
        push!(traces, scatter3d(;x=points[1,ind], y=points[2,ind], z=points[3,ind], mode=&quot;markers&quot;, marker_size, name=value))
    end
    plot(traces, Layout(;legend=attr(itemsizing=&quot;constant&quot;)))
end</code></pre><p>Use it like this:</p><pre><code class="language-julia-repl hljs">julia&gt; plot_categorical_3d(reduced, &quot;celltype.l1&quot;)</code></pre></details>
<br><p>For visualization purposes, it is often useful to further reduce the dimension after running PCA. (In contrast, analyses are generally run on the PCA/normalized/original data, since the methods below necessarily distort the data to force it down to 2 or 3 dimensions.)</p><h3 id="Force-Layout"><a class="docs-heading-anchor" href="#Force-Layout">Force Layout</a><a id="Force-Layout-1"></a><a class="docs-heading-anchor-permalink" href="#Force-Layout" title="Permalink"></a></h3><p>Force Layout plots (also known as SPRING Plots) are created like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fl = force_layout(reduced; ndim=3, k=100)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (3 variables and 34639 observations)
  Matrix{Float64}
  Variables: <span class="sgr4">id</span>
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, ...
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Filter, Normalization, SCTransform, ...</code></pre><p><img src="https://user-images.githubusercontent.com/16546530/228492990-14c31888-28e1-4f3c-8062-f10682e55430.svg" alt="force_layout"/></p><p><a href="https://github.com/rasmushenningsson/SingleCellProjections.jl/files/11099049/force_layout.zip">Download interactive Force Layout plot</a>.</p><h3 id="UMAP"><a class="docs-heading-anchor" href="#UMAP">UMAP</a><a id="UMAP-1"></a><a class="docs-heading-anchor-permalink" href="#UMAP" title="Permalink"></a></h3><p><code>SingleCellProjections</code> can be used together with <a href="https://github.com/dillondaudert/UMAP.jl">UMAP.jl</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using UMAP</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; umapped = umap(reduced, 3)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (3 variables and 34639 observations)
  Matrix{Float64}
  Variables: <span class="sgr4">id</span>
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, ...
  Models: UMAPModel(n_components=3), SVD, Filter, Normalization, SCTransform, ...</code></pre><p><img src="https://user-images.githubusercontent.com/16546530/228493039-588cafde-86fc-4fae-ae58-fa65cf59e929.svg" alt="umap"/></p><p><a href="https://github.com/rasmushenningsson/SingleCellProjections.jl/files/11099051/umap.zip">Download interactive UMAP plot</a>.</p><h3 id="t-SNE"><a class="docs-heading-anchor" href="#t-SNE">t-SNE</a><a id="t-SNE-1"></a><a class="docs-heading-anchor-permalink" href="#t-SNE" title="Permalink"></a></h3><p>Similarly, t-SNE plots are supported using <a href="https://github.com/lejon/TSne.jl">TSne.jl</a>. In this example, we just run it one every 10ᵗʰ cell, because t-SNE doesn&#39;t scale very well with the number of cells:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TSne</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = tsne(reduced[:,1:10:end], 3)</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (3 variables and 3464 observations)
  Matrix{Float64}
  Variables: <span class="sgr4">id</span>
  Observations: <span class="sgr4">id</span>, sampleName, barcode, fraction_mt, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, ...
  Models: NearestNeighborModel(base=&quot;tsne&quot;, k=10), Filter, SVD, Filter, Normalization, ...</code></pre><p><img src="https://user-images.githubusercontent.com/16546530/228493090-06cc9f32-4e11-4441-a9b3-8da93d503a83.svg" alt="t-SNE"/></p><p><a href="https://github.com/rasmushenningsson/SingleCellProjections.jl/files/11099055/t-SNE.zip">Download interactive t-SNE plot</a>.</p><h3 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h3><p>It is of course possible to use your own favorite dimension reduction method/package. The natural input for most cases are the coordinates after dimension reduction by PCA (<code>obs_coordinates(reduced)</code>).</p><h2 id="Projections"><a class="docs-heading-anchor" href="#Projections">Projections</a><a id="Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Projections" title="Permalink"></a></h2><p><code>SingleCellProjections</code> is build to make it very easy to project one dataset onto another.</p><p>Let&#39;s load count data for two more samples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sample_paths_proj = joinpath.(base_path, [&quot;GSE164378_RNA_ADT_3P_P5.h5&quot;, &quot;GSE164378_RNA_ADT_3P_P6.h5&quot;]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; counts_proj = load_counts(sample_paths_proj; sample_names=[&quot;P5&quot;,&quot;P6&quot;]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; leftjoin!(counts_proj.obs, cell_annotations; on=:barcode);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; counts_proj</code><code class="nohighlight hljs ansi" style="display:block;">DataMatrix (33766 variables and 42553 observations)
  SparseMatrixCSC{Int64, Int32}
  Variables: <span class="sgr4">id</span>, <span class="sgr4">feature_type</span>, name, genome, read, pattern, sequence
  Observations: <span class="sgr4">id</span>, sampleName, barcode, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, donor, ...</code></pre><p>And project them onto the Force Layout we created above:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fl_proj = project(counts_proj, fl)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Projecting onto VarCountsFractionModel(subset_size=13, total_size=33538, col=&quot;fraction_mt&quot;)
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Projecting onto SCTransformModel(nvar=20239, clip=34.32)
<span class="sgr36"><span class="sgr1">[ Info: </span></span>- Removed 13527 variables that were not found in Model
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Projecting onto NormalizationModel(rank=2, ~1+num(fraction_mt))
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Projecting onto FilterModel(:, &quot;celltype.l1&quot;=&gt;!Fix2{typeof(isequal), String}(isequal, &quot;other&quot;))
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Projecting onto SVDModel(nsv=20)
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Projecting onto NearestNeighborModel(base=&quot;force_layout&quot;, k=10)
DataMatrix (3 variables and 41095 observations)
  Matrix{Float64}
  Variables: <span class="sgr4">id</span>
  Observations: <span class="sgr4">id</span>, sampleName, barcode, nCount_ADT, nFeature_ADT, nCount_RNA, nFeature_RNA, orig.ident, lane, donor, ...
  Models: NearestNeighborModel(base=&quot;force_layout&quot;, k=10), SVD, Filter, Normalization, SCTransform, ...</code></pre><p>The result looks similar to the force layout plot above, since the donors &quot;P5&quot; and &quot;P6&quot; are similar to donors &quot;P1&quot; and &quot;P2&quot;.</p><p><img src="https://user-images.githubusercontent.com/16546530/228493122-bfdee02b-e6fb-4219-88d1-31ab4e323ca9.svg" alt="force_layout_projected"/></p><p><a href="https://github.com/rasmushenningsson/SingleCellProjections.jl/files/11099059/force_layout_projected.zip">Download interactive Force Layout projection plot</a>.</p><p>Under the hood, <code>SingleCellProjections</code> recorded a <code>ProjectionModel</code> for every step of the analysis leading up to the Force Layout. Let&#39;s take a look:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fl.models</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{ProjectionModel}:
 VarCountsFractionModel(subset_size=13, total_size=33538, col=&quot;fraction_mt&quot;)
 SCTransformModel(nvar=20239, clip=34.32)
 NormalizationModel(rank=2, ~1+num(fraction_mt))
 FilterModel(:, &quot;celltype.l1&quot;=&gt;!Fix2{typeof(isequal), String}(isequal, &quot;other&quot;))
 SVDModel(nsv=20)
 NearestNeighborModel(base=&quot;force_layout&quot;, k=10)</code></pre><p>When projecting, these models are applied one by one (C.f. output from <code>project</code> above), ensuring that the projected data is processed correctly. In most cases, projecting is <strong>not</strong> the same as running the same analysis independently, since information about the data set is recorded in the model.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../datamatrices/">Data Matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 24 June 2023 01:40">Saturday 24 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
