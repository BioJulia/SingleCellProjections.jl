var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [SingleCellProjections]","category":"page"},{"location":"interface/#SingleCellProjections.DataMatrix","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"struct DataMatrix{T,Tv,To}\n\nA DataMatrix represents a matrix together with annotations for variables and observations.\n\nFields:\n\nmatrix::T - The matrix.\nvar::Tv - Variable annotations.\nobs::To - Observation annotations.\nmodels::Vector{ProjectionModel} - Models used in the creation of this DataMatrix.\n\nThe first column of the var and obs tables should contain unique IDs.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SingleCellProjections.DataMatrix-Tuple{Any, Any, Any}","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"DataMatrix(matrix, var, obs; kwargs...)\n\nCreate a DataMatrix with the given matrix, var and obs.\n\nThe first column of var/obs are used as IDs.\n\nKwargs:\n\nduplicate_var - Set to :ignore, :warn or :error to decide what happens if duplicate var IDs are found.\nduplicate_obs - Set to :ignore, :warn or :error to decide what happens if duplicate obs IDs are found.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.DataMatrix-Tuple{}","page":"Interface","title":"SingleCellProjections.DataMatrix","text":"DataMatrix()\n\nCreate an empty DataMatrix{Matrix{Float64},DataFrame,DataFrame}.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.LowRank","page":"Interface","title":"SingleCellProjections.LowRank","text":"LowRank\n\nA matrix decomposition UVᵀ where each row of U represents a variable and each column of Vᵀ represents a sample. Intended for situations where the product is low rank, i.e. size(U,2)==size(Vt,1) is small.\n\n\n\n\n\n","category":"type"},{"location":"interface/#SingleCellProjections.NormalizationModel-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}","page":"Interface","title":"SingleCellProjections.NormalizationModel","text":"NormalizationModel(data::DataMatrix, design::DesignMatrix;\n                   scale=false, min_std=1e-6, annotate=true,\n                   rtol=sqrt(eps()), var=:copy, obs=:copy)\n\nCreate a NormalizationModel based on data and a design matrix.\n\nscale - Set to true to normalize variables to unit standard deviation. Can also be set to a vector with a scaling factor for each variable.\nmin_std - If scale==true, the scale vector is set to 1.0 ./ max.(std, min_std). That is, min_std is used to suppress variables that are very small (and any fluctuations can be assumed to be noise).\nannotate - Only used if scale!=false. With annotate=true, the scale vector is added as a var annotation.\nrtol - Singular values of the design matrix that are ≤rtol are discarded. Needed for numerical stability.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nSee also: normalize_matrix, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.PseudoBulkModel","page":"Interface","title":"SingleCellProjections.PseudoBulkModel","text":"PseudoBulkModel <: ProjectionModel\n\nA model used for computing a \"pseudo-bulk\" representation of a DataMatrix.\n\nSee also: pseudobulk\n\n\n\n\n\n","category":"type"},{"location":"interface/#SingleCellProjections.SCTransformModel-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SingleCellProjections.SCTransformModel","text":"SCTransformModel([T=Float64], counts::DataMatrix;\n                 var_filter = hasproperty(counts.var, :feature_type) ? :feature_type => isequal(\"Gene Expression\") : nothing,\n                 rtol=1e-3, atol=0.0, annotate=true,\n                 post_var_filter=:, post_obs_filter=:,\n                 obs=:copy,\n                 kwargs...)\n\nComputes the SCTransform parameter estimates for counts and creates a SCTransformModel that can be applied to the same or another data set. Defaults to only using \"Gene Expression\" features.\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nvar_filter - Control which variables (features) to use for parameter estimation. Defaults to \"feature_type\" => isequal(\"Gene Expression\"), if a feature_type column is present in counts.var. Can be set to nothing to disable filtering. See DataFrames.filter for how to specify filters.\nvar_filter_cols - Additional columns used to ensure features are unique. Defaults to \"feature_type\" if present in counts.var. Use a Tuple/Vector for specifying multiple columns. Can be set to nothing to not include any additional columns.\nrtol - Relative tolerance when constructing low rank approximation.\natol - Absolute tolerance when constructing low rank approximation.\nannotate - Set to true to include SCTransform parameter estimates as feature annotations.\npost_var_filter - Equivalent to applying variable (feature) filtering after sctransform, but computationally more efficient.\npost_obs_filter - Equivalent to applying observation (cell) filtering after sctransform, but computationally more efficient.\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\nkwargs... - Additional kwargs are passed on to SCTransform.scparams.\n\nExamples\n\nSetup SCTransformModel (Gene Expression features):\n\njulia> SCTransformModel(counts)\n\nSetup SCTransformModel (Antibody Capture features):\n\njulia> SCTransformModel(counts; var_filter = :feature_type => isequal(\"Antibody Capture\"))\n\nSee also: sctransform, SCTransform.scparams, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.SVDModel","page":"Interface","title":"SingleCellProjections.SVDModel","text":"SVDModel <: ProjectionModel\n\nA model used for projecting onto an SVD object. Normally created using svd(::DataMatrix).\n\nSee also: svd\n\n\n\n\n\n","category":"type"},{"location":"interface/#Base.copy-Tuple{DataMatrix}","page":"Interface","title":"Base.copy","text":"copy(data::DataMatrix; var=:copy, obs=:copy, matrix=:keep)\n\nCopy DataMatrix data. By default, var and obs annotations are copied, but the matrix is shared. Set kwargs var, obs and matrix to :keep/:copy for fine grained control.\n\n\n\n\n\n","category":"method"},{"location":"interface/#LinearAlgebra.svd-Tuple{DataMatrix}","page":"Interface","title":"LinearAlgebra.svd","text":"svd(data::DataMatrix; nsv=3, var=:copy, obs=:copy, kwargs...)\n\nCompute the Singular Value Decomposition (SVD) of data using the Random Subspace SVD algorithm from [Halko et al. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions\"]. SVD is often used to perform Principal Component Analysis (PCA), which assumes that the data is centered.\n\nnsv - The number of singular values.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nAdditional kwargs related to numerical precision are passed to SingleCellProjections.implicitsvd.\n\nSee also: SingleCellProjections.implicitsvd\n\n\n\n\n\n","category":"method"},{"location":"interface/#SCTransform.sctransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SCTransform.sctransform","text":"sctransform([T=Float64], counts::DataMatrix; verbose=true, kwargs...)\n\nCompute the SCTransform of the DataMatrix counts. The result is stored as a Matrix Expression with the sum of a sparse and a low-rank term. I.e. no large dense matrix is created.\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nSee SCTransformModel for description of kwargs....\n\nExamples\n\nCompute SCTransform (Gene Expression features):\n\njulia> sctransform(counts)\n\nCompute SCTransform (Antibody Capture features):\n\njulia> sctransform(counts; var_filter = :feature_type => isequal(\"Antibody Capture\"))\n\nCompute SCTransform (Gene Expression features), using eltype Float32 to lower memory usage:\n\njulia> sctransform(Float32, counts)\n\nSee also: SCTransformModel, SCTransform.scparams\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.adjacency_distances","page":"Interface","title":"SingleCellProjections.adjacency_distances","text":"adjacency_distances(adj, X, Y=X)\n\nFor each structural non-zero in adj, compute the Euclidean distance between the point in the DataMatrix Y and the point in the DataMatrix X.\n\nCan be useful when adj is created using e.g. a lower dimensional representation and we want to know the distances in the original, high dimensional space.\n\nAt the moment all points in Y are required to have the same number of neighbors in X, for computation reasons.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.covariate","page":"Interface","title":"SingleCellProjections.covariate","text":"covariate(src, group_a, [group_b])\n\nCreate a two-group covariate referring to src, comparing group_a to group_b.\n\nsrc is one of:\n\nString - referring to a column in the DataMatrix obs.\nDataFrame - with exactly two columns, the first should contain IDs matching IDs in obs, and the second should be the covariate.\nAnnotations (experimental) - with ID matching the DataMatrix obs and a second column for the covariate.\n\nIf src is a String it will refer to a column in the DataMatrix obs. src can also be an Annotations object, with ID matching the DataMatrix obs. group_a and group_b must be values occuring in the column src.\n\nIf group_b is not given, group_a will be compared to all other observations.\n\nSee also: designmatrix\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.covariate-2","page":"Interface","title":"SingleCellProjections.covariate","text":"covariate(src, type=:auto)\n\nCreate a covariate referring to src.\n\nsrc is one of:\n\nString - referring to a column in the DataMatrix obs.\nDataFrame - with exactly two columns, the first should contain IDs matching IDs in obs, and the second should be the covariate.\nAnnotations (experimental) - with ID matching the DataMatrix obs and a second column for the covariate.\n\ntype must be one of :auto, :numerical, :categorical, :twogroup and :intercept. :auto means auto-detection by checking if the values in the column are numerical or categorical. type==:intercept adds an intercept to the model (in which case the src parameter is ignored).\n\nSee also: designmatrix\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.designmatrix-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.designmatrix","text":"designmatrix(data::DataMatrix, [covariates...]; center=true, max_categories=100)\n\nCreates a design matrix from data.obs and the given covariates. Covariates can be specied using strings (column name in data.obs), with autodetection of whether the covariate is numerical or categorical, or using the covariate function for more control.\n\ncenter - If true, an intercept is added to the design matrix. (Should only be set to false in very rare circumstances.)\nmax_categories - Safety parameter, an error will be thrown if there are too many categories. In this case, it is likely a mistake that the covariate was used as a categorical covariate. Using a very large number of categories is also bad for performance and memory consumption.\n\nExamples\n\nCentering only:\n\njulia> designmatrix(data)\n\nRegression model with intercept (centering) and \"fraction_mt\" (numerical annotation):\n\njulia> designmatrix(data, \"fraction_mt\")\n\nAs above, but also including \"batch\" (categorical annotation):\n\njulia> designmatrix(data, \"fraction_mt\", \"batch\")\n\nSee also: normalize_matrix, NormalizationModel, covariate\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_matrix-Tuple{Any, Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_matrix","text":"filter_matrix(fvar, fobs, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the variables and observations passing the filters.\n\nfvar/fobs can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all variables/observations should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nAlso note that indexing of a DataMatrix supports AbstractVectors of indices/booleans and :, and is otherwise identical to filter_matrix.\n\nExamples\n\nKeep every 10th variable and 3rd observation:\n\njulia> filter_matrix(1:10:size(data,1), 1:3:size(data,2), data)\n\nOr, using indexing syntax:\n\njulia> data[1:10:end, 1:3:end]\n\nFor more examples, see filter_var and filter_obs.\n\nSee also: filter_var, filter_obs, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_obs-Tuple{Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_obs","text":"filter_obs(f, data::DataMatrix)\n\nReturn a new DataMatrix, containing only the observations passing the filter.\n\nf can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all observations should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nExamples\n\nKeep every 10th observation:\n\njulia> filter_obs(1:10:size(data,2), data)\n\nRemove observations where \"celltype\" equals \"other\":\n\njulia> filter_obs(\"celltype\"=>!isequal(\"other\"), data)\n\nSee also: filter_matrix, filter_var, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.filter_var-Tuple{Any, DataMatrix}","page":"Interface","title":"SingleCellProjections.filter_var","text":"filter_var(f, data::DataMatrix; kwargs...)\n\nReturn a new DataMatrix, containing only the variables passing the filter.\n\nf can be:\n\nAn AbstractVector of indices to keep.\nA AbstractVector of booleans (true to keep, false to discard).\n: indicating that all variables should be kept.\nAnything you can pass on to DataFrames.filter (see DataFrames documentation for details).\n\nExamples\n\nKeep every 10th variable:\n\njulia> filter_var(1:10:size(data,1), data)\n\nKeep only variables of the type \"Gene Expression\":\n\njulia> filter_var(\"feature_type\"=>isequal(\"Gene Expression\"), data)\n\nSee also: filter_matrix, filter_obs, DataFrames.filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.force_layout-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.force_layout","text":"force_layout(data::DataMatrix;\n             ndim=3,\n             k,\n             adj,\n             kprojection=10,\n             obs=:copy,\n             adj_out,\n             niter = 100,\n             link_distance = 4,\n             link_strength = 2,\n             charge = 5,\n             charge_min_distance = 1,\n             theta = 0.9,\n             center_strength = 0.05,\n             velocity_decay = 0.9,\n             initialAlpha = 1.0,\n             finalAlpha = 1e-3,\n             initialScale = 10,\n             seed,\n             rng)\n\nCompute the Force Layout (also known as a force directed knn-graph or SPRING plots) for data. Usually, data is a DataMatrix after reduction to 10-100 dimensions by svd.\n\nA Force Layout is computed by running a physics simulation were the observations are connected by springs (such that connected observations are attracted), a general \"charge\" force repelling all observations from each other and a centering force that keep the observations around the origin. The implementation is based on d3-force: https://github.com/d3/d3-force, also see LICENSE.md.\n\nExactly one of the kwargs k and adj must be provided. See details below.\n\nGeneral parameters:\n\nk - Number of nearest neighbors to connect each observation to (computes adj below).\nadj - An sparse, symmetric, adjacency matrix with booleans. true if two observations are connected by a spring and false otherwise.\nkprojection - The number of nearest neighbors used when projecting onto the resulting force layout. (Not used in the computation of the layout, only during projection.)\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\nadj_out - Optional Ref. If specified, the (computed) adj matrix will be assigned to adj_out.\n\nParamters controlling the physics simulation:\n\nniter - Number of iterations to run the simulation.\nlink_distance - The length of each spring.\nlink_strength - The strength of the spring force.\ncharge - The strength of the charge force.\ncharge_min_distance - Used to avoid numerical instabilities by limiting the charge force for observations that are very close.\ntheta - Parameter controlling accuracy in the Barnes-Hut approximation for charge forces.\ncenter_strength - Strength of the centering force.\nvelocity_decay - At each iteration, the current velocity for an observations is multiplied by velocity_decay.\ninitialAlpha - The alpha value decreases over time and allows larger changes to happen early, while being more stable towards the end.\nfinalAlpha - See initialAlpha\ninitialScale - The simulation is initialized by randomly drawing each observation from a multivariate Gaussian, and is scaled by initialScale.\nseed - Optional random seed used to init rng. NB: This requires the package StableRNGs to be loaded.\nrng - Optional RNG object. Useful for reproducibility.\n\nExamples\n\njulia> force_layout(data; ndim=3, k=100)\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ftest!-Tuple{DataMatrix, Any}","page":"Interface","title":"SingleCellProjections.ftest!","text":"ftest!(data::DataMatrix, h1; h0, kwargs...)\n\nPerforms an F-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used.\n\nftest! adds a F-statistic and a p-value column to data.var.\n\nSee ftest_table for usage examples and more details on computations and parameters.\n\nIn addition ftest! supports the kwarg:\n\nprefix - Output column names for F-statistics and p-values will be prefixed with this string. If none is given, it will be constructed from h1 and h0.\n\nSee also: ftest_table, ftest, ttest!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ftest-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ftest","text":"ftest(data::DataMatrix, h1; h0, var=:copy, obs=:copy, matrix=:keep, kwargs...)\n\nPerforms an F-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used.\n\nftest creates a copy of data and adds a F-statistic and a p-value column to data.var.\n\nSee ftest_table and ftest! for usage examples and more details on computations and parameters.\n\nSee also: ftest!, ftest_table, ttest\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ftest_table-Tuple{DataMatrix, Any}","page":"Interface","title":"SingleCellProjections.ftest_table","text":"ftest_table(data::DataMatrix, h1; h0, kwargs...)\n\nPerforms an F-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of F-Tests are ANOVA and Quadratic Regression, but any linear model can be used. (See \"Examples\" below for concrete examples.)\n\nF-tests can be performed on any DataMatrix, but it is almost always recommended to do it directly after transforming the data using e.g. sctransform, logtransform or tf_idf_transform.\n\nnote: Normalization\nDo not use ftest_table after normalizing the data using normalize_matrix: ftest_table needs to know about the h0 model (regressed out covariates) for correction computations. Failing to do so can result in incorrect results. If you want to correct for the same covariates, pass them as h0 to ftest_table.\n\nh1 can be:\n\nA string specifying a column name of data.obs. Auto-detection determines if the column is categorical (ANOVA) or numerical.\nA covariate for more control of how to interpret the values in a column.\nA tuple or vector of the above for compound models.\n\nftest_table returns a Dataframe with columns for variable IDs, F-statistics and p-values.\n\nSupported kwargs are:\n\nh0                  - Use a non-trivial h0 (null) model. Specified in the same way as h1 above.\ncenter=true         - Add an intercept to the h0 (null) model.\nstatistic_col=\"F\"   - Name of the output column containing the F-statistics. (Set to nothing to remove from output.)\npvalue_col=\"pValue\" - Name of the output column containing the p-values. (Set to nothing to remove from output.)\nh1_missing=:skip    - One of :skip and :error. If skip, missing values in h1 columns are skipped, otherwise an error is thrown.\nh0_missing=:error   - One of :skip and :error. If skip, missing values in h0 columns are skipped, otherwise an error is thrown.\nallow_normalized_matrix=false - Set to true to accept running on a DataMatrix that has been normalized.\n\nExamples\n\nPerform an ANOVA using the \"celltype\" annotation.\n\njulia> ftest_table(transformed, \"celltype\")\n\nPerform an ANOVA using the \"celltype\" annotation, while correcting for fraction_mt (a linear covariate).\n\njulia> ftest_table(transformed, \"celltype\"; h0=\"fraction_mt\")\n\nPerform an ANOVA using the \"celltype\" annotation, while correcting for fraction_mt (a linear covariate) and \"phase\" (a categorical covariate).\n\njulia> ftest_table(transformed, \"celltype\"; h0=(\"fraction_mt\",\"phase\"))\n\nPerform Quadractic Regression using the covariate x, by first creating an annotation for x squared, and then using a compound model.\n\njulia> data.obs.x2 = data.obs.x.^2;\n\njulia> ftest_table(transformed, (\"x\",\"x2\"))\n\nSee also: ftest!, ftest, ttest_table, covariate\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.implicitsvd-Tuple{Any}","page":"Interface","title":"SingleCellProjections.implicitsvd","text":"implicitsvd(A; nsv=3, subspacedims=4nsv, niter=2, stabilize_sign=true, seed, rng)\n\nCompute the SVD of A using Random Subspace SVD. [Halko et al. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions\"]\n\nnsv - Number of singular values/vectors to compute\nsubspacedims - Number of dimensions used for the subspace approximating the action of A.\nniter - Number of iterations. In each iteration, one multiplication of A with a matrix and one multiplication of A' with a matrix will be performed.\nstabilize_sign - If true, handles the problem that the SVD is only unique up to the sign of each component (for real matrices), by ensuring that the l1 norm of the positive entires for each column in U is larger than the l1 norm of the negative entries.\nseed - Use a random seed to init the rng. NB: This requires the package StableRNGs to be loaded.\nrng - Specify a custom RNG.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load10x-Tuple{Any}","page":"Interface","title":"SingleCellProjections.load10x","text":"load10x(filename; lazy=false, var_id=nothing, var_id_delim='_')\n\nLoad a CellRanger \".h5\" or \".mtx[.gz]\" file as a DataMatrix.\n\nlazy - If true, the count matrix itself will not be loaded, only features and barcodes. This is used internally in load_counts to merge samples more efficiently. Use load_counts to later load the count data.\nvar_id - If a pair var_id_col=>cols, the contents of columns cols will be merged to create new IDs. Useful to ensure that IDs are unique.\nvar_id_delim - Delimiter used to when merging variable columns to create the variable id column.\n\nExamples\n\nLoad counts from a CellRanger \".h5\" file. (Recommended.)\n\njulia> counts = load10x(\"filtered_feature_bc_matrix.h5\")\n\nLoad counts from a CellRanger \".mtx\" file. Tries to find barcode and feature annotation files in the same folder.\n\njulia> counts = load10x(\"matrix.mtx.gz\")\n\nLazy loading followed by loading.\n\njulia> counts = load10x(\"filtered_feature_bc_matrix.h5\");\njulia> counts = load_counts(counts)\n\nSee also: load_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Tuple{Any, Any}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts([loadfun=load10x], filenames;\n            sample_names,\n            sample_name_col,\n            obs_id_col = \"cell_id\",\n            lazy,\n            lazy_merge = false,\n            obs_id_delim = '_',\n            obs_id_prefixes = sample_names,\n            extra_var_id_cols::Union{Nothing,String,Vector{String}},\n            duplicate_var,\n            duplicate_obs,\n            callback=nothing)\n\nLoad and merge multiple samples efficiently.\n\nDefaults to loading 10x CellRanger files. The files are first loaded lazily, then the merged count matrix is allocated and finally each sample is loaded directly into the merged count matrix. (This strategy greatly reduces memory usage, since only one copy of data is needed instead of two.)\n\nfilenames specifies which files to load. (It can be a vector of filenames or a single filename string.) For each file, loadfun is called.\n\nsample_names - Specify the sample names. Should be a vector of the same length as filenames. Set to nothing to not create a sample name annotation.\nsample_name_col - Column for sample names in obs, defaults to \"sampleName\".\nobs_id_col - Colum for merged ids in obs.\nlazy - Enable lazy loading. Defaults to true if load10x is used, and false otherwise.\nlazy_merge - Enable lazy merging, i.e. var and obs are created, but the count matrix merging is postponed until a second call to load_counts.\nobs_id_delim - Delimiter used when creating merged obs IDs.\nobs_id_prefixes - Prefix (one per sample) used to create new IDs. Set to nothing to keep old IDs. Defaults to sample_names.\nextra_var_id_cols - Additional columns to use to ensure variable IDs are unique during merging. Defaults to \"feature_type\" if that column is present for all samples. Can be a Vector{String} to include multiple columns. Set to nothing to disable.\nduplicate_var - Set to :ignore, :warn or :error to decide what happens if duplicate var IDs are found.\nduplicate_obs - Set to :ignore, :warn or :error to decide what happens if duplicate obs IDs are found.\ncallback - Experimental callback functionality. The callback function is called between samples during merging. Return true to abort loading and false to continue.\nAdditional kwargs (including duplicate_var/duplicate_obs if specified) are passed to loadfun.\n\nExamples\n\nLoad and name samples:\n\njulia> counts = load_counts([\"s1.h5\", \"s2.h5\"]; sample_names=[\"Sample A\", \"Sample B\"])\n\nSee also: load10x, merge_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Tuple{DataMatrix{<:SingleCellProjections.Lazy10xMatrix}}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts(data::DataMatrix{<:Lazy10xMatrix})\n\nLoad counts for a lazily loaded 10x DataMatrix.\n\nSee also: load10x\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.load_counts-Union{Tuple{DataMatrix{<:SingleCellProjections.LazyMergedMatrix{Tv, Ti}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Interface","title":"SingleCellProjections.load_counts","text":"load_counts(data::DataMatrix{<:LazyMergedMatrix})\n\nMerge/load counts for a lazily merged DataMatrix.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.loadh5ad-Tuple{Any}","page":"Interface","title":"SingleCellProjections.loadh5ad","text":"loadh5ad(filename; var_id_column=:id, obs_id_column=:id)\n\nExperimental loading of .h5ad files.\n\nnote: Note\nThis function is deprecated. Load Muon.jl and see help for create_datamatrix.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.local_outlier_factor!-Tuple{DataMatrix, DataMatrix}","page":"Interface","title":"SingleCellProjections.local_outlier_factor!","text":"local_outlier_factor!(data::DataMatrix, full::DataMatrix; k=10, col=\"LOF\")\n\nCompute the Local Outlier Factor (LOF) for each observation in data, and add as column to data.obs with the name col.\n\nWhen working with projected DataMatrices, use local_outlier_factor_projection! instead.\n\nNB: This function might be very slow for high values of k.\n\nFirst, the k nearest neighbors are found for each observation in data. Then, the Local Outlier Factor is computed by considering the distance between the neighbors, but this time in the full DataMatrix. Thus full must have the same observations as are present in data.\n\nA LOF value smaller than or close to one is means that the observation is an inlier, but a LOF value much larger than one means that the observation is an inlier.\n\nBy specifiying full=data, this is coincides with the standard definition for Local Outlier Factor. However, it is perhaps more useful to find neighbors in a dimension reduced space (after e.g. svd (PCA) or umap), but then compute distances in the high dimensional space (typically after normalization). This way, an observation is concidered an outlier if the reduction to a lower dimensional space didn't properly represent the neighborhood of the observation.\n\nnote: Note\nThe interface is not yet fully decided and subject to change.\n\nExamples\n\nCompute the Local Outlier Factor, with nearest neighbors based only on reduced, but later using distances in full for the actual LOF computation.\n\njulia> reduced = svd(normalized; nsv=10)\n\njulia> local_outlier_factor!(reduced, normalized; k=10)\n\nSee also: local_outlier_factor, local_outlier_factor_table, local_outlier_factor_projection!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.local_outlier_factor-Tuple{DataMatrix, DataMatrix}","page":"Interface","title":"SingleCellProjections.local_outlier_factor","text":"local_outlier_factor(data::DataMatrix, full::DataMatrix; k=10, col=\"LOF\", matrix=:keep, var=:copy)\n\nSee local_outlier_factor! for documentation. This version does not modify data in place.\n\nSee also: local_outlier_factor!, local_outlier_factor_table, local_outlier_factor_projection\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.local_outlier_factor_projection!-NTuple{4, DataMatrix}","page":"Interface","title":"SingleCellProjections.local_outlier_factor_projection!","text":"local_outlier_factor_projection!(data::DataMatrix, full::DataMatrix, base::DataMatrix, base_full::DataMatrix; k=10, col=\"LOF_projection\")\n\nCompute the Local Outlier Factor (LOF) for each observation in data, and add as column to data.obs with the name col.\n\nUse local_outlier_factor_projection! if you are working with projected data, and local_outlier_factor! otherwise.\n\nParameters:\n\ndata - A DataMatrix for which we compute LOF for each observation. Expected to be a DataMatrix projected onto base, so that the data and base use the same coordinate system.\nfull - A DataMatrix with the same observations as data, used to compute distances in the LOF computation. Expected to be a DataMatrix projected onto base_full, so that the full and base_full use the same coordinate system.\nbase - The base DataMatrix.\nbase_full - The base DataMatrix.\nk - The number of nearest neighbors to use. NB: This function might be very slow for high values of k.\n\nFirst, for each observation in data, the k nearest neighbors in base are found. Then, the distance to each neighbor is computed using full and base_full. Thus full must have the same observations as are present in data, and base_full must have the same observations as base.\n\nA LOF value smaller than or close to one is means that the observation is an inlier, but a LOF value much larger than one means that the observation is an inlier.\n\nBy specifiying full=data and base_full=base, this is coincides with the standard definition for Local Outlier Factor. However, it is perhaps more useful to find neighbors in a dimension reduced space (after e.g. svd (PCA) or umap), but then compute distances in the high dimensional space (typically after normalization). This way, an observation is concidered an outlier if the reduction to a lower dimensional space didn't properly represent the neighborhood of the observation.\n\nnote: Note\nThe interface is not yet fully decided and subject to change.\n\nExamples\n\nCompute the Local Outlier Factor (LOF) for each observation in a data set reduced, which has been projected onto base_reduced.\n\nThe nearest neighbors are computed between observations in reduced and base_reduced, but the distances in the actual LOF computation are between the same observations in normalized and base_normalized.\n\njulia> base_reduced = svd(base_normalized; nsv=10)\n\njulia> normalized = project(counts, base_normalized);\n\njulia> reduced = project(normalized, base_reduced);\n\njulia> local_outlier_factor!(reduced, normalized, base_reduced, base_normalized; k=10)\n\nSee also: local_outlier_factor_projection, local_outlier_factor_projection_table, local_outlier_factor!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.local_outlier_factor_projection-NTuple{4, DataMatrix}","page":"Interface","title":"SingleCellProjections.local_outlier_factor_projection","text":"local_outlier_factor_projection(data::DataMatrix, full::DataMatrix, base::DataMatrix, base_full::DataMatrix; k=10, col=\"LOF_projection\", matrix=:keep, var=:copy)\n\nSee local_outlier_factor_projection! for documentation. This version does not modify data in place.\n\nSee also: local_outlier_factor_projection!, local_outlier_factor_projection_table, local_outlier_factor\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.local_outlier_factor_projection_table-NTuple{4, DataMatrix}","page":"Interface","title":"SingleCellProjections.local_outlier_factor_projection_table","text":"local_outlier_factor_projection_table(data::DataMatrix, full::DataMatrix, base::DataMatrix, base_full::DataMatrix; k=10, col=\"LOF_projection\", matrix=:keep, var=:copy)\n\nSee local_outlier_factor_projection! for documentation. This returns a DataFrame with observation IDs and a column col with LOF values for the projection.\n\nSee also: local_outlier_factor_projection!, local_outlier_factor_projection, local_outlier_factor_table\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.local_outlier_factor_table-Tuple{DataMatrix, DataMatrix}","page":"Interface","title":"SingleCellProjections.local_outlier_factor_table","text":"local_outlier_factor_table(data::DataMatrix, full::DataMatrix; k=10, col=\"LOF\")\n\nSee local_outlier_factor! for documentation. This returns a DataFrame with observation IDs and a column col with LOF values.\n\nSee also: local_outlier_factor!, local_outlier_factor, local_outlier_factor_projection_table\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.logtransform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SingleCellProjections.logtransform","text":"logtransform([T=Float64], counts::DataMatrix;\n             var_filter = hasproperty(counts.var, \"feature_type\") ? \"feature_type\" => isequal(\"Gene Expression\") : nothing,\n             var_filter_cols = hasproperty(counts.var, \"feature_type\") ? \"feature_type\" : nothing,\n             scale_factor=10_000,\n             var=:copy,\n             obs=:copy)\n\nLog₂-transform counts using the formula:\n\n  log₂(1 + cᵢⱼ*scale_factor/(∑ᵢcᵢⱼ))\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nvar_filter - Control which variables (features) to use for parameter estimation. Defaults to \"feature_type\" => isequal(\"Gene Expression\"), if a feature_type column is present in counts.var. Can be set to nothing to disable filtering. See DataFrames.filter for how to specify filters.\nvar_filter_cols - Additional columns used to ensure features are unique. Defaults to \"feature_type\" if present in counts.var. Use a Tuple/Vector for specifying multiple columns. Can be set to nothing to not include any additional columns.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nExamples\n\njulia> transformed = logtransform(counts)\n\nUse eltype Float32 to lower memory usage:\n\njulia> transformed = logtransform(Float32, counts)\n\nSee also: sctransform\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.mannwhitney!-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.mannwhitney!","text":"mannwhitney!(data::DataMatrix, column, [group_a, group_b]; kwargs...)\n\nPerform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.\n\nNote that data must be a DataMatrix containing a sparse matrix only. It is recommended to first logtransform (or tf_idf_transform) the raw counts before performing the Mann-Whitney U-test.\n\nmannwhitney! adds a U statistic and a p-value column to data.var. See mannwhitney_table for more details on groups and kwargs.\n\nIn addition mannwhitney! supports the kwarg:\n\nprefix - Output column names for U statistics and p-values will be prefixed with this string. If none is given, it will be constructed from column, group_a and group_b.\n\nSee also: mannwhitney_table, mannwhitney\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.mannwhitney-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.mannwhitney","text":"mannwhitney(data::DataMatrix, column, [group_a, group_b]; var=:copy, obs=:copy, matrix=:keep, kwargs...)\n\nPerform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.\n\nNote that data must be a DataMatrix containing a sparse matrix only. It is recommended to first logtransform (or tf_idf_transform) the raw counts before performing the Mann-Whitney U-test.\n\nmannwhitney creates a copy of data and adds a U statistic and a p-value column to data.var. See mannwhitney! and mannwhitney_table for more details on groups and kwargs.\n\nSee also: mannwhitney!, mannwhitney_table\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.mannwhitney_table-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.mannwhitney_table","text":"mannwhitney_table(data::DataMatrix, column, [group_a, group_b]; kwargs...)\n\nPerform a Mann-Whitney U-test (also known as a Wilcoxon rank-sum test) between two groups of observations. The U statistic is corrected for ties, and p-values are computed using a normal approximation.\n\nNote that data must be a DataMatrix containing a sparse matrix only. It is recommended to first logtransform (or tf_idf_transform) the raw counts before performing the Mann-Whitney U-test.\n\ncolumn specifies a column in data.obs and is used to determine which observations belong in which group.\n\nIf group_a and group_b are not given, the column must contain exactly two unique values (except missing). If group_a is given, but not group_b, the observations in group A are compared to all other observations (except missing). If both group_a and group_b are given, the observations in group A are compared the observations in group B.\n\nmannwhitney_table returns a Dataframe with columns for variable IDs, U statistics and p-values.\n\nSupported kwargs are:\n\nstatistic_col=\"U\"   - Name of the output column containing the U statistics. (Set to nothing to remove from output.)\npvalue_col=\"pValue\" - Name of the output column containing the p-values. (Set to nothing to remove from output.)\nh1_missing=:skip    - One of :skip and :error. If skip, missing values in column are skipped, otherwise an error is thrown.\n\nThe following kwargs determine how the computations are threaded:\n\nnworkers      - Number of worker threads used in the computation. Set to 1 to disable threading.\nchunk_size    - Number of variables processed in each chunk.\nchannel_size  - Max number of unprocessed chunks in queue.\n\nSee also: mannwhitney!, mannwhitney\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.merge_counts-Tuple{Any, Any}","page":"Interface","title":"SingleCellProjections.merge_counts","text":"merge_counts(samples, sample_names;\n             lazy=false,\n             sample_name_col = sample_names===nothing ? nothing : \"sampleName\",\n             obs_id_col = \"cell_id\",\n             obs_id_delim = '_',\n             obs_id_prefixes = sample_names,\n             extra_var_id_cols::Union{Nothing,String,Vector{String}},\n             duplicate_var,\n             duplicate_obs,\n             callback=nothing)\n\nMerge samples to create one large DataMatrix, by concatenating the obs. The union of the variables from the samples is used, and if a variable is not present in a sample, the count will be set to zero.\n\nThe obs IDs are created by concatenating the current obs ID columns, together with the sample_names (if provided).\n\nlazy - Lazy merging. Use load_counts to actually perform the merging.\nsample_name_col - Column in which the sample_names are stored.\nobs_id_col - Name of obs ID column after merging. (Set to nothing to keep old column name.)\nobs_id_delim - Delimiter used when merging obs IDs.\nobs_id_prefixes - Prefix (one per sample) used to create new IDs. Set to nothing to keep old IDs. Defaults to sample_names.\nextra_var_id_cols - Additional columns to use to ensure variable IDs are unique during merging. Defaults to \"feature_type\" if that column is present for all samples. Can be a Vector{String} to include multiple columns. Set to nothing to disable.\nduplicate_var - Set to :ignore, :warn or :error to decide what happens if duplicate var IDs are found.\nduplicate_obs - Set to :ignore, :warn or :error to decide what happens if duplicate obs IDs are found.\ncallback - Experimental callback functionality. The callback function is called between samples during merging. Return true to abort loading and false to continue.\n\nSee also: load_counts\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, SingleCellProjections.DesignMatrix}","page":"Interface","title":"SingleCellProjections.normalize_matrix","text":"normalize_matrix(data::DataMatrix, design::DesignMatrix; scale=false, kwargs...)\n\nNormalize data using the specified design matrix.\n\nSee also: NormalizationModel, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.normalize_matrix-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.normalize_matrix","text":"normalize_matrix(data::DataMatrix, [covariates...]; center=true, scale=false, kwargs...)\n\nNormalize data. By default, the matrix is centered. Any covariates specified (using column names of data.obs) will be regressed out.\n\ncenter - Set to true to center the data matrix.\nscale - Set to true to scale the variables in the data matrix to unit standard deviation.\n\nFor other kwargs and more detailed descriptions, see NormalizationModel and designmatrix.\n\nExamples\n\nCentering only:\n\njulia> normalize_matrix(data)\n\nRegression model with intercept (centering) and \"fraction_mt\" (numerical annotation):\n\njulia> normalize_matrix(data, \"fraction_mt\")\n\nAs above, but also including \"batch\" (categorical annotation):\n\njulia> normalize_matrix(data, \"fraction_mt\", \"batch\")\n\nSee also: NormalizationModel, designmatrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.obs_coordinates","page":"Interface","title":"SingleCellProjections.obs_coordinates","text":"obs_coordinates(data::DataMatrix)\n\nReturns a matrix with coordinates for the observations. Not available for all types of DataMatrices. Mostly useful for data matrices after dimension reduction such as svd or force_layout has been applied.\n\nIn the case of SVD (PCA), obs_coordinates returns the principal components, scaled by the singular values. This is a a good starting point for downstream analysis, since it is the optimal linear approximation of the original data for the given number of dimensions.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, AbstractVector{<:ProjectionModel}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, models, args...; verbose=true, kwargs...)\n\nConvenience function for projection onto multiple models. Essentially calls foldl and prints some @info messages (if verbose=true). In most cases, it is better to call project(data, base::DataMatrix) instead of using this method directly.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, base::DataMatrix, args...; from=nothing, kwargs...)\n\nProject data onto base, by applying ProjectionModels from base one by one.\n\nSince data already might have some models applied, project will try to figure out which models from base to use. See \"Examples\" below for concrete examples. Here's a more technical overview:\n\nConsider a base data matrix with four models:\n\nbase: A -> B -> C -> D\n\nGiven some new data (typically counts), we can project that onto base, given the result proj by applying all four models:\n\ndata:\nproj: A -> B -> C -> D\n\nIf data already has some models applied (e.g. we already projected onto A and B above), project will look for the last model in data (in this case B) in the list of models in base, and only apply models after that (in this case C and D).\n\ndata: A -> B\nproj: A -> B -> C -> D\n\nIt is also possible to use the from kwarg to specify exactly which models to apply. (The models in from must be a prefix of the models in base, or in other words, base was created by applying additional operations to from.)\n\ndata: X\nbase: A -> B -> C -> D\nfrom: A -> B\nproj: X -> C -> D\n\nNote that it is necessary to use the from kwarg if the last model in data does not occurr in base, because project cannot figure out on its own which models it makes sense to apply.\n\nExamples\n\nFirst, we construct a \"base\" by loading counts, SCTransforming, normalizing, computing the svd and finally computing a force layout:\n\njulia> fp = [\"GSE164378_RNA_ADT_3P_P1.h5\", \"GSE164378_RNA_ADT_3P_P2.h5\"];\njulia> counts = load_counts(fp; sample_names=[\"P1\",\"P2\"]);\njulia> transformed = sctransform(counts);\njulia> normalized = normalize_matrix(transformed);\njulia> reduced = svd(normalized; nsv=10);\njulia> fl = force_layout(reduced; ndim=3, k=100)\n  DataMatrix (3 variables and 35340 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nNote how the last line lists all ProjectionModels used in the creation of fl.\n\nNext, let's load some more samples for projection:\n\njulia> fp2 = [\"GSE164378_RNA_ADT_3P_P5.h5\", \"GSE164378_RNA_ADT_3P_P6.h5\"];\njulia> counts2 = load_counts(fp2; sample_names=[\"P5\",\"P6\"]);\n\nIt is easy to project the newly loaded counts2 onto the \"base\" force layout fl:\n\njulia> project(counts2, fl)\nDataMatrix (3 variables and 42553 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nWe can also project in two or more steps, to get access to intermediate results:\n\njulia> reduced2 = project(counts2, reduced)\nDataMatrix (20239 variables and 42553 observations)\n  SVD (10 dimensions)\n  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...\n  Observations: id, sampleName, barcode\n  Models: SVDModel(nsv=10), Normalization, SCTransform\n\njulia> project(reduced2, fl)\nDataMatrix (3 variables and 42553 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform\n\nIf the DataMatrix we want to project is modified, we need to use the from kwarg to tell project which models to use:\n\njulia> filtered = counts2[:,1:10:end]\nDataMatrix (33766 variables and 4256 observations)\n  SparseArrays.SparseMatrixCSC{Int64, Int32}\n  Variables: id, feature_type, name, genome, read, pattern, sequence\n  Observations: id, sampleName, barcode\n  Models: FilterModel(:, 1:10:42551)\n\njulia> reduced2b = project(filtered2, reduced; from=counts)\nDataMatrix (20239 variables and 4256 observations)\n  SVD (10 dimensions)\n  Variables: id, feature_type, name, genome, read, pattern, sequence, logGeneMean, outlier, beta0, ...\n  Observations: id, sampleName, barcode\n  Models: SVDModel(nsv=10), Normalization, SCTransform, Filter\n\nAfter that, it is possible to continue without specifying from:\n\njulia> project(reduced2b, fl)\nDataMatrix (3 variables and 4256 observations)\n  Matrix{Float64}\n  Variables: id\n  Observations: id, sampleName, barcode\n  Models: NearestNeighborModel(base=\"force_layout\", k=10), SVD, Normalization, SCTransform, Filter\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.project-Tuple{DataMatrix, ProjectionModel, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.project","text":"project(data::DataMatrix, model::ProjectionModel, args...; verbose=true, kwargs...)\n\nCore projection function. Project data based on the single ProjectionModel model. In most cases, it is better to call project(data, base::DataMatrix) instead of using this method directly.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.pseudobulk-Tuple{DataMatrix, Any, Vararg{String}}","page":"Interface","title":"SingleCellProjections.pseudobulk","text":"pseudobulk(data::DataMatrix, obs_col, [additional_columns...]; var=:copy)\n\nCreate a new DataMatrix by averging over groups, as specified by the categorical annotation obs_col (and optionally additional columns).\n\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\n\nExamples\n\nCreate a pseudobulk representation of each sample:\n\njulia> pseudobulk(transformed, \"sampleName\")\n\nCreate a pseudobulk representation for each celltype in each sample:\n\njulia> pseudobulk(transformed, \"sampleName\", \"celltype\")\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.set_obs_id_col!-Tuple{DataMatrix, String}","page":"Interface","title":"SingleCellProjections.set_obs_id_col!","text":"set_obs_id_col!(data::DataMatrix, obs_id_col::String; duplicate_obs=:error)\n\nSet which column to use as observation IDs. It will be moved to the first column of data.obs. The rows of this column in data.obs must be unique.\n\nduplicate_obs - Set to :ignore, :warn or :error to decide what happens if duplicate IDs are found.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.set_var_id_col!-Tuple{DataMatrix, String}","page":"Interface","title":"SingleCellProjections.set_var_id_col!","text":"set_var_id_col!(data::DataMatrix, var_id_col::String; duplicate_var=:error)\n\nSet which column to use as variable IDs. It will be moved to the first column of data.var. The rows of this column in data.var must be unique.\n\nduplicate_var - Set to :ignore, :warn or :error to decide what happens if duplicate IDs are found.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.splitrange-Union{Tuple{T}, Tuple{UnitRange{T}, Integer}} where T<:Real","page":"Interface","title":"SingleCellProjections.splitrange","text":"splitrange(r::UnitRange, nparts::Integer)\n\nSplits a range in nparts number of parts of equal length.\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.tf_idf_transform-Union{Tuple{T}, Tuple{Type{T}, DataMatrix}} where T","page":"Interface","title":"SingleCellProjections.tf_idf_transform","text":"tf_idf_transform([T=Float64], counts::DataMatrix;\n                 var_filter = hasproperty(counts.var, \"feature_type\") ? \"feature_type\" => isequal(\"Gene Expression\") : nothing,\n                 var_filter_cols = hasproperty(counts.var, \"feature_type\") ? \"feature_type\" : nothing,\n                 scale_factor = 10_000,\n                 idf = vec(size(counts,2) ./ max.(1,sum(counts.matrix; dims=2))),\n                 annotate = true,\n                 var = :copy,\n                 obs = :copy)\n\nCompute the TF-IDF (term frequency-inverse document frequency) transform of counts, using the formula log( 1 + scale_factor * tf * idf ) where tf is the term frequency counts.matrix ./ max.(1, sum(counts.matrix; dims=1)).\n\nOptionally, T can be specified to control the eltype of the sparse transformed matrix. T=Float32 can be used to lower the memory usage, with little impact on the results, since downstream analysis is still done with Float64.\n\nvar_filter - Control which variables (features) to use for parameter estimation. Defaults to \"feature_type\" => isequal(\"Gene Expression\"), if a feature_type column is present in counts.var. Can be set to nothing to disable filtering. See DataFrames.filter for how to specify filters.\nvar_filter_cols - Additional columns used to ensure features are unique. Defaults to \"feature_type\" if present in counts.var. Use a Tuple/Vector for specifying multiple columns. Can be set to nothing to not include any additional columns.\nannotate - If true, idf will be added as a var annotation.\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ttest!-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ttest!","text":"ttest!(data::DataMatrix, h1, [group_a], [group_b]; h0, kwargs...)\n\nPerforms a t-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.\n\nttest! adds a t-statistic, a p-value and a difference column to data.var.\n\nSee ttest_table for usage examples and more details on computations and parameters.\n\nIn addition ttest! supports the kwarg:\n\nprefix - Output column names for t-statistics, p-values and differences will be prefixed with this string. If none is given, it will be constructed from h1, group_a, group_b and h0.\n\nSee also: ttest_table, ttest, ftest!, mannwhitney!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ttest-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ttest","text":"ttest(data::DataMatrix, h1, [group_a], [group_b]; h0, var=:copy, obs=:copy, matrix=:keep, kwargs...)\n\nPerforms a t-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.\n\nttest creates a copy of data and adds a t-statistic, a p-value and a difference column to data.var.\n\nSee ttest_table and ttest! for usage examples and more details on computations and parameters.\n\nSee also: ttest!, ttest_table, ftest, mannwhitney\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.ttest_table-Tuple{DataMatrix, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.ttest_table","text":"ttest_table(data::DataMatrix, h1, [group_a], [group_b]; h0, kwargs...)\n\nPerforms a t-Test with the given h1 (alternative hypothesis) and h0 (null hypothesis). Examples of t-Tests are Two-Group tests and Linear Regression.\n\nT-tests can be performed on any DataMatrix, but it is almost always recommended to do it directly after transforming the data using e.g. sctransform, logtransform or tf_idf_transform.\n\nnote: Normalization\nDo not use ttest_table after normalizing the data using normalize_matrix: ttest_table needs to know about the h0 model (regressed out covariates) for correction computations. Failing to do so can result in incorrect results. If you want to correct for the same covariates, pass them as h0 to ttest_table.\n\nh1 can be:\n\nA string specifying a column name of data.obs. Auto-detection determines if the column is categorical (Two-Group) or numerical (linear regression).\nIf group_a and group_b are specified, a Two-Group test between group_a and group_b is performed.\nIf group_a is specified, but not group_b, a Two-Group test between group_a and all other observations is performed.\nA covariate for more control of how to interpret the values in the column.\n\nttest_table returns a Dataframe with columns for variable IDs, t-statistics, p-values and differences. For Two-group tests, difference is the difference in mean between the two groups. For linear regression, the difference corresponds to the rate of change.\n\nSupported kwargs are:\n\nh0                            - Use a non-trivial h0 (null) model. Specified in the same way as h1 above.\ncenter=true                   - Add an intercept to the h0 (null) model.\nstatistic_col=\"t\"             - Name of the output column containing the t-statistics. (Set to nothing to remove from output.)\npvalue_col=\"pValue\"           - Name of the output column containing the p-values. (Set to nothing to remove from output.)\ndifference_col=\"difference\"   - Name of the output column containing the differences. (Set to nothing to remove from output.)\nh1_missing=:skip              - One of :skip and :error. If skip, missing values in h1 columns are skipped, otherwise an error is thrown.\nh0_missing=:error             - One of :skip and :error. If skip, missing values in h0 columns are skipped, otherwise an error is thrown.\nallow_normalized_matrix=false - Set to true to accept running on a DataMatrix that has been normalized.\n\nExamples\n\nPerform a Two-Group t-test between celltypes \"Mono\" and \"DC\".\n\njulia> ttest_table(transformed, \"celltype\", \"Mono\", \"DC\")\n\nPerform a Two-Group t-test between celltype \"Mono\" and all other cells.\n\njulia> ttest_table(transformed, \"celltype\", \"Mono\")\n\nPerform a Two-Group t-test between celltypes \"Mono\" and \"DC\", while correcting for \"fraction_mt\" (a linear covariate).\n\njulia> ttest_table(transformed, \"celltype\", \"Mono\", \"DC\")\n\nPerform Linear Regression using the covariate \"fraction_mt\".\n\njulia> ttest_table(transformed, \"fraction_mt\")\n\nSee also: ttest!, ttest, ftest_table, mannwhitney_table, covariate\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.update_matrix","page":"Interface","title":"SingleCellProjections.update_matrix","text":"update_matrix(data::DataMatrix, matrix, model=nothing;\n              var::Union{Symbol,String,DataFrame} = \"\",\n              obs::Union{Symbol,String,DataFrame} = \"\")\n\nCreate a new DataMatrix by replacing parts of data with new values. Mostly useful when implementing new ProjectionModels.\n\nmatrix - the new matrix.\nmodel - will be appended to the list of models from data. If set to nothing, the resulting list of models will be empty.\n\nKwargs:\n\nvar - One of:\n:copy - Copy from data.\n:keep - Share var with data.\n::DataFrame - Replace with a new table with variable annotations.\nprefix::String - Prefix, the new variables will be named prefix1, prefix2, etc.\nobs See var.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.ustatistic_single-Union{Tuple{T}, Tuple{AbstractSparseMatrix{T}, Vararg{Any, 4}}} where T","page":"Interface","title":"SingleCellProjections.ustatistic_single","text":"ustatistic_single(X, j, groups, n1, n2)\n\nNB: Assumes all sparse non-zeros are positive.\n\nX is a sparse matrix where each column is a variable. j is the current variable. groups is a vector with values: 1 for each sample in group 1, 2 for each sample in group 2 and 0 for samples in neither group. n1 number of elements in group 1 (precomputed from groups) n2 number of elements in group 2 (precomputed from groups)\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.var_coordinates","page":"Interface","title":"SingleCellProjections.var_coordinates","text":"var_coordinates(data::DataMatrix)\n\nReturns a matrix with coordinates for the variables. Only available for DataMatrices that have a dual representation (e.g. SVD/PCA).\n\nIn the case of SVD (PCA), var_coordinates returns the principal components as unit vectors.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SingleCellProjections.var_counts_fraction!-Tuple{DataMatrix{<:AbstractMatrix{<:Integer}}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.var_counts_fraction!","text":"var_counts_fraction!(counts::DataMatrix, sub_filter, tot_filter, col; check=true, var=:keep, obs=:keep)\n\nFor each observation, compute the fraction of counts that match a specific variable pattern.\n\nsub_filter decides which variables are counted.\ntot_filter decides which variables to include in the total.\n\nkwargs:\n\nvar - Use this to set var in the ProjectionModel.\nobs - Use this to set obs in the ProjectionModel. Note that counts.obs is changed in place, regardless of the value of obs.\n\nIf check=true, an error will be thrown if no variables match the patterns.\n\nFor more information on filtering syntax, see examples below and the documentation on DataFrames.filter.\n\nExamples\n\nCompute the fraction of reads in MT- genes, considering only \"Gene Expression\" features (and not e.g. \"Antibody Capture\").\n\nvar_counts_fraction!(counts, \"name\"=>startswith(\"MT-\"), \"feature_type\"=>isequal(\"Gene Expression\"), \"fraction_mt\")\n\nCompute the fraction of reads in MT- genes, when there is no feature_type annotation (i.e. all variables are genes).\n\nvar_counts_fraction!(counts, \"name\"=>startswith(\"MT-\"), Returns(true), \"fraction_mt\")\n\nSee also: var_counts_fraction\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.var_counts_fraction-Tuple{DataMatrix{<:AbstractMatrix{<:Integer}}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.var_counts_fraction","text":"var_counts_fraction(counts::DataMatrix, sub_filter, tot_filter, col; check=true, var=:copy, obs=:copy)\n\nFor each observation, compute the fraction of counts that match a specific variable pattern.\n\nsub_filter decides which variables are counted.\ntot_filter decides which variables to include in the total.\n\nkwargs:\n\nvar - Can be :copy (make a copy of source var) or :keep (share the source var object).\nobs - Can be :copy (make a copy of source obs) or :keep (share the source obs object).\n\nIf check=true, an error will be thrown if no variables match the patterns.\n\nFor more information on filtering syntax, see examples below and the documentation on DataFrames.filter.\n\nExamples\n\nCompute the fraction of reads in MT- genes, considering only \"Gene Expression\" features (and not e.g. \"Antibody Capture\").\n\nvar_counts_fraction(counts, \"name\"=>startswith(\"MT-\"), \"feature_type\"=>isequal(\"Gene Expression\"), \"fraction_mt\")\n\nCompute the fraction of reads in MT- genes, when there is no feature_type annotation (i.e. all variables are genes).\n\nvar_counts_fraction(counts, \"name\"=>startswith(\"MT-\"), Returns(true), \"fraction_mt\")\n\nSee also: var_counts_fraction!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.var_counts_sum!-Tuple{Any, DataMatrix{<:AbstractMatrix}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.var_counts_sum!","text":"var_counts_sum!([f=identity], counts::DataMatrix, filter, col; check=true, var=:keep, obs=:keep)\n\nFor each observation, compute the sum of counts matching the filter.\n\nIf f is specified, it is applied to each element before summing. (Similar to sum.)\n\nkwargs:\n\nvar - Use this to set var in the ProjectionModel.\nobs - Use this to set obs in the ProjectionModel. Note that counts.obs is changed in place, regardless of the value of obs.\n\nIf check=true, an error will be thrown if no variables match the pattern.\n\nFor more information on filtering syntax, see examples below and the documentation on DataFrames.filter.\n\nExamples\n\nSum all \"Gene Expression\" counts:\n\nvar_counts_sum!(counts, \"feature_type\"=>isequal(\"Gene Expression\"), \"totalRNACount\")\n\nCompute the number of \"Gene Expression\" variables that are expressed (i.e. nonzero):\n\nvar_counts_sum!(!iszero, counts, \"feature_type\"=>isequal(\"Gene Expression\"), \"nonzeroRNACount\")\n\nSee also: var_counts_sum\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.var_counts_sum-Tuple{Any, DataMatrix{<:AbstractMatrix}, Vararg{Any}}","page":"Interface","title":"SingleCellProjections.var_counts_sum","text":"var_counts_sum([f=identity], counts::DataMatrix, filter, col; check=true, var=:keep, obs=:keep)\n\nFor each observation, compute the sum of counts matching the filter.\n\nIf f is specified, it is applied to each element before summing. (Similar to sum.)\n\nkwargs:\n\nvar - Use this to set var in the ProjectionModel.\nobs - Use this to set obs in the ProjectionModel. Note that counts.obs is changed in place, regardless of the value of obs.\n\nIf check=true, an error will be thrown if no variables match the pattern.\n\nFor more information on filtering syntax, see examples below and the documentation on DataFrames.filter.\n\nExamples\n\nSum all \"Gene Expression\" counts:\n\nvar_counts_sum(counts, \"feature_type\"=>isequal(\"Gene Expression\"), \"totalRNACount\")\n\nCompute the number of \"Gene Expression\" variables that are expressed (i.e. nonzero):\n\nvar_counts_sum(!iszero, counts, \"feature_type\"=>isequal(\"Gene Expression\"), \"nonzeroRNACount\")\n\nSee also: var_counts_sum!\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.variable_std-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.variable_std","text":"variable_std(data::DataMatrix)\n\nComputes the variance of each variable in data.\n\nnote: Note\ndata must be mean-centered. E.g. by using normalize_matrix before calling variable_std.\n\nSee also: variable_var, normalize_matrix\n\n\n\n\n\n","category":"method"},{"location":"interface/#SingleCellProjections.variable_var-Tuple{DataMatrix}","page":"Interface","title":"SingleCellProjections.variable_var","text":"variable_var(data::DataMatrix)\n\nComputes the variance of each variable in data.\n\nnote: Note\ndata must be mean-centered. E.g. by using normalize_matrix before calling variable_var.\n\nSee also: variable_std, normalize_matrix\n\n\n\n\n\n","category":"method"},{"location":"datamatrices/#Data-Matrices","page":"Data Matrices","title":"Data Matrices","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"# Mimic the dataset from the tutorial without including it in the docs building\n\n\n# Useful function to extract a little data from a DataMatrix to use here for show\n# function f(col, n; h=10, t=10, filler=\"\")\n# \t@assert h+t <= n\n# \tpre = string(col[1:h])\n# \tmid = string(\"fill(\\\"\", filler, \"\\\", \", n-h-t, \")\")\n# \tpost = string(col[end-t+1:end])\n# \tstring(\"vcat(\", pre, \", \", mid, \", \", post, ')')\n# end\n\n\n\nusing SingleCellProjections, SparseArrays, DataFrames\nP,N = 33766,35340\nX = sparse(Int32[], Int32[], Int[], P, N)\n\nv_id = vcat([\"MIR1302-2HG\", \"FAM138A\", \"OR4F5\", \"AL627309.1\", \"AL627309.3\", \"AL627309.2\", \"AL627309.4\", \"AL732372.1\", \"OR4F29\", \"AC114498.1\"], string.(\"dummy_\", 1:33746), [\"CD169\", \"CD28\", \"CD161\", \"CD163\", \"CD138-1\", \"CD164\", \"CD138-2\", \"CD144\", \"CD202b\", \"CD11c\"])\nv_feature_type = vcat(fill(\"Gene Expression\",33538), fill(\"Antibody Capture\", P-33538))\n\no_id = vcat([\"P1_L1_AAACCCAAGACATACA\", \"P1_L1_AAACCCACATCGGTTA\", \"P1_L1_AAACCCAGTGGAACAC\", \"P1_L1_AAACCCATCTGCGGAC\", \"P1_L1_AAACGAAAGTTACTCG\", \"P1_L1_AAACGAACAATGAGCG\", \"P1_L1_AAACGAACACTCCTTG\", \"P1_L1_AAACGAACAGCATCTA\", \"P1_L1_AAACGAATCCTCACCA\", \"P1_L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:35320), [\"P2_L5_TTTGGTTGTCCGAAAG\", \"P2_L5_TTTGGTTTCCTCTAGC\", \"P2_L5_TTTGGTTTCGTAGGGA\", \"P2_L5_TTTGGTTTCTTTGATC\", \"P2_L5_TTTGTTGAGTGTACCT\", \"P2_L5_TTTGTTGGTACGATCT\", \"P2_L5_TTTGTTGGTCCTTAAG\", \"P2_L5_TTTGTTGTCAACACCA\", \"P2_L5_TTTGTTGTCATGCATG\", \"P2_L5_TTTGTTGTCCGTGCGA\"])\no_sampleName = vcat(fill(\"P1\",18135), fill(\"P2\", N-18135))\no_barcode = vcat([\"L1_AAACCCAAGACATACA\", \"L1_AAACCCACATCGGTTA\", \"L1_AAACCCAGTGGAACAC\", \"L1_AAACCCATCTGCGGAC\", \"L1_AAACGAAAGTTACTCG\", \"L1_AAACGAACAATGAGCG\", \"L1_AAACGAACACTCCTTG\", \"L1_AAACGAACAGCATCTA\", \"L1_AAACGAATCCTCACCA\", \"L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:35320), [\"L5_TTTGGTTGTCCGAAAG\", \"L5_TTTGGTTTCCTCTAGC\", \"L5_TTTGGTTTCGTAGGGA\", \"L5_TTTGGTTTCTTTGATC\", \"L5_TTTGTTGAGTGTACCT\", \"L5_TTTGTTGGTACGATCT\", \"L5_TTTGTTGGTCCTTAAG\", \"L5_TTTGTTGTCAACACCA\", \"L5_TTTGTTGTCATGCATG\", \"L5_TTTGTTGTCCGTGCGA\"])\n\nv = DataFrame(id=v_id, feature_type=v_feature_type, name=v_id, genome=\"hg19\", read=\"\", pattern=\"\", sequence=\"\")\no = DataFrame(id=o_id, sampleName=o_sampleName, barcode=o_barcode)\ndata = DataMatrix(X, v, o)","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"DataMatrix objects – annotated matrices where rows are variables and columns are observations – are central in SingleCellProjections.jl. A DataMatrix is also sometimes called an \"Assay\", in other software packages.","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"An overview of a DataMatrix is shown when the object is displayed:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Here we see the matrix size (number of variables and observations), a brief description of the matrix contents, and an overview of available variable and observation annotations. The underlined annotation names are the ID columns (see IDs below for more details).","category":"page"},{"location":"datamatrices/#Variables","page":"Data Matrices","title":"Variables","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Variables, or var for short, are typically genes, features (such as CITE-seq features) or variables after dimension reduction (e.g. \"UMAP1\"). The variables are stored as a DataFrame and can be accessed by:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.var","category":"page"},{"location":"datamatrices/#Observations","page":"Data Matrices","title":"Observations","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Observations, or obs for short, are typically cells, but can in theory be any kind of observation. The observations are stored as a DataFrame and can be accessed by:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.obs","category":"page"},{"location":"datamatrices/#IDs","page":"Data Matrices","title":"IDs","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Each variable and each observation must have a unique ID, that is, each row in the DataFrame should be unique if we consider the ID columns only. As seen above, the ID columns are underlined when displaying a DataMatrix. We can also access them directly:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.var_id_cols","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"data.obs_id_cols","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Most of the time, IDs are handled automatically by SingleCellProjections.jl. Sometimes, you need to make sure IDs are unique when loading or merging data matrices. In particular, when loading a DataMatrix that should be projected onto another DataMatrix, the user must ensure that relevant IDs are matching.","category":"page"},{"location":"datamatrices/#Matrix","page":"Data Matrices","title":"Matrix","text":"","category":"section"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"The matrix can be accessed by data.matrix. Depending on the stage of analysis, different kinds of matrices (or matrix-like objects) are used. Most of this complexity is hidden from the user, but internally SingleCellProjections.jl depends on this functionality to be fast and to reduce memory usage.","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"warning: Read-only\nSingleCellProjections.jl will reuse matrices when possible, in order to reduce memory usage. E.g. normalize_matrix will reuse and extend the Matrix Expression of the source DataMatrix, without creating a copy of the actual data. When matrices are reused/copied is considered an implementation detail, and can change at any time. Users of SingleCellProjections.jl should thus consider the matrices to be \"read-only\". This should rarely present problems in practice.","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Roughly, the matrix types used at different stages are:","category":"page"},{"location":"datamatrices/","page":"Data Matrices","title":"Data Matrices","text":"Counts - SparseMatrixCSC\nTransformed and normalized data - Matrix Expressions\nSVD (PCA) result - SVD\nForceLayout/UMAP/t-SNE result - Matrix{Float64}","category":"page"},{"location":"matrixexpressions/#Matrix-Expressions","page":"Matrix Expressions","title":"Matrix Expressions","text":"","category":"section"},{"location":"matrixexpressions/","page":"Matrix Expressions","title":"Matrix Expressions","text":"To be written.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SingleCellProjections","category":"page"},{"location":"#SingleCellProjections","page":"Home","title":"SingleCellProjections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SingleCellProjections.jl is an easy to use and powerful package for analysis of Single Cell Expression data in Julia. It is faster and uses less memory than existing solutions since the data is internally represented as expressions of sparse and low rank matrices, instead of storing huge dense matrices. In particular, it efficiently performs PCA (Principal Component Analysis), a natural starting point for downstream analysis, and supports both standard workflows and projections onto a base data set.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Source code: SingleCellProjections.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install SingleCellProjections.jl by running the following commands in Julia:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SingleCellProjections\")","category":"page"},{"location":"#Threading","page":"Home","title":"Threading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SingleCellProjections.jl relies heavily on threading. Please make sure to enable threading in Julia to dramatically improve computation speed.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Mimic the real dataset, without actually loading the data.\n# The plots are generated offline and uploaded separately.\n# We might consider actually running the tutorial code here - but then we would need to download files, load more packages and to more computations each time we rebuild the docs.\n\n\n# Useful function to extract a little data from a DataMatrix to use here for show\n# function f(col, n; h=10, t=10, filler=\"\")\n#   @assert h+t <= n\n#   pre = string(col[1:h])\n#   mid = string(\"fill(\\\"\", filler, \"\\\", \", n-h-t, \")\")\n#   post = string(col[end-t+1:end])\n#   string(\"vcat(\", pre, \", \", mid, \", \", post, ')')\n# end\n\n\nusing SingleCellProjections, SparseArrays, DataFrames, LinearAlgebra\nusing UMAP, TSne\n\nfunction load_counts(args...; sample_names, kwargs...) # Shadow SingleCellProjections.load_counts to fake loading!\n    P = 33766\n    N = \"P1\" in sample_names ? 35340 : 42553\n    # X = sparse(Int32[], Int32[], Int[], P, N)\n    # X = sparse(ones(Int32,N), Int32.(1:N), 1:N, P, N)\n\n    I = repeat(Int32[1,2]; inner=N)\n    J = vcat(Int32.(1:N), Int32.(1:N))\n    V = vcat(1:N, div.(N:-1:1,3))\n    X = sparse(I,J,V,P,N)\n\n    v_id = vcat([\"MIR1302-2HG\", \"FAM138A\", \"OR4F5\", \"AL627309.1\", \"AL627309.3\", \"AL627309.2\", \"AL627309.4\", \"AL732372.1\", \"OR4F29\", \"AC114498.1\"], string.(\"dummy_\", 1:33746), [\"CD169\", \"CD28\", \"CD161\", \"CD163\", \"CD138-1\", \"CD164\", \"CD138-2\", \"CD144\", \"CD202b\", \"CD11c\"])\n    v_feature_type = vcat(fill(\"Gene Expression\",33538), fill(\"Antibody Capture\", P-33538))\n\n    v_id[33497:33509] .= string.(\"MT-\", 1:13)\n\n    o_cell_id = vcat([\"P1_L1_AAACCCAAGACATACA\", \"P1_L1_AAACCCACATCGGTTA\", \"P1_L1_AAACCCAGTGGAACAC\", \"P1_L1_AAACCCATCTGCGGAC\", \"P1_L1_AAACGAAAGTTACTCG\", \"P1_L1_AAACGAACAATGAGCG\", \"P1_L1_AAACGAACACTCCTTG\", \"P1_L1_AAACGAACAGCATCTA\", \"P1_L1_AAACGAATCCTCACCA\", \"P1_L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:N-20), [\"P2_L5_TTTGGTTGTCCGAAAG\", \"P2_L5_TTTGGTTTCCTCTAGC\", \"P2_L5_TTTGGTTTCGTAGGGA\", \"P2_L5_TTTGGTTTCTTTGATC\", \"P2_L5_TTTGTTGAGTGTACCT\", \"P2_L5_TTTGTTGGTACGATCT\", \"P2_L5_TTTGTTGGTCCTTAAG\", \"P2_L5_TTTGTTGTCAACACCA\", \"P2_L5_TTTGTTGTCATGCATG\", \"P2_L5_TTTGTTGTCCGTGCGA\"])\n    o_sampleName = vcat(fill(\"P1\",18135), fill(\"P2\", N-18135))\n    o_barcode = vcat([\"L1_AAACCCAAGACATACA\", \"L1_AAACCCACATCGGTTA\", \"L1_AAACCCAGTGGAACAC\", \"L1_AAACCCATCTGCGGAC\", \"L1_AAACGAAAGTTACTCG\", \"L1_AAACGAACAATGAGCG\", \"L1_AAACGAACACTCCTTG\", \"L1_AAACGAACAGCATCTA\", \"L1_AAACGAATCCTCACCA\", \"L1_AAACGAATCTCACTCG\"], string.(\"dummy_\", 1:N-20), [\"L5_TTTGGTTGTCCGAAAG\", \"L5_TTTGGTTTCCTCTAGC\", \"L5_TTTGGTTTCGTAGGGA\", \"L5_TTTGGTTTCTTTGATC\", \"L5_TTTGTTGAGTGTACCT\", \"L5_TTTGTTGGTACGATCT\", \"L5_TTTGTTGGTCCTTAAG\", \"L5_TTTGTTGTCAACACCA\", \"L5_TTTGTTGTCATGCATG\", \"L5_TTTGTTGTCCGTGCGA\"])\n\n    v = DataFrame(id=v_id, feature_type=v_feature_type, name=v_id, genome=\"hg19\", read=\"\", pattern=\"\", sequence=\"\")\n    o = DataFrame(cell_id=o_cell_id, sampleName=o_sampleName, barcode=o_barcode)\n    counts = DataMatrix(X, v, o)\nend\n\nfunction sctransform(counts)\n    # SingleCellProjections.sctransform(counts; use_cache=false, verbose=false)\n    m = SCTransformModel(counts; use_cache=false, verbose=false)\n    nvar = 20239\n    append!(m.params, m.params[mod1.(1:nvar-size(m.params,1),2),:])\n    m.params.id = counts.var.id[1:nvar]\n    project(counts, m; verbose=false)\nend\n\nsvd(args...; nsv, kwargs...) = LinearAlgebra.svd(args...; nsv, subspacedims=nsv, niter=1, kwargs...)\nforce_layout(args...; kwargs...) = SingleCellProjections.force_layout(reduced; niter=1, kwargs...)\n\numap(args...; kwargs...) = UMAP.umap(args...; n_epochs=1, init=:random, n_neighbors=2, kwargs...)\ntsne(data, d; kwargs...) = TSne.tsne(data, d, 0, 1, 5; verbose=false, progress=false, kwargs...) # We might want to speed this up further by running with fewer cells, takes about half of the total doc generation time","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For this example we will use PBMC (Peripheral Blood Mononuclear Cell) data from the paper Integrated analysis of multimodal single-cell data by Hao et al. You can find the original data here, in MatrixMarker (.mtx) format. For convenience, you can download the samples recompressed as .h5 files. Direct links:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Cell annotations (.csv.gz)\nDonor P1 (.h5)\nDonor P2 (.h5)\nDonor P3 (.h5)\nDonor P4 (.h5)\nDonor P5 (.h5)\nDonor P6 (.h5)\nDonor P7 (.h5)\nDonor P8 (.h5)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First we load SingleCellProjections and the packages DataFrames and CSV for handling annotations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SingleCellProjections, DataFrames, CSV","category":"page"},{"location":"tutorial/#Loading-Data","page":"Tutorial","title":"Loading Data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we load samples \"P1\" and \"P2\", by specifiying the paths to the files and naming them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"base_path = \"/path/to/downloads/\";\n\nsample_paths = joinpath.(base_path, [\"GSE164378_RNA_ADT_3P_P1.h5\", \"GSE164378_RNA_ADT_3P_P2.h5\"]);\n\ncounts = load_counts(sample_paths; sample_names=[\"P1\",\"P2\"])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Data sets in SingleCellProjections are represented as DataMatrix objects, which are matrices with annotations for var (variables/genes/features) and obs (observations, typically cells). Above, counts is a DataMatrix where the counts are stored in a sparse matrix. You can also see the available annotations for variables and observations. To access the different parts, use:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts.matrix - For the matrix\ncounts.var - Variable annotations (DataFrame)\ncounts.obs - Observation annotations (DataFrame)","category":"page"},{"location":"tutorial/#Cell-Annotations","page":"Tutorial","title":"Cell Annotations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we compute a new obs annotation where we count the fraction of reads coming from Mitochondrial genes for each cell:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"var_counts_fraction!(counts, \"name\"=>startswith(\"MT-\"), \"feature_type\"=>isequal(\"Gene Expression\"), \"fraction_mt\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the new annotation fraction_mt is present in the output.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will also load some more cell annotations from the provided file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> cell_annotations = CSV.read(joinpath(base_path, \"GSE164378_RNA_ADT_3P.csv.gz\"), DataFrame);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\ncounts.obs.fraction_mt[1:10] = [194/5864,606/9333,176/3251,299/4198,343/5486,473/7379,196/4444,174/5693,160/4525,156/3519]\n\ncsv_str = \"\"\"barcode,nCount_ADT,nFeature_ADT,nCount_RNA,nFeature_RNA,orig.ident,lane,donor,time,celltype.l1,celltype.l2,celltype.l3,Phase,Batch\n          L1_AAACCCAAGAAACTCA,7535,217,10823,2915,SeuratProject,L1,P2,7,Mono,CD14 Mono,CD14 Mono,G1,Batch1\n          L1_AAACCCAAGACATACA,6013,209,5864,1617,SeuratProject,L1,P1,7,CD4 T,CD4 TCM,CD4 TCM_1,G1,Batch1\n          L1_AAACCCACAACTGGTT,6620,213,5067,1381,SeuratProject,L1,P4,2,CD8 T,CD8 Naive,CD8 Naive,S,Batch1\n          L1_AAACCCACACGTACTA,3567,202,4786,1890,SeuratProject,L1,P3,7,NK,NK,NK_2,G1,Batch1\n          L1_AAACCCACAGCATACT,6402,215,6505,1621,SeuratProject,L1,P4,7,CD8 T,CD8 Naive,CD8 Naive,G1,Batch1\n          L1_AAACCCACATCAGTCA,5297,212,4332,1633,SeuratProject,L1,P3,2,CD8 T,CD8 TEM,CD8 TEM_1,G1,Batch1\n          L1_AAACCCACATCGGTTA,7634,219,9333,2672,SeuratProject,L1,P1,7,Mono,CD16 Mono,CD16 Mono,G1,Batch1\n          L1_AAACCCACATGGATCT,8210,222,3589,1122,SeuratProject,L1,P4,2,B,B intermediate,B intermediate lambda,G1,Batch1\n          L1_AAACCCAGTGGAACAC,2847,201,3251,1375,SeuratProject,L1,P1,2,NK,NK,NK_2,G2M,Batch1\n          L1_AAACCCATCCACACCT,4557,209,3401,1200,SeuratProject,L1,P3,2,CD8 T,CD8 Naive,CD8 Naive,S,Batch1\n          L1_AAACCCATCTGCGGAC,5129,212,4198,1318,SeuratProject,L1,P1,0,CD4 T,CD4 TCM,CD4 TCM_1,S,Batch1\n          L1_AAACGAAAGTTACTCG,7630,208,5486,1390,SeuratProject,L1,P1,0,CD4 T,CD4 TCM,CD4 TCM_3,G1,Batch1\n          \"\"\"\ncell_annotations = CSV.read(codeunits(csv_str), DataFrame)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To merge, we use the DataFrames function leftjoin!, since it takes care of matching the cells in counts to the cells in cell_annotations based on the :barcode column.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"leftjoin!(counts.obs, cell_annotations; on=:barcode);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts.obs[34639+1:end,\"celltype.l1\"] .= \"other\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's look at some annotations for the first few cells:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts.obs[1:5,[\"cell_id\",\"sampleName\",\"barcode\",\"fraction_mt\",\"celltype.l1\"]]","category":"page"},{"location":"tutorial/#Transformation","page":"Tutorial","title":"Transformation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The raw counts data is not suitable for analyses like PCA, since the data is far from normally distributed. A common strategy to handle this is to transform the data. Here we will use SCTransform (see also original sctransform implementation in R).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"transformed = sctransform(counts)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From the output, we see that the number of variables have been reduced, since the default sctransform options remove variables present in very few cells and only keeps variables with feature_type set to \"Gene Expression\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The matrix is now shown as A+B₁B₂B₃. This is normally not very important from the user's point of view, but it is critical for explaining how SingleCellProjections can be fast and not use too much memory. Instead of storing the SCTransformed matrix as a huge dense matrix, it is stored in memory as a MatrixExpression, in this case a sparse matrix A plus a product of three smaller matrices B₁,B₂ and B₃.","category":"page"},{"location":"tutorial/#Normalization","page":"Tutorial","title":"Normalization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After transformation we always want to normalize the data. At the very least, data should be centered for PCA to work properly, this can be achieved by just running normalize_matrix with the default parameters. Here, we also want to regress out \"fraction_mt\". You can add more obs annotations (categorical and/or numerical) to regress out if you need.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"normalized = normalize_matrix(transformed, \"fraction_mt\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the matrix is shown as A+B₁B₂B₃+(-β)X', i.e. another low-rank term was added to handle the normalization/regression. The first two terms are reused to make sure memory is not wasted.","category":"page"},{"location":"tutorial/#Filtering","page":"Tutorial","title":"Filtering","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is possible to filter variables and observations. Here we keep all cells that are not labeled as \"other\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"filtered = filter_obs(\"celltype.l1\"=>!isequal(\"other\"), normalized)","category":"page"},{"location":"tutorial/#Principal-Component-Analysis-(PCA)","page":"Tutorial","title":"Principal Component Analysis (PCA)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we are ready to perform Principal Component Analysis (PCA). This is computed by the Singular Value Decomposition (SVD), so we should call the svd function. The number of dimensions is specified using the nsv parameter.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"reduced = svd(filtered; nsv=20)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The matrix is now stored as an SVD object, which includes low dimensional representations of the observations and variables. To retrieve the low dimensional coordinates, use obs_coordinates and var_coordinates respectively.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Principal Component Analysis)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive PCA plot.","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<details>\n<summary>Expand this to show some example PlotlyJS plotting code.</summary>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can of course use your own favorite plotting library instead. Use obs_coordinates to get the coordinates for each cell, and data.obs to access cell annotations for coloring.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PlotlyJS\nfunction plot_categorical_3d(data, annotation; marker_size=3)\n    points = obs_coordinates(data)\n    traces = GenericTrace[]\n    for sub in groupby(data.obs, annotation; sort=true)\n        value = sub[1,annotation]\n        ind = parentindices(sub)[1]\n        push!(traces, scatter3d(;x=points[1,ind], y=points[2,ind], z=points[3,ind], mode=\"markers\", marker_size, name=value))\n    end\n    plot(traces, Layout(;legend=attr(itemsizing=\"constant\")))\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use it like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> plot_categorical_3d(reduced, \"celltype.l1\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"</details>\n<br>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For visualization purposes, it is often useful to further reduce the dimension after running PCA. (In contrast, analyses are generally run on the PCA/normalized/original data, since the methods below necessarily distort the data to force it down to 2 or 3 dimensions.)","category":"page"},{"location":"tutorial/#Force-Layout","page":"Tutorial","title":"Force Layout","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Force Layout plots (also known as SPRING Plots) are created like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fl = force_layout(reduced; ndim=3, k=100)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: force_layout)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive Force Layout plot.","category":"page"},{"location":"tutorial/#UMAP","page":"Tutorial","title":"UMAP","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SingleCellProjections can be used together with UMAP.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using UMAP\n\numapped = umap(reduced, 3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: umap)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive UMAP plot.","category":"page"},{"location":"tutorial/#t-SNE","page":"Tutorial","title":"t-SNE","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, t-SNE plots are supported using TSne.jl. In this example, we just run it one every 10ᵗʰ cell, because t-SNE doesn't scale very well with the number of cells:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TSne\n\nt = tsne(reduced[:,1:10:end], 3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: t-SNE)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive t-SNE plot.","category":"page"},{"location":"tutorial/#Other","page":"Tutorial","title":"Other","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is of course possible to use your own favorite dimension reduction method/package. The natural input for most cases are the coordinates after dimension reduction by PCA (obs_coordinates(reduced)).","category":"page"},{"location":"tutorial/#Projections","page":"Tutorial","title":"Projections","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SingleCellProjections is built to make it very easy to project one dataset onto another.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's load count data for two more samples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sample_paths_proj = joinpath.(base_path, [\"GSE164378_RNA_ADT_3P_P5.h5\", \"GSE164378_RNA_ADT_3P_P6.h5\"]);\n\ncounts_proj = load_counts(sample_paths_proj; sample_names=[\"P5\",\"P6\"]);\n\nleftjoin!(counts_proj.obs, cell_annotations; on=:barcode);\n\ncounts_proj","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"counts_proj.obs[41095+1:end,\"celltype.l1\"] .= \"other\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And project them onto the Force Layout we created above:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fl_proj = project(counts_proj, fl)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The result looks similar to the force layout plot above, since the donors \"P5\" and \"P6\" are similar to donors \"P1\" and \"P2\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: force_layout_projected)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Download interactive Force Layout projection plot.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Under the hood, SingleCellProjections recorded a ProjectionModel for every step of the analysis leading up to the Force Layout. Let's take a look:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fl.models","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When projecting, these models are applied one by one (C.f. output from project above), ensuring that the projected data is processed correctly. In most cases, projecting is not the same as running the same analysis independently, since information about the data set is recorded in the model.","category":"page"}]
}
